[
["index.html", "Introduction to R Chapter 1 INTRO", " Introduction to R Łukasz Muszyński 2018-06-02 Chapter 1 INTRO O jezyku R R jest jezykiem ktory posiada typowanie dynamiczne. Typowanie dynamiczne to przypisywanie typow do wartosci przechowywanych w zmiennych w trakcie dzialania programu. Przy zastosowaniu typowania dynamicznego, zmienne nie posiadaja typow przypisanych statycznie, czyli przed uruchomieniem programu np. w trakcie kompilacji. W takiej sytuacji typ zmiennej wynika z wartosci jaka dana zmienna przechowuje. Jest to jeden ze sposobow na zwolnienie programisty z obowiazku deklarowania typow zmiennych. Ulatwia to operacje na zmiennych, utrudnia natomiast kontrola integralnosci programu. Zmienna moze w roznych momentach wykonania programu przechowywac wartosci roznych typow. R jest jezykiem ktory pozwala na programowanie strukturalne, funkcyjne i obiektowo. R jest jezykiem imperatywnym a nie deskryptywnym. Domyślnie program R pracuje w trybie interpretowanym a nie kompilowanym. Praca w trybie kompilowanym jest możliwa np. dzieki p:complier. W internecie warto sledzic rozwoj R-a i porownania go do innych narzedzi. Ostatnio bardzo popularne są zestawiania R-a z Pytonem: Figure 1.1: Python vs R "],
["syntax.html", "Chapter 2 SYNTAX 2.1 Variables names 2.2 &lt;- vs = 2.3 Using quotation marks [cudzysłów] 2.4 Sterowanie przeplywam [control flow] 2.5 formulas 2.6 LANGUAGE BRICKS (Expression and call)", " Chapter 2 SYNTAX 2.1 Variables names Nie dopuszcza sie rozpoczynania nazw zmiennych od cyfr. Ponadto niedopuszczalne sa znaki takie jak: / * + - &amp; ^ [ ( { ? : ; Dopuszczalne jest stosowanie podkreslnikow oraz kropek, rowniez na poczatku. Zmienna z kropka na poczatku maja pewna wlanosc opisana w ksiazce Gagolewskiego. Zmienna taka bedzie tzw zmienna ukryta i nie bedzie np. widziana domyslnie przez f:ls ktora wyswietla liste zmiennych. W przypadku tworzenia nazw zmiennych warto odwolac sie do regul podanych przez Wickhama w tzw. ‘Style Guide’ w jego podreczniku do zaawansowanego programowania w R ( http://adv-r.had.co.nz/Style.html ). 2.2 &lt;- vs = To make things easier for new users familiar with languages like C, R added the capability in 2001 to also allow = be used as an assignment operator, on the basis that the intent (assignment or association) is usually clear by context. So, x = 3 clearly means “assign 3 to x”, whereas f(x = 3) clearly means “call function f, setting the argument x to 3”. There is one case where ambiguity might occur: if you wanted to assign a variable during a function call. The only way to do this in modern versions of R is: f(x &lt;- 3) which means “assign 3 to x, and call f with the first argument set to the value 3”. This is a contrived example though, and never really occurs in real-world programming. [UPDATE: In fact, constructs like this are best avoided for reasons given in the comments below.] 2.3 Using quotation marks [cudzysłów] Mozna uzywac pojedynczego ' i podwojnego &quot; Wazne jest pamietanie o tym jak stosuje sie cudzyslow w podawaniu argumentow funkcji. Tutaj moga wystapic rozne sytuacja. W wiekszosci funkcji podawanie nazwy argumentu bez cudzyslowia oznacza albo odwolanie sie do zdefiniowanej wczesniej zmiennej albo uzywamy go gdzie podajac argument definiujemy obiekt wektor &lt;- c(1,2,3,4) # definiuje zmienna # ad 1 : tutaj wektor to odwolanie do zmienne ktora zostala wczeniej zdefiniowana sum(wektor) # ad 2:tworze obiekt w trakcie podawania argumentu sum(c(1,2,3,4)) # nastepny przyklad dla f:char ciag_tekstowy &lt;- &#39;ala ma kota&#39; char(ciag_tekstowy) #zwraca dlugosc tekstu char(&#39;ala ma kota&#39;) #dlugosc tekstu stworzonego w trakcie podawania argumentu Ale przeanalizujemy teraz ponizszy przypadek: #tworze tabela z dwoma kolumnami tabela&lt;- data.frame( kolumna_A = 1:10 , kolumna_B = 11:20) # celowo jest tak na odwrot ponizej z nazwami kolumna_B &lt;- &#39;kolumna_A&#39; # ta funkcja wykona nam operacja dodania nowej kolumny o nazwie &quot;suma&quot; to naszej tabeli dplyr::mutate( tabela # tutaj podaje nazwe moje tabeli i dziala to jak poprzednio ,suma = kolumna_B * 10 ) # chce stworzyc nowa kolumne poprzez pomnozenie wartosci innej kolumny przez 10 i tutaj niestety zasada dzilania jest juz inna Powyzej problem polega na tym, ze bedziemy miec zrobiony iloczynu po kolumnie_B a nie kolumnie_A. f:summarise nie traktuje nazwy “kolumna_B” jako odwolania do zdefiniowanej wczesniej zmiennej o nazwie komlumna_B do ktorej przypisalismy nazwe “kolumna_A” !!!. Takie rozwiazanie jest wprowadzone dla wygody zeby nie meczyc sie z cudzyslowiem. Ale pytanie co zrobic jezli jednak bedziemy chcieli zdefiniowac kolumne potrzebna do iloczyny poprzed odwolanie sie do zdefiniowanej wczesniej zmiennej. To bedzie nam potrzebne np. wtedy kiedy w kodzie nie bedziemy z gory wiedziec jaka kolumne bedziemy chcieli zastosowac i zostanie to okreslone w innym miejsu programu, gdzie wybor przypiszemy wlasnie do zmiennej do ktorej bedzie sie trzeba odwolac. Niestety rozwiazania tego problemu jest dosyc skomplikowany zagadnieniem zwiaznanym z manipulowaniem elementami samej skladni jezyka. p:dplyr ma swoj wlasny system rozwiazania tego problemu ktory pokaze wlasnie przy omawianiu tego pakietu. Ponizej natomiast przedstawie jedno z mozliwych uniwersalnych rozwiazan: # jeszcze raz to co w poprzednim chunku ale odwolamy sie do kolumny poprzez zmienna #tworze tabela z dwoma kolumnami tabela&lt;- data.frame( kolumna_A = 1:10 , kolumna_B = 11:20) # celowo jest tak na odwrot ponizej z nazwami kolumna_B &lt;- &#39;kolumna_A&#39; lazyeval::lazy_eval(lazyeval::interp(~dplyr::mutate(tabela, sum = kolumna * 10), kolumna = as.name(kolumna_B))) Jak widac powyzej mamy juz zastosowano kolumne_A do wyliczen ale skladnie jest dosyc skomplikowana. Na szczecie wiekszosc funkcji dla ktorych argumenty definiuje sie w taki sposob nalezy do p:dlyr a tam jest inne duzo wygodniejsze rozwiazanie, ktore pokaze pozniej. Podawanie argumentow funkcji # podajac argujenty mozna podawac ich nazwy mean( x = 1:10 , trim = 0 , na.rm = FALSE) # ale jezeli zachowujemy kolejnosc jak jest to domyslnie w funkcji mozemy nazwy pominac. mean( 1:10 , 0 , FALSE) # mozemy podac argumenty w innej kolejnosci ale wtedy musimy uzywac nazw mean( trim = 0 , na.rm = FALSE , x = 1:10) 2.4 Sterowanie przeplywam [control flow] 2.4.1 petla for skladnia Licznik petli for moze byc po dowolnym wyrazeniu wektorowym (np. macierz liczb-licznik przebiega wtedy po kolejnych kolumnach) typu liczbowgo (zatem moga to byc rowniez ulamki). Petla moze tez isc po innych typach obiektow niz wektory/macierze liczbowe ale nie jest to rozwiazania zalezane ze wzgledu na slaba wydajnosc #wersja 1 skladni np. for(i in 1:10){ print(i) #wyswietl i w konsoli } #wersja 2 skladni bez nawiasow wasatych for(i in 1:10) print(i) # petla po obiekie nieliczbowym (po liscie tesktow) for(i in list(&#39;ala&#39;, &#39;kot&#39;) ) print(i) break i next w petli for W petlach mozna wykorzystywac operacje break (przerwij petle) i next (przejdź do nastepnej iteracji): #break n&lt;-100 for(i in 1:n){ wyrazenia if(n &gt; 10) break # przewywam petle przy spelnieniu warunku } #next n &lt;-100 m &lt;- 20 for(i in 1:n){ wyrazenia if(n == m) next # przechodze do nastepnej interacji przy spelnieniu warunku ze n = m. } Reczne sterowanie licznikiem petli niemozliwe o czym swiadczy ponizszy przyklad s &lt;- 0 for(i in 1:10){ s &lt;- s+i if(i==2) i &lt;-9 # tutaj chce zeby i zwiekszylo sie przy drugiej iteracji do 9 czyli zeby przeskoczyl do dziewiatej interacji petli } s # wartosc sumy pokazuje ze nie nastapilo przeskoczenie # zmienna s ma ta sama wartosc co suma skumulowana suma liczb od 1 do 9 cumsum(1:9) 2.4.2 if Skladnia wersja 1 if(3 &lt; 10) print(&#39;ok&#39;) Skladnia wersja 2 if(3 &gt; 10) { print(&#39;ok&#39;) } Skladnia wersja 3 if(3 &gt; 10) { print(&#39;ok&#39;) }else{ #nawias wasaty powinien byc za &#39;else&#39; a nie pod nim !!! print(&#39;no ok&#39;) } Skladnia wersja 4 z &lt;-10 if(z &gt; 10){ print(&#39;ok&#39;) }else if(z &lt; 5){ print(&#39;ok&#39;) }else{ print(&#39;I do not know&#39;) } 2.4.3 ifelse (czyli wektorowa wersja if) f:ifelse moze dzialal na calym wektorze wartosci logicznych w przeciwieństwie do zwyklego if. f:ifelse mozna zagniezdzac. Niestety czesto wystepuja z nim problemy (np. w pakiecie dplyr). ifelse(c(1,2,3,4,5) &gt; 3 # tutaj dostaniemy caly wektor wartosci logicznych , &#39;ok&#39; # zwraca jezeli TRUE , &#39;zle&#39;) # zwraca jezeli FALSE # wynikiem bedzie wektor wartosci &#39;ok&#39; i &#39;zle&#39; Funkcja ifelse ma swoj dobry subsytut o prawie identycznej nazwie: dplyr::if_else. Ale tu jest jeden fajny bajer bo funkcja automatycznie obsluguje rowniez sytuacje gdy sa braki danych NA dplyr::if_else(c(1,2,3,NA,5) &gt; 3 # dla czwartego elementu jest brak danych NA i porownanie z wartoscia 3 nie nastapi i zwroci nam znowu wartosc NA , &#39;ok&#39; # zwraca jezeli TRUE , &#39;zle&#39; # zwraca jezeli FALSE , &#39;wystapil brak danych&#39; ) #zwraca jezeli NA (brak danych) 2.4.4 while x &lt;- 1 while(x &lt; 10){ x &lt;- x + 1 } x 2.4.5 repeat W f:repeat nie podaje sie ilosci wykonan operacji, ale zagniezdza warunek stopu (przez wyrazenie ‘break’), dlatego trzeba na te strukture uwazac. sum &lt;- 1 repeat { sum &lt;- sum + 2; print(sum); if (sum &gt; 11) break; } 2.4.6 switch Switch to taka kompaktowa wersja ‘if’ Warning! W przypadku f:switch zmienna ktora dostarczamy musi byc typu character czyli tekstem. Cos takiego jak ponizej wywali blad : # ponizej chce zeby f:switch wyswietlila w konsoli odpowiedni napis w zaleznosci od wartosci zmiennej w. Poniewaz w ma wartosc 3 chcialbym zeby bylo wyswietlone &#39;ok&#39; w &lt;- 3 switch(w, # w jest liczba a nie tekstem i dostaniemy blad !!!! 1 = print(&#39;malo&#39;), 2 = print(&#39;malo&#39;), 3 = print(&#39;ok&#39;), 4 = print(&#39;duzo&#39;), print(&#39;lipa&#39;)) # &#39;lipa&#39; ma sie wyswietlac jezeli wartosc zmiennej &#39;w&#39; jest inna niz 1 ,2, 3, lub 4. Musimy zrobic niestety tak zeby to dzialo: w &lt;- 3 switch(as.character(w) # konwertuje liczbe 3 na tekst , &#39;1&#39;=print(&#39;malo&#39;) , &#39;2&#39;=print(&#39;malo&#39;) , &#39;3&#39;=print(&#39;ok&#39;) , &#39;4&#39;=print(&#39;duzo&#39;) , print(&#39;lipa&#39;)) Switch a wykonywanie WIELU operacji jeseli spelniona jest okreslona wartosc a &lt;- 70 # jezeli chce aby przy danym warunku bylo wykonanych kilka operacji uzwywam nawiasow wasatych i srenikow switch( as.character(a) ,&#39;1&#39;=print(&#39;zle&#39;) ,&#39;10&#39;=z &lt;- 4444 # chce ponizej wykonac az 3 dzialania jezeli zmienna &#39;a&#39; nie ma wartosci 1 ani 10. , { w &lt;- 100; #operacja 1 print(&#39;zle&#39;); #operacja 2 z &lt;- 10000} #operacja 3 ) w # sprawdzam czy do w przypisalo sie 100 z # sprawdzam czy do z przypisalo sie 10000 2.5 formulas 2.5.1 Informacje wstepne Formuly to klasa obiektow ktore mozna uzyc np. jako argument w funkcjach wymagajacych rownania (np. f:lm do obliczania regresji ) # stworzenie formuly i przypisanie do zmiennej a &lt;- formula(&#39;y ~ x | z&#39;) class(a) # uzycie formuly w funkcji do liczenia regresji lm( formula = price ~ table + cut # w modelu regresji price to zmienna objasniana a table i cut objasnaijace , data = diamonds) 2.5.2 Przyklady stosowania formul y ~ a #zaleznosc y od a y ~ a + b #zaleznosc y od a i b gdzie a i b sa addytywne y ~ a + b + a:b #zaleznosc y od a i b gdzie a i b sa addytywne, oraz zaleznosc od interakcji a i b y ~ . #zaleznosc y od wszystkich pozostalych zmiennych (zmienne sa addytywne i nie uwzgledniamy interakcji) #zaleznosc od wszystkich zmiennych ale NIE uwzgledniamy WYRAZU WOLNEGO y ~ . - 1 #lub y ~ . + 0 y~.-a #zaleznosc od wszystkich zmiennych z wyjatkiem zmiennej a #Operator I() umozliwia zastosowanie dzialan w ich arytmetycznym sensie: y ~ I(a + b * 2) #zaleznosc od SUMY zmiennych a i b*2 (to nie to samo co y~a+b*2!!!) y ~ lag(x, 2) #y zalezny od opoznionej zmiennej x o 2 okresy #offest-zeby dodac zmienna dla ktorej wspolczynnik nie jest estymowany (jest na sztywko rowny 1). Przyklad dla f:glm liczacej np. regresje logistyczna glm( Y ~ offset(log(N)) + (x1 + x2) , family=poisson) # wprowadzenie warunkowosci - ale interpretacja tutaj zalezy od tego w jakiej metodzie statystycznej to zastosujemy response ~ predictor | condition #Zastosowania znaku mnozenia #Znak mnozenia * zastepuje nam addytywnosc i interakcje w analizie ANOVA. Nie ma to zastosowania przy regresji. (Biecek str 166) y ~ a * b #to to samo co: y ~ a + b + a : b 2.5.3 Formula a tekst # srpbujemy formule przesztalcic na text funkcja do konwertowania obiektow na tekst a1 &lt;- as.character(formula(&#39;y ~ x | z&#39;)) a1 # okazuje sie ze dostlismy 4 elementy tekstowe # jezeli chcemy formule przeksztalcic w jeden ciag tekstowy ktory wyglada tak jak orryginalna formula stosujemy: a2 &lt;- deparse(formula(&#39;y ~ x | z&#39;)) a2 # teraz mamy jeden ciag tekstowy 2.5.4 Wyciaganie elementow formuly z &lt;- formula(&#39;y ~ x | z&#39;) #wyciagniecie wszystkich elementow formuly terms.formula(z) #wyciagam tylko zmienne all.vars(z) 2.5.5 Modyfikacja formul z &lt;- formula(y ~ 1 + x + w^2 + u + i + u:i) # do formuly z daodaje zmienna &#39;ze&#39;, usuwam zmienna &#39;x&#39; i usuwam interacje &#39;u:i&#39; update(z, ~ . + ze - x - u:i) # w formule nie moze byc cyfr mnozacych cale addytywne wyrazenia poza jedynka oznaczajaca wyraz wolny (przyklad bledu: y ~ 1+2*x) #you can also modify left side of formula update(z, log(.) ~ . ) #logarytmuje cala lewa strone formuly (kropka zastepue nam) # jeszcze raz usuwam zmienna (tym razem &#39;y&#39;) update(z, ~ . -y) #usuwam zmienna &#39;y&#39; i na jej miejsce dodane &#39;log(y)&#39; update(z, ~ . -y +log(y)) 2.5.6 Dynamiczne tworzenie formuly LINIOWEJ z zadanych elementow Ponizsz funkcja umozliwia tworzenie z zadanych elementow prostych liniowych formul. z &lt;- c(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;) #zmienne objasniajace d &lt;- &#39;y&#39; # zmienna objasniana reformulate( termlabels = z #zmienne objasniajace , response = d #zmienna objasniana , intercept = TRUE) # czy formula ma miec wyraz wolny 2.6 LANGUAGE BRICKS (Expression and call) Basic terms constant-e.g. 1, ‘a’, TRUE, FALSE name (called also symbols)- names of functions, variables and the like call - expression which can executed by R. call is recursive, so call can include another call. expression - group of calls. 2.6.1 evaluating call and expressions eval() 2.6.2 names #to get name: quote(z) as.name(&#39;z&#39;) as.symbol(&#39;z&#39;) #to check if name z &lt;- as.name(z) z # we will get name, not string &#39;z&#39; are any other value is.name(z) is.symbol(z) 2.6.3 converting call and expression #expression (not call!!!) from string parse(text=&#39;z&lt;-100&#39;) #text is not a first parametr so you have to specify it manually. #call to string deparse(quote(z &lt;- 100)) 2.6.4 creating call #1. quote(z &lt;- 100) #2. w &lt;- 100 bquote(z = b + .(w)) #dynamic substitution with .() #warning: problem with &#39;=&#39; z&lt;-&#39;ble&#39; bquote({.(as.name(z)) = w})[[2]] #use paranthesis to solve problem #3. substitute(z &lt;- 100) #4. w&lt;-&#39;price&#39; substitute(target &lt;- 100, list(target=as.name(w))) #warning: problem with &#39;=&#39; . I have no ide what to do with that. #5. substitute(z &lt;- w, list(w=100)) 2.6.5 get elements of expression p &lt;-parse(text=&#39;z&lt;-100&#39;) p[[1]] 2.6.6 get elements of call z &lt;- quote(z + w + 200 + 500) all.vars(z) #names of variables all.names(z) #all names z[[1]] #first element 2.6.7 change functions parameters in call expressions z &lt;- quote(mean(x=c(1,2,3,4), trim=.3)) z$trim &lt;- .6 z 2.6.8 call vs expression You should use expression when you want its capacity to hold more than one expression or call. It really returns an “expression list”. The usual situation for the casual user of R is in forming arguments to ploting functions where the task is forming symbolic expressions for labels. R expression-lists are lists with potentially many items, while calls never are such. It’s interesting that (???)’s Advanced R Programming suggests “you’ll never need to use [the expression function]”: http://adv-r.had.co.nz/Expressions.html. Parenthetically, the bquote function is highly useful, but has the limitation that it does not act on more than one expression at a time. I recently hacked a response to such a problem about parsing expressions and got the check, but I thought (???)’s answer was better: R selectively style plot axis labels The strategy of passing an expression to the evaluator with eval( expr, envir= &lt; a named environment or list&gt;) is essentially another route to what function is doing. A big difference between expression and call (the functions) is that the latter expects a character object and will evaluate it by looking for a named function in the symbol table. When you say that processing both with the eval “works”, you are not saying it produces the same results, right? The D function (call) has additional arguments that get substituted and restrict and modify the result. On the other hand evaluation of the expression-object substitutes the values into the symbols. There seem to be “levels of evaluation”: expression(mean(1:10)) # expression(mean(1:10)) call(&quot;mean&quot; , (1:10)) # mean(1:10) eval(expression(mean(1:10))) # [1] 5.5 eval(call(&quot;mean&quot; , (1:10))) # [1] 5.5 2.6.9 quote vs expression expression returns its arguments as a vector of unevaluated expressions. quote returns its argument as an unevaluated expression. 2.6.10 dynamic formulas y &lt;- &#39;price&#39; as.formula(paste(&#39;x~&#39;,y,sep=&#39;&#39;)) y &lt;- &#39;price&#39; as.formula(bquote(x~.(as.name(y)))) y &lt;- &#39;price&#39; as.formula(substitute(x~target, list(target=as.name(y)))) 2.6.11 Functions 2.6.11.1 call, do.call, match.call W f:call podajemy elementy ktore nie a przekazywane w postaci listy (w przeciwienstwie do f:do.call). Jezeli nie podajemy nazw parametrow musimy zachowac dobra kolejnosc. Otrzymujemy w wyniku niewyliczone wyrazenie typu call. Kolejnosc argumentow bedzie taka jak podalismy w f:call wiec nie musi sie zgadzac z kolejnoscia argumentow jaka jest domyslnie w funkcjach. Uwaga f:match.call mozna tez uzywac wewnatrz funkcji zeby pobrac wartosc wprowadzonych w funkcji argumentow (wiecej infro patrz w rozdziale o funkcjach). W f:match.call podajemy parametry i nazwe funkcji call wraz z ich PELNYMI nazwami parametrow. otrzymane wyrazenie bedzie mialo argumenty zgodne z porzadkiem argumentow w funkcji. Otrzymujemy niewyliczone wyrazenie typu call. Kolejnosc argumentow bedzie sie zgadzac z kolejnoscia argumentow jaka jest domyslnie w funkcjach (to podstawowa roznica w stosunku do f:call i f:sys.call). W f:do.call parametry podajemy w liscie bez koniecznosci podawania nazw parametow-nalezy zachowac wtedy kolejnosc. Dostajemy wynik OBLICZONEGO wyrazenia. #call a match.call call(&#39;rnorm&#39;, sd=10, n=20) # otrzymamy wyrazenie w ktorym kolejnosc jest taka jak podana w funkcji call match.call(rnorm, call(&#39;rnorm&#39;, sd=10, n=20)) # otrzymane wyrazenie bedzie mialo argumenty zgodne z porzadkiem argumentow w funkcji. #call i quote call(&#39;round&#39;, quote(2+6.8)) # wersja gdzie pierwszy argument jest jako character match.call(eval(as.name(&#39;rnorm&#39;)), call(&#39;rnorm&#39;, sd=10, n=20)) 2.6.11.2 f:substitute z &lt;- substitute(a + b, list(a=1, b=2) ) #zwroci nam call a nie expression!!! class(z) eval(z) #takie cos nie ma sensu: z &lt;- substitute(expression(a + b), list(a=1, b=2) ) class(z) eval(z) #dostaniemy wyrazenie typu call ktore nie bedzie zinterpretowane tak aby je wyliczyc!!! #uwaga. Cos takiego jest niedozwolone. 1 jest podstawione automatycznie po obu stronach rownania co prowadzi do sprzecznosci!!! z &lt;- substitute(x &lt;- x + 1, list(x = 1)) eval(z) #nieprawidlowe uzycie substitute z &lt;- expression(a+b) a = 3 b = 4 eval(z) #do tego momentu ok y &lt;- substitute(z, list(a=1, b=2) ) #nie zadziala prawidlowo. &#39;z&#39; nie jest widziane jako zmienna eval(y) "],
["functions-and-environemnts.html", "Chapter 3 FUNCTIONS AND ENVIRONEMNTS 3.1 Functions 3.2 Environments 3.3 Environment and variables scope 3.4 Macros", " Chapter 3 FUNCTIONS AND ENVIRONEMNTS 3.1 Functions 3.1.1 Types of functions Types of functions we can meet (this division is not exclusive) Primitive vs closure: Primitive functions are only found in the base package, and since they operate at a low level, they can be more efficient (primitive replacement functions don’t have to make copies), and can have different rules for argument matching (e.g. switch and call). This, however, comes at a cost of behaving differently from all other functions in R. Hence R core generally avoids creating them unless there is no other option. Jest jeszcze kategoria ‘internal’ podobna do ‘primitive’. Duzo o ‘internal’ i ‘primitive’ jest w artukule Wickhama R’s C interface (link), oraz na stronie (link) Generic functions - Generic functions (objects from or extending class genericFunction) are EXTENDET function objects, containing information used in creating and dispatching methods for this function. They also identify the package associated with the function and its methods. Generalnie sa to funkcje kore mozna przeciazac (staja sie tak jakby metodami dla klas obiektow). Replacement functions [funkcje podstawieniowe]. Funkcje uzywajace operatora przypisania &lt;- slozace do wygodnego modyfikowania wlasciwosci obiektu. Warto tez poczytac o infix operator: https://www.datamentor.io/r-programming/infix-operator #czy funkcja jest &#39;primitive&#39;: is.primitive(&#39;mean&#39;) # Czy funkcja jest &#39;generic&#39;: require(methods) isGeneric(&#39;mean&#39;) #to jest chyba lista primitive functions nms &lt;- names(methods:::.BasicFunsList) 3.1.2 Extracting function code Extracting methods depends on type of function Just press F2-not always give you detailed code If it is primitive or internal function use f:show_c_course(pryr). pryr::show_c_source(.Internal(mean(x))) pryr::show_c_source(.Primitive(sum(x))) If it is S3 method use f:getS3method(utils)-see example below: # Extractig code from s3 method #step 1-check if it is s3 object require(pryr) pryr::ftype(weighted.mean) # step 2-see all classes methods(weighted.mean) # step 3-find class you are interested in. Usually &#39;default&#39; has more intresting code. require(utils) getS3method(f = &#39;weighted.mean&#39;, class = &#39;default&#39;) If it is S4 method use f:getMethod(‘methods’) require(Matrix) # pakiet z funkcja ktora ma metode S4 # sprawdzam czy niteresujaca funkcja jest typu S4 pryr::ftype(chol2inv) # wyswietlam jakie sa dostepne metody dla tej funkcji showMethods(chol2inv) # funkcja chol2inv # wyswietl kod dla metody chol2inv getMethod(&#39;chol2inv&#39;, &#39;C&#39;) findMethod(&#39;chol2inv&#39;, &#39;diagonalMatrix&#39;) 3.1.3 Functions defining z &lt;- function(x, y, z=10) #z is default value. Names &#39;x&#39;, &#39;y&#39; i &#39;z&#39; refers only to variables INSIDE function. { a &lt;- 10 #przypisanie lokalne b &lt;&lt;- 100 #przypisanie globalne return() #to co ma byc zwrocone. Moze to byc dowolny typ danych (macierz, lista, wektor itp) } 3.1.4 Unspecified formal arguments [argumenty nadmiarowe] z &lt;- function(x,...) #argumenty nadmiarowe beda przekazane do funkcji zagniezdzonej { g(y, w, ...) } Przyklad: www &lt;- function(x,...) { z &lt;- list(...) return(x + z[[2]]) } www(x=2, y=100, u=300) How to check if we passed any argument? fff &lt;- function(...){ if(length(list(...))==0){ print(&#39;there is nothing&#39;) }else{ print(&#39;there is something&#39;) } } 3.1.5 functions arguments without quotation marks 3.1.5.1 Dla okreslonej ilosci argumentow z &lt;- function(x){ z &lt;- deparse(substitute(x)) return(z) } z(tr) # exapmple 1 l.fff &lt;- function(a) { z &lt;- deparse(substitute(a)) diamonds[1:10, z] } l.fff(cut) # example 2 l.fff1 &lt;- function(a) { abc &lt;- deparse(substitute(a)) dplyr::select(.data = diamonds[1:10,], eval(parse(text=abc )) ) } l.fff1(cut) #warning - proble with Handley&#39;s functions l.fff1 &lt;- function(a) { z &lt;- deparse(substitute(a)) dplyr::select(.data = diamonds[1:10,], eval(parse(text=z )) ) # it will return always &quot;z&quot; variable } l.fff1(cut) This solution works for both arguments with quotations marks and without it. # example 3 get_column &lt;- function(zmienna){ if(&#39;character&#39; %in% class(substitute(zmienna))){ zmienna_ost &lt;- zmienna }else{ zmienna_ost &lt;- deparse(substitute(zmienna)) } diamonds[1:10, zmienna_ost] } get_column(cut) get_column(&quot;cut&quot;) 3.1.5.2 Dla nieokreslonej ilosci argumentow foo &lt;- function(a, ...) { arg &lt;- deparse(substitute(a)) dots &lt;- substitute(list(...))[-1] c(arg, sapply(dots, deparse)) } x &lt;- 1 y &lt;- 2 z &lt;- 3 foo(x,y,z) 3.1.6 recursive function 3.1.6.1 f:Recall f:Recall is useful when you will need to rename function fib &lt;- function(n) if(n&lt;=2) { if(n&gt;=0) 1 else 0 } else Recall(n-1) + Recall(n-2) fibonacci &lt;- fib; rm(fib) ## renaming wouldn&#39;t work without Recall fibonacci(10) # 55 If not you can use name of function for recursion: fib &lt;- function(n) if(n&lt;=2) { if(n&gt;=0) 1 else 0 } else fib(n-1) + fib(n-2) fib(10) Ciag fibbociego w dwoch wersjach fib_1 &lt;- function(n){ if(n&lt;=2){ if(n&gt;=0) 1 else 0 } else{ fib_1(n-1) + fib_1(n-2) } } fib_1(5) fib_2 &lt;- function(n){ if(n&lt;=2){ if(n&gt;=0) return(1) else return(0) } else{ a &lt;- fib_2(n-1) b &lt;- fib_2(n-2) return(list(fib_2(n-1)[[1]] + fib_2(n-2)[[1]], a, b )) } } fib_2(6) fib_2(6) %&gt;% listviewer::jsonedit() Pouczajacy przykad funkcji rekurencyjnej do liczenia sumy skumulowej w roznych wariantach. # suma rekurencyjna - ciagniecie w dol f1 &lt;- function(s=0,x){ if(x&lt;1){ return(s) }else{ s&lt;-s+x f1(s=s,x=x-1) } } f1(0,10) # suma rekurencyjna - normalna rekurencja f2 &lt;- function(x){ if(x&lt;1){ return(0) }else{ x+f2(x-1) } } f2(10) # suma rekurencyjna - zwykla rekurencja plus zapis sanych o poszczegolnych sumach i poszczegolnych dodawanych wartosiach f3 &lt;- function(x){ if(x &lt; 1){ return(list(0,0)) }else{ list(x+f3(x-1)[[1]], x, f3(x-1)) } } f3(10) # przypadek w ktorym dostaniemy ostateczna sume i element dodany poprzedni element. Dlaczego dostaniemy tylk tylt??? f4 &lt;- function(x){ if(x &lt; 1){ return(list(0,0)) }else{ list(x+f4(x-1)[[1]], x-1) } } f4(10) Ciagniecie informacji w gore dla listy lista &lt;- list(a=5, b=list(c=20, d=list(e=50, f=100))) f5 &lt;- function(x){ if(is.numeric(x)){ x }else{ list(sum( unlist(x) ), lapply(x, f5) ) } } f5(lista) 3.1.7 create infix function &#39;%moje_dzialanie%&#39; &lt;- function(x,y) #in real syntax use tits instead of single quote { z &lt;- x^2+y^3 return(z) } x = 10 y = 20 x%moje_dzialanie%y 3.1.8 replacement functions [funkcje podstawieniowe] Przy definiowaniu funkcji w nazwie musi byc symbol &lt;-. Na końcu musi byc podany argument value. #example 1: ponizsza funkcja konwertuje wartosci powyzej 50 na inf. &#39;cutoff&lt;-&#39; &lt;- function(x, value){ #in real syntax use tits instead of single quote x[x &gt; value] &lt;- Inf x } x &lt;- 1:100 cutoff(x) &lt;- 50 x #example 2: the following function allows you to modify the second element of a vector: &#39;second&lt;-&#39; &lt;- function(x, value) { #in real syntax use tits instead of single quote x[2] &lt;- value x } x &lt;- 1:10 second(x) &lt;- 5L x 3.1.9 missing myplot &lt;- function(x, y) { if(missing(y)) { y &lt;- x x &lt;- 1:length(y) } plot(x, y) } 3.1.10 pmatch pmatch(&quot;m&quot;, c(&quot;mean&quot;, &quot;median&quot;, &quot;mode&quot;)) # returns NA pmatch(&quot;med&quot;, c(&quot;mean&quot;, &quot;median&quot;, &quot;mode&quot;)) # returns 2 3.1.11 Overloading functions [przeciazanie funkcji]-(concern generic functions) For more information see: objective orientated programing. plot.logical=function(obiekt) #overloading f:plot for &#39;logical&#39; data type. { } 3.1.12 Arguments values from give vector center &lt;- function(x, type = c(&#39;mean&#39;, &#39;median&#39;, &#39;trimmed&#39;)) { type &lt;- match.arg(type) switch(type, mean = mean(x), median = median(x), trimmed = mean(x, trim = .1)) } x &lt;- c(runif(100)) center(x, &#39;mean&#39;) center(x, &#39;median&#39;) center(x,&#39;ble&#39;) #wywali blad bo nie ma tego na liscie require(tables) tabular( (Species + 1) ~ (n=1) + Format(digits=2)*(Sepal.Length + Sepal.Width)*(mean + sd), data=iris ) require(tables) require(xtable) z1 &lt;- tabular( (Species + 1) ~ (n=1) + Format(digits=2)*(Sepal.Length + Sepal.Width)*(mean + sd), data=iris , html=F) html(tabular( (Species + 1) ~ (n=1) + Format(digits=2)*(Sepal.Length + Sepal.Width)*(mean + sd), data=iris )) require(tables) mydf &lt;- data.frame(rowFactor1 = sample(letters[1:2], 100, replace = TRUE), colFactor1 = sample(LETTERS[1:2], 100, replace = TRUE), x = rnorm(100), rowFactor2 = sample(1:2, 100, replace = TRUE), colFactor2 = sample(1:2, 100, replace = TRUE)) tab1 &lt;- tabular(Heading()*RowFactor(rowFactor2, spacing = 1, levelnames = c(&quot;rowLabel1&quot;, &quot;rowLabel2&quot;))* Heading()*RowFactor(rowFactor1, levelnames = c(&quot;b1&quot;, &quot;b2&quot;)) ~ Heading()*Factor(colFactor2, levelnames = c(&quot;colLabel1&quot;, &quot;colLabel2&quot;) )* Heading()*Factor(colFactor1, levelnames = c(&quot;a1&quot;, &quot;a2&quot;))* Heading()*(x)*Heading()*(mean), data = mydf) html(tab1) require(xtable) require(ggplot2) print(xtable(head(diamonds)), type=&#39;html&#39;, html.table.attributes=&#39;class=&quot;sortable&quot;&#39;) Red Orange Yellow Green Blue asdfdsafdsaf red red red red red red orange orange orange orange orange sadfsdaf yellow yellow yellow yellow yellow sadfvdasf green green green green green weefsdaf blue blue blue blue blue 3.1.13 conditionals values of arguments f &lt;- function(x, y=ifelse(x&lt;10,0,10)){ print(y) } f(5) f(20) 3.1.14 f:formals #lista argumentow funkcji formals(lm) #&gt; przypisanie wartosci zmiennych #przyklad_1 f &lt;- function(x) a+b formals(f) &lt;- alist(a = , b = 3) # function(a, b = 3) a+b f(2) # result = 5 #przyklad 2 b &lt;- 40 f &lt;- function(x) 100 * x + b formals(f) &lt;- alist(x=10, b=30) f() f() #&lt; Wyciagane argumentow funkcje w jej srodku function_1 &lt;- function(a, b, c){ formals(sys.function()) } function_1() 3.1.15 functions factory #creating function witch output is albo a function poisson_nll &lt;- function(x) { n &lt;- length(x) sum_x &lt;- sum(x) function(lambda) { #returned function n * lambda - sum_x * log(lambda) # + terms not involving lambda } } x1 &lt;- c(41, 30, 31, 38, 29, 24, 30, 29, 31, 38) x2 &lt;- c(6, 4, 7, 3, 3, 7, 5, 2, 2, 7, 5, 4, 12, 6, 9) #create new functions nll1 &lt;- poisson_nll(x1) nll2 &lt;- poisson_nll(x2) #using new functions nll1(c(1,20)) nll2(c(1,20)) How to check body of new function #raw body nll1 #substituted value of x (when we produce new function they differ in x) as.list(environment(nll1)) 3.1.16 function operator chatty &lt;- function(f) { function(x, ...) { res &lt;- f(x, ...) cat(&quot;Processing &quot;, x, &quot;\\n&quot;, sep = &quot;&quot;) res } } f &lt;- function(x) x ^ 2 s &lt;- c(3, 2, 1) chatty(f)(1) 3.2 Environments 3.3 Environment and variables scope 3.3.1 Types of environment in R srodowisko gdzie obiekt jest przechowywany [chyba binding environment] (wyszukujemy f:ls) srodowisko gdzie obiekt zostal utworzony [enclosing environment] (dla obietow ktore sa funkcjami uzywamy f:environment(obiekt). W przypadku np. danych to pojęcie chyba nie ma zastosowania. Do czego miałaby się przydać informacja o miejscu utworzeniu zmiennej? Wystarczy jej lokalizacja). srodowisko ktore wywolalo obiekt [calling environments] (f:parent.frame) srodowisko parent parent einvironment srodowisko wykonywania operacji [execution environment] (f:environment() ) Uwga ad. punkt 2. f:environment ktora jako argument ma podana funkcje zwraca ta kutra jest aktualnie dostepna w przestrzeni. Jezeli chcemy odwolac sie do konkretnej przestrzeni stosujemy np: environment(plyr::summarise) “The enclosing environment determines how the function finds values; the binding environments determine how we find the function” 3.3.1.1 srodowisko gdzie obiekt jest przechowywany #kom do identyfikacji obiektu uzywamy funkcji #lista zmiennych w srodowisku globalnym ls(envir = .GlobalEnv) &lt;small class=&#39;Sblack&#39;&gt;Uwaga!: odwolanie do srodowiska globalnego przez `.GlobalEnv`&lt;/small&gt; #&gt; odwolanie do zmiennych w innym srodowisku new_env &lt;- new.env(parent = .GlobalEnv) #tworze srodowisko assign(x = &#39;x&#39;, value = 1:10, envir = new_env) # w srodowisku tworze wektor &#39;x&#39; o wartosciach 1:10 ls(envir=new_env) #lista zmiennych w nowym srodowisku o nazwie &#39;new_env&#39; #&lt; 3.3.1.2 srodowisko gdzie obiekt zostal utworzony funkcja_bylejaka &lt;- function(){ print(100) } environment(funkcja_bylejaka) 3.3.1.3 srodowisko ktore wywolalo obiekt funkcja_1 &lt;- function(){ funkcja_2() environment() # wyciagam nazwe sorowiska f:funkcja_1 } funkcja_2 &lt;- function(){ print(100) print(parent.frame()) # wyciagam nazwe srodowiska funkcji ktore wywolala f:funkcja_2. Jest to f:funkcja_1 } funkcja_1() Srodowisko ktore wywolalo funkcje-informacje wyciagana we wnetrzu funkcji. get_encoling_enviroment &lt;- function(){ ft &lt;- function(){ env_parent &lt;- parent.frame() call_ &lt;- sys.call() call_ list(eval(substitute(environment(x), list(x=as.name(call_[[1]])))), env_parent, environment(mean)) } ft() } get_encoling_enviroment() 3.3.1.4 srodowisko paren env_1 &lt;- new.env() env_2 &lt;- new.env(parent = env_1) parent.env(env_1) parent.env(env_2) #zmiana srodowiska parent parent.env(env_2) &lt;- .GlobalEnv parent.env(env_2) 3.3.1.5 srodowisko pracy #bierzace srodowisko pracy environment() 3.3.1.6 lexical scoping rules Jezeli kod wewnatrz funkcji nie znajdzie zmiennej w jej wnetrzu to szuka w srodowisku otaczjacym. Środowisko otaczajace definiuje sie wzgledem miejsca gdzie FUNKCJA ZOSTALA STWORZONA, a nie gdzie znajduje sie aktualnie (tzw. laxical scoping). Example of how does scoping rule works: x&lt;-100 f1 &lt;- function(){ x&lt;-200 return(f2()) } f2 &lt;- function(){ return(10+x) } f1() # we will get 110 !!! (not 210) 3.3.1.7 Odwolanie przez referencje - sposob najprostszy Mozna tez zastosowac p:R.oo set &lt;- function(x, value){ eval.parent(substitute(x &lt;- value)) } valX &lt;- 51 set(valX ,10) valX #uzyskamy wartosc 10 a nie 51 !!! addOne_1 &lt;- function(x,value){ eval.parent(substitute(x &lt;- x + 1)) } valX &lt;- 51 addOne_1(valX) valX Note that you could not change the value of x inside the function. If you change the value of x, a new object will be created. The substitute function will replace x with the new value and hence this method wont work. For example: addOne_2 &lt;- function(x,value){ x &lt;- x + 1 eval.parent(substitute(x &lt;- x)) } valX &lt;- 51 addOne_2(valX) #Otrzymamy blad: Error in 52 &lt;- 52 : invalid (do_set) left-hand side to assignment If you want to change the value of x inside the function, you have to copy x to a new object and use new object as x. At the end of the function, you can replace the value of x with the new object at the parent environment. addOne_3 &lt;- function(x, value){ xx &lt;- x xx &lt;- xx + 1 eval.parent(substitute(x &lt;- xx)) } valX &lt;- 51 addOne_3(valX) valX #p substitute quote eval parse deparse call all.names(q) #k z &lt;- unlist(quote({z &lt;- 100; w &lt;- 200})) z_p &lt;- parse(text=&#39;z&lt;-100&#39;) mode(z_p) mode(z_p[[1]]) q &lt;- quote(z &lt;- 100 + 200) unlist(q) mode(q[[3]]) mode(q[[3]][[1]]) mode(quote({z &lt;- 100; w &lt;- 200})) mode(substitute(z &lt;- 100)) mode(substitute({z &lt;- 100; w &lt;- 200})) unlist(call(&#39;z&lt;-100&#39;)) 3.3.1.8 environments - basic operations Informacje (dosc zaskakujace) o strukturze srodowisk w programie R sa w ksiazcek Gagolewskiego. Warto tez zajec do artykulu Wickhama pt. Environments (link) #new environment zz &lt;- new.env() #ASSIGNING variable to environment assign(&#39;a&#39;, 100, envir=zz) assign(&#39;b&#39;, 200, envir=zz) assign(&#39;c&#39;, 300, envir=zz) zz$d &lt;- 400 zz$e &lt;- 500 #zrzucenie do listy elementow ze srodowiska w &lt;- as.list(zz) #REMOVING zmiennej &#39;a&#39; ze srodowiska &#39;zz&#39; rm(&#39;a&#39;, envir=zz) #USUNICIE WSZYSTKICH elementow z danego srodowiska rm(list=ls(srod1, all.names=TRUE), envir=srod1) #not run #WYSWIETLENIE zmiennej &#39;b&#39; ze srodowiska &#39;zz&#39; get(&#39;b&#39;, envir=zz ) #w jakim otoczniu (w jakim innym srodowisku) jest SRODOWISKO &#39;zz&#39; parent.env(zz) #LISTA zmiennych w danym srodowisku ls(envir=zz) #czy zmienna &#39;b&#39; ISTNIEJE w srodowisku &#39;zz&#39; exists(&#39;b&#39;, envir=zz, inherits=T) #funkcja wywolujaca globalenvironment (jest to funkcja , dlatego sa nawiasy okragle) globalenv() #nazwa srodiwska globalnego (you gives it as a parameter in some functions) .GlobalEnv 3.3.1.9 Nesting environments #tworzenie srodowiska w srodowisku g1 &lt;- new.env() g2 &lt;- new.env(parent = g1) g3 &lt;- new.env(parent = g2) assign(&#39;a&#39;, 100, envir=g1) #przypisanie zmiennej do srodowiska g1 #pobieram ze srodowiska g2. Nie ma jej tam, ale jest w srodowisku otaczajacym g1. Jesli nie bylo by w g1 poszukiwania byly by kontynuowane w kolejnym nadrzednym srodowisku poniewaz parametr inherits jesst ustawiony domylsnie na TRUE. . get(&#39;a&#39;, envir = g2) ls(patter=&#39;^g&#39;) #funkcja zwroci srodowiska zagniezdzone w innych, zatem dostaniem g1 i zagniezdzone w niej g2 zagniedzone w g2 srodowisko g3. #zwraca rodzica srodowiska g3 niestety nie jest to jego nazwa parent.env(g2) #usuniecie srodowiska nie powoduje usuniecia srodowisk w nim zagniezdzonych rm(g1) ls(patter=&#39;^g&#39;) #co wiecej jako rodzic dalej pokazywane jest srodowisko usuniete. parent.env(g2) #ustawienie otoczenia parent.env(g3) &lt;- g2 Uwaga Srodowisko moze byc argumentem funkcji. W takiej sytuacji operacje wykonywane na srodowisku zostawiaja w nim zmiany po skonczeniu dzialania funkcji. 3.3.2 Different functions to work with environments 3.3.2.1 operator przypisania Uwaga Operator &lt;&lt;- przypisuje do srodowiska otaczajacego a niekoniecznie do globalenvironment. It helps to think of &lt;&lt;- as equivalent to assign (if you set the inherits parameter in that function to TRUE). The benefit of assign is that it allows you to specify more parameters (e.g. the environment), so I prefer to use assign over &lt;&lt;- in most cases. Using &lt;&lt;- and assign(x, value, inherits=TRUE) means that “enclosing environments of the supplied environment are searched until the variable ‘x’ is encountered.” In other words, it will keep going through the environments in order until it finds a variable with that name, and it will assign it to that. This can be within the scope of a function, or in the global environment. In order to understand what these functions do, you need to also understand R environments (e.g. using search). I regularly use these functions when I’m running a large simulation and I want to save intermediate results. This allows you to create the object outside the scope of the given function or apply loop. That’s very helpful, especially if you have any concern about a large loop ending unexpectedly (e.g. a database disconnection), in which case you could lose everything in the process. This would be equivalent to writing your results out to a database or file during a long running process, except that it’s storing the results within the R environment instead. My primary warning with this: be careful because you’re now working with global variables, especially when using &lt;&lt;-. That means that you can end up with situations where a function is using an object value from the environment, when you expected it to be using one that was supplied as a parameter. This is one of the main things that functional programming tries to avoid (see side effects). I avoid this problem by assigning my values to a unique variable names (using paste with a set or unique parameters) that are never used within the function, but just used for caching and in case I need to recover later on (or do some meta-analysis on the intermediate results). 3.3.2.2 detach attach Attach umozliwia dostep do ramki/listy bezposrednio. Detach uniemozliwia taka operacje. Trzeba sie odwolywac posrednio. a &lt;- 100 d &lt;- data.frame(a=1, b=2) attach(d) a #bedziemy mieli informacje o zakryciu zmienne z ramki. Zatem &#39;a&#39; bedzie oznaczalo tutaj dostep do zmiennej o wartosci 100. 3.3.2.3 with, within Roznica miedzy f:with i f:within: f:within is similar, except that it examines the environment after the evaluation of expr and makes the corresponding modifications to data (this may fail in the data frame case if objects are created which cannot be stored in a data frame), and returns it. within can be used as an alternative to transform. require(MASS) #do danych &#39;anorexia&#39; anorexia$wtDiff &lt;- with(anorexia, Postwt - Prewt) anorexia &lt;- within(anorexia, wtDiff2 &lt;- Postwt - Prewt) anorexia &lt;- transform(anorexia, wtDiff3 = Postwt - Prewt) 3.3.2.4 local Umozliwia m.in robienie obliczeń ‘na boku’. Wynik local przypisujemy do zmiennej. Zostanie przypisany ostatni element w klamrach (zgodnie z regula dzialania klamr). z &lt;- local({ w &lt;- 100 u &lt;- 200 }) z #zwroci 200 3.3.3 wyszukiwanie i usuwanie zmiennych Sluza do tego przede wszystkim takie funkcje jak rm, ls, ls.str, lsf.str,exists, get. 3.3.3.1 ls Podstaje lista zmiennych w danym srodowisku. Zwraca poza zmiennymi funkcje i srodowiska. F:ls dziala rowniez dla data.frame i list. Funkcja domyslnie pomija zmienne zaczynajace sie od znaku kropki . #Dosylnie zwracane sa elementy z srodowiska globalnego ls() #lista elementow w danym srodowisku (nazwy podajemy bez cudzyslowia) ls(envir = zz) #lista elementow w data.frame i liscie m &lt;- data.frame(a=c(1:10), b=letters[1:10]) ls(m) l &lt;- list(a=1, b=2) ls(m) #wyszukiwanie elementow zgodnie ze wzorcem regular expression ls(pattern=&#39;z&#39;) #dostaniemy elementy zawierajace z nazwie litere z #uwzglednianie zmiennych ukrytych ls(all.names=TRUE) #niestety nie ma parametru &#39;mode&#39; do ograniczenia zakresu typow szukanych obiektow. ls(mode=&#39;list&#39;) #BLAD: Error in ls(mode = &quot;list&quot;) : unused argument (mode = &quot;list&quot;) #funkcje-elementy w srodku #ls() nie dziala niestety dla funkcji f &lt;- function() { x &lt;- 100 y &lt;- 200 return(x + y) } ls(f) #wywali blad get(&#39;x&#39;, f)#wywali blad #Wniosek jest taki ze te funkcje nie dzialaja dla funkcji 3.3.3.2 lsf.str Lista funkcji w danym srodowisku. #lista funkcji w oparciu o pattern lsf.str(pattern=&#39;^l\\\\.m&#39;) #lista funkcji w oparciu o pattern lsf.str(envir=my.env) 3.3.3.3 ls.str Zwraca liste obiektow wraz z ich struktura, a konkretnie stosuje f:str na kazdym obiekcie ktory zwraca. ls.str(mode = &quot;list&quot;) 3.3.3.4 rm f:rm usuwa zmienne, funkcje, srodowiska. #usuniecie elementu rm(z) #usuniecie kilku elementow rm(a,b) #usuniecie gdzie nazwy elementow podaje jako stringi rm(list=c(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;)) #usuniecie wszystkich elementow w danym srodowisku (domyslnie w globalnym) rm(list=ls()) rm(list=ls(envir = &#39;my.env&#39;)) #usuniecie wszystkich zmiennych z pominienciem funkcji rm(list = setdiff(ls(), lsf.str())) #usuniecie elementow wg. &#39;pattern&#39; rm(list=ls(pattern=&#39;zzz&#39;)) #inherits rm(a, envir=&#39;my.env&#39;, inherits = FALSE) # czy usuwac zmienne ze srodowiska nadrzednego 3.3.4 exists, existsFunction i get #czy istnieje dany obiekt (funkcja, zmienna, srodowisko) exists(x = &#39;z&#39;, #nazwe zmiennej podajemy jako strin &lt;small class=&#39;s1&#39;&gt;UWaga&lt;/small&gt; envir = &#39;my.env&#39; , mode = &#39;any&#39;, inherits = ) #czy szukac w srodowisku otaczjacym exists(&#39;apply&#39;) exists(&#39;foreach&#39;) #false jezeli pakiet &#39;zawierajacy funkcje nie jest zaladowany #czy istnieje funkcja &#39;mean existsFunction(f = &#39;mean&#39;) #pobieranie obiektow ze srodowisk get(x=&#39;z&#39;, envir=&#39;my.env&#39;, mode=&#39;list&#39; inherits=TRUE) 3.4 Macros Wszystko co dzieje sie w makrze jest widoczne poza nim. Makra tak jak funkcje moja argumenty require(gtools) #makro musi miec jakis argument. Jesli chcemy sie nim nieprzejmowac stosujemy ponizsza konstrukcje z &lt;- defmacro(x, expr={ u &lt;- 100 }) z(0) #uwaga: zero nie bedzie przypisane globalnie do x (nazwa argumentu makra!!!) # w makrach mozna tworzyc nowe funkcje plot.sf &lt;- defmacro(type=&#39;b&#39;, col=&#39;black&#39;, title=deparse(substitute(x)), DOTS, expr= function(x, y) plot( x,y, type=type, col=col, main=title, ...) ) "],
["data-structures.html", "Chapter 4 DATA STRUCTURES 4.1 Objects attributes 4.2 Podzial struktur 4.3 Atomic lists [Listy atomowe] 4.4 matrix 4.5 Generic list [Listy generyczne] 4.6 Different data structures convetring and merging", " Chapter 4 DATA STRUCTURES 4.1 Objects attributes Atrybuty sa przechowywane w postaci pairlist Liste atrybutow obiekty pobieramy przez f:attributes Konkretny atrybut pobieramy f:attr (np. attr(x, 'names')) Nowe atrybuty przypisujemy przez f:attr (np. attr(x, 'atrybut') &lt;- wartosc). W przypadku niektorych atrubutow (class, names,…) mozna odwolywac sie przez funkcje podstawieniowe. dim, length, ncol, nrow are not an attributes. They are function of type primitive 4.2 Podzial struktur Na razie pominiemy tzw. typy danych tzn. daty, liczny, ciagi tekstowe, bo to rozbudowane tematy i zajmiemy się tym w jakie struktury mozna takie typu zebrac. Dane w jezyku R sa przechodywane w listach ktore dzieli sie na 2 podstawowe typy atomowe - kazdy element listy jest tego samego typu (czyli wszystko jest np. liczba) i elementow nie mozna w sobie zagniezdzac (przykladem jest np. vektor, matrix, array). Lista atomowa nie moze przechowywac obiektu NULL. generyczne - kazdy element moze byc innego typu i elementy mozna zagniezdzac (przykladem sa listy, data.frames [ramki danych]). Lista generyczna moze przechowywac obiekt NULL. nasz_wektor &lt;- c(1,2,3) is.atomic(nasz_wektor) # czy obiekt jest atmowy isGeneric(&#39;nasz_wektor&#39;) # czy obiekt jest generyczny 4.3 Atomic lists [Listy atomowe] W przypadku list atomowych beda nas interesowaly: vector - wektor matrix - macierz dwuwymiarowa array - macierz o dowolnej liczbie wymiarow Uwaga: W R nie ma czegos takiego jak skalar, czyli obiektu zawierajacego na sztywno tylko jeden element !!!. Mozna sobie co najwyzej zrobic wektor z jednym elementem albo macierz o wymiarze 1x1. 4.3.1 wektory Dla wektorow w wiekszosci sytuacji chyba nie ma sensu wyrozniac czy jest wierszowy czy kolumnowy. Po uzyciu na nim funkcji transponujacej dostaniemy matrix z jednym wierszem: wektor &lt;- c(1,2,3) transponowany_wektor &lt;- t(wektor) class(transponowany_wektor) # sprawdzam klase obiektu i dostaje &quot;matrix&quot; Taka transpozycja moze kilka razy mi sie kiedys przydala. Tworzenie wektora #obie ponizsze linijki kodu sa rownowazne wektor &lt;- c(1,2,3,4,5,6,7,8,9) wektor &lt;- 1:9 #mozna tez to mieszac te konstrukcje wektor1 &lt;- c(1:3, 10:20, 5, 12, 100:200) # sklejanie wektorow wektor_1 &lt;- 1:3 wektor_2 &lt;- 4:6 # skleilem ponizej 4 wektory wektor_razem &lt;- c( wektor_1 , wektor_2 , 1:30 , c(1,2,3)) wektor_pusty_liczbowy &lt;- numeric(0) # ten wektor ma zero elementow ale wiemy ze jest typu liczbowego (typy wektorow bede w jednej z kolejnych czesci) Wybieranie podzbioru elementow wektora po indeksach # wybieranie po indeksach (pozycjach) elementow wektor[1] #wyciagnij pierwszy element wektor[c(2,3)] #wyciagnij drugi i trzeci element wektor[2:3] #wyciagnij drugi i trzeci element wektor[-1] # wszyskie elementy z wyjatkiem pierwszego wektor[c(-1,-3)] # wszyskie elementy z wyjatkiem pierwszego i trzeciego wektor[-1:-3] # wszyskie elementy z wyjatkiem pierwszego drugiego i trzeciego # mozeby tez wyciagajac elementy zmieniac sobie kolejnosc wektor[c(3,2,1)] order(wektor) # to naz zwroci ktory pod wzgledem wartosci jest dany element wektor[order(wektor)] # dzieki takiemu podstawieniu dostaniemy posortowany wektor. Ale do srotowania generalnie lepsza jest f:sort ktora bedzie potem pokazana. Wybieranie podzbioru elementow wektora po warunkach logicznych wektor[c(TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE)] # wycianij pierwszy i drugi element - zwrocmy uwage ze ilosc wartosci logicznych jest rowna ilosci elementow wektora, czyli warunek definiujemy oddzielnie dla kazdego elementu #ponizsze dzialanie zwraca nam wektor wartosci logicznych o dlugosci naszego wektora pokazujace ktore elementy sa wieksze niz 3 wektor &gt; 3 #nic nie stoi na przeszkodzie zeby powyzsze dzialanie podstawic w nawiasach kwadratowych naszego wektora: wektor[wektor &gt; 3] # wyciagnij elementy wieksze niz 3 # bardziej skpmplikowany warunek wektor[wektor &gt; 3 &amp; wektor &lt; 8] Wybieranie podzbioru elementow wektora po nazwach. wektor &lt;- c(a=10, b=20, c=30) # kazdy element naszego wektora bedzie teraz mial nazwy literowe names(wektor) # zwroci wektor z nazwami elementow wystapujacymi w naszym wektorze wektor[&#39;a&#39;] # element o nazwie &#39;a&#39; wektor[c(&#39;a&#39;,&#39;b&#39;)] # elementy o nazwach &#39;a&#39; i &#39;b&#39; # niestety nie dziala tutaj trik ze znakiem minus jak przy odwolywaniu sie przez indeksy wektor[-&#39;a&#39;] # dostaniemy blad #zeby rozwiazac powyzszy problem z brakie mozliwosci uzycia minusa zastosujemy: indeksy_do_usuniecia &lt;- which(names(wektor) %in% c(&#39;a&#39;, &#39;b&#39;)) # f:which zwroci nam numery nazw ktore zawieraja sie w zbiore dwuelementowym &#39;a&#39; i &#39;b&#39;. wektor[-indeksy_do_usuniecia] # dostaniemy tylko element &#39;c&#39; # wektor bez komplenu nazw dla elementow: wektor_bez_kompletu_nazw &lt;- c(a=10, b=20, 30) # trzeci element nie nazwany names(wektor_bez_kompletu_nazw) # na trzeciej pozycji mamy po prostu znak pusty &quot;&quot; wektor_bez_kompletu_nazw[&quot;&quot;] # to nie zadziala. Do elementow nie nazwanych nie odwolamy sie po nazwie !!! Atrybuty wektora wektor &lt;- c(a=10, b=20, c=30) #wczesniej wspomniane nazwy elementow names(wektor) #dlugosc wektora length(wektor) # podstawowy typ wektora (w rozdziale o typach danych wyjasnie co to jest) mode(wektor) # tzw. klasa wektora (to nie to samo co podstawowy typ, chociaz tutaj mamy akurat prosty wektor numeryczny i f:mode oraz f:class zwraca nam &#39;numeric&#39; ). O tym czym jest klasa tez bedzie pozniej class(wektor) Modyfikacja wektora wektor &lt;- c(a=10, b=20, c=30, d=40) wektor[2] &lt;- 200 # drugi element zastap wartosciowa 200 wektor wektor[&#39;c&#39;] &lt;- 300 wektor wektor[1:3] &lt;- c(1,2,3) wektor wektor[1:3] &lt;- c(1000, 2000) # trzy elementy zastepujemy dwoma, ale nie jest do dobra praktyka. wektor wektor[1:3] &lt;- 100 # to zadziala i jest czesto stosowane bo kilka elementow zastepujemy JEDNYM I TYM SAMYM elementem wektor # mimo ze wektor ma tylko 4 elementy mozemy sie odwolac w indeksie do liczby 5 i tym samym dokleic kolejny element wektor[5] &lt;- 10000 wektor # to co jest nizej tez zadziala. Wektor ma juz 5 elementow a teraz bedzie mial 10. Dziury od elementu 6 do 9 zostana wypelnione brakami danych czyli wartoscia NA wektor[10] &lt;- 10000 wektor wektor &lt;- wektor[1:3] # skrocenie wektora do pierwszych 3 elementow # ponizsze 2 linijki sa roznowazne wektor &lt;- replace(wektor, list = c(1,2), values = c(10,20)) wektor[c(1,2)] &lt;- c(10,20) Rozne przydatne funkcje do pracy z wektorami wektor &lt;- 1:10 # odwrocenie kolejnosci elementow rev(wektor) # sortowanie rosnaco sort(wektor) # sortowanie malejaco sort(wektor, decreasing = TRUE) # sortowanie malejaco tak zeby braki danych NA byly po sortowaniu na koncu wektora sort(wektor, decreasing = TRUE, na.last = TRUE) which(wektor == 2) # pozycja elementow rownych 2 which(wektor &gt; 2 &amp; wektor &lt; 7) which.max(wektor) # pozycja najwiekszego elementu which.min(wektor) # pozycja najmniejszego elementu is.na(wektor) # czy elementy sa brakami danych typu NA is.nan(wektor) # czy elementy sa brakami danych typu NaN wektor %in% c(1,10) # czy kazdy z kolejnych elementow zawiera sie w zbiorze liczb 1 i 2 ! wektor %in% c(1,10) # zaprzeczenie tego co jest wyzej wektor_1 &lt;- 1:10 wektor_2 &lt;- 1:10 wektor_1 == wektor_2 # czy kazdy element z osobna jest taki sam wektor_1 != wektor_2 # czy kazdy element z osobna jest taki rozny wektor_1 &gt; wektor_2 # czy kazdy element z osobna jest wiekszy w wektorze_1 w stosunku do wektora_2 all.equal(wektor_1, wektor_2) # czy wszyskie elementy sa takie same (dostaniemy jedna wartosc logiczna) unique(wektor) # usuniecie duplikatow duplicated(wektor) # czy poszczegolne wartosci sa duplikatami order(wektor) # ktory z kolei pod wzgledem wartosci jest dany element 4.4 matrix Tworzenie macierzy macierz &lt;- matrix( data = 1:4 #beda 4 elementy , nrow = 2 # beda w wiersz , byrow = TRUE) # elementy beda wprowadzone w kolejnosci po wierszach macierz # tak jak przy wektorach mozna wprowadzic nazwy elementow # (1) mozna nazwac oddzielnie kazda komorke macierz co chyba nigdy nie jest praktykowane i nie bedziemy sie tym zajmowac # (2) mozna nazwac kolumny i wiersze - to sie najbardziej przydaje # (3) mozna nazwa wymiary macierz_z_nazwami &lt;- matrix( data = 1:4 , nrow = 2 , dimnames = list( a=c(&#39;A&#39;,&#39;B&#39;) #wymiar wierszy o nazwie &#39;a&#39; bedzie zawieral wiesze &#39;A&#39; i &#39;B&#39; , b=c(&#39;D&#39;,&#39;E&#39;))) #wymiar kolumn o nazwie &#39;b&#39; bedzie zawieral kolumny &#39;D&#39; i &#39;E&#39; # macierz_z_nazwami **Atrybuty macierzy* names(macierz_z_nazwami) # dostaniemy NULL bo nie nazwalismy osobno kazdej komorki (Przy okazji zauwaz ze to pierwszy raz kiedy dostalismy obiekt NULL - wlasnie czesto jezli jakas funkcja nie ma czego zwrocic bo to nie isnieje, to zwraca NULL ktorego nie nalezy mylic z NULL-em w SQL-u) colnames(macierz_z_nazwami) # nazwy kolumn rownames(macierz_z_nazwami) # nazwy wierszy dimnames(macierz_z_nazwami) # nazwy wymiarow length(macierz) # ilosc komorek macierzy dim(macierz) # wymiary - dostaniemy dwu elementowy wektor z iloscia i kolumn i wierszy ncol(macierz) # ilosc kolumn nrow(macierz) # ilosc wierszy Odwolywanie sie do elemenow Tutaj wszystko dziala analogicznie do wektorow wiec nie ma sie nad czym rozwodzic. Komplikacja jest to ze mamy 2 wymiary. Podam kilka prosty przykladow juz bez rozwleklego komentowania macierz1 &lt;- matrix( data = 1:9 , nrow = 3) #nazwy kolumn i wierszy mozna tez przypisac tak colnames(macierz1) &lt;- c(&#39;A&#39;,&#39;B&#39;,&#39;C&#39;) rownames(macierz1) &lt;- c(&#39;D&#39;,&#39;E&#39;,&#39;F&#39;) macierz1[ ,2] # druga kolumna macierz1[2, ] # druga wiersz macierz1[1,2] # element z pierwszego wiesza i drugiej kolumny macierz1[1, 1:2] macierz1[1:2, 1:2] macierz1[-1,] macierz1[-1:-2,] macierz1[,&#39;A&#39;] macierz1[,c(&#39;A&#39;,&#39;B&#39;)] # Wazna uwaga do powyzszego jest to ze jezeli zwracany obiekt jest jednowymiarowy dostajemy wektor a nie jednowymiarowa macierz is.matrix(macierz1[ ,2]) # zwroci FALSE Funckje do pracy z macierzami Generalnie wiekszosc funkcji do pracy z wektorami moze tez pobrac macierze: macierz &lt;- matrix(1:4, 2) sum(macierz) #suma wszysktich elementow max(1:4) # maksimum z wszystkich elemenotow W powyzszych sytuacjach macierz jest potraktowana po prostu jak wektor i funkcja nie widzi wymiarowosci macierzy. Problem jest jezeli nie chcemy traktowac macierzy jak wektora ale zrobic obliczenia wzgledem kolumn albo wierszy (czyli pracowac na jej wymiarach) Zalozmy ze chcemy zrobic wartosc maksymalna z kazdej kolumny. Mozna to zrobic petla for: macierz &lt;- matrix(1:4, 2) wynik &lt;- numeric(0) #definiuje pusty wektor liczbowy gdzie bededokladal wyniki moich obliczen for(i in 1:ncol(macierz)){ # wartosc licznika &#39;i&#39; bedzie od 1 do ncol(macierz) czyli ilosci kolumn macierzy max_i_tej_kolumny &lt;- max(macierz[,i]) #max z i-tej kolumny wynik &lt;- c(wynik, max_i_tej_kolumny) # do mojej zmiennej doklejam sobie wartosc max z kolejnej kolumny } wynik Jest to jednak malo wygodne i w praktyce jesli chcemy ta sama operacje wykonac na wielu roznych elementach (czyli np. na kolejnych kolumnach marcierzy) to stosujemy funkcje mapujace. Funkcje te niesamowite zastosowania w pracy ze zlowonymi strukturami danych. Przy macierzach nie bedzie dzialo sie nic spektakulanego. Dla macierzy istnieje taka dedykowana mapujaca funkcja i nazywa sie apply: # wartosc maksymalna z kolumn (dostaniemy dokladnie to samo co wczesniej z petli for) apply(macierz , MARGIN = 1 , FUN = max) # wartosc maksymalna z wierszy apply( macierz , MARGIN = 2 , FUN = max) Skejanie (bindowanie [binding]) Bindowanie po wierszach [rows] #czy mozna bindowac macierz ktore maja inne nazwy kolumn? z1 &lt;- matrix(c(1:4),c(2:2)) colnames(z1) &lt;- c(&#39;a&#39;,&#39;b&#39;) z2 &lt;- matrix(c(5:8),c(2:2)) colnames(z2) &lt;- c(&#39;c&#39;,&#39;d&#39;) z &lt;- rbind(z1,z2) #wniosek jest taki ze mozna. Nazwy sa przejmowane od pierwszej macierzy #tworzenie macierzy przez bindowanie kiedy macierz startowa jest pusta i nieokreslona (bidnowanie od zera) m1 &lt;- numeric() m1 &lt;- rbind(m1, matrix(c(1:10), 2) ) m1 &lt;- rbind(m1, matrix(c(10:1), 2) ) m1 #dostaniemy macierz o wymiarach 2X10 # bindowanie po kolumnach cbind(m1, m1) Inne operacje macierzowe #posortowanie po pierwszej kolumnie macierz[order(macierz[, 1]), ] #przypomnij sobie co robi f:order i wyjasnij jak tutaj dziala # transponowanie t(macierz) 4.4.1 Array (macierz wielowymiarowa) Ja tego typu struktury danych bardzo rzadko uzywam w praktyce, wiec potraktuj to jako ciekawostke ktorej nie bede szczegolowo opisywal. W podstawowych kwestiach tutaj nie ma sie nad czym rozwodzic bo wszystko jest tak jak w matrix tylko mamy wiecej wymiarow. W przypadku takich obiektow bardziej skomplikowane jest np. sklejanie (bindowanie) takich kilku wielowymiarowych kostek w jedna. Gdyby Cie to interesowalo to jest p:abind ktory sluzy do pracy z macierzmi wialowymiarowymi, ktory tutaj bedzi uzyty wlasnie do bindowania. # tworze macierz twojwymiarowa macierz_w &lt;- array( data = 1:27 , dim = c(3, 3, 3) # zrobimy 3 wymiarowa kostke z 3 wierszami w kazdym wymiarze , dimnames = NULL) # nazwy sobie podarujemy dim(macierz_w) #wymiary macierzy # uwaga: do wielowymiarowej transpozycji sluzy f:aperm a NIE f:t jak przy macierzach dwuwymiarowych aperm(macierz_w, perm = c(2,1,3)) # tutaj zrobilismy transpozycje wymiaru drugiego z pierwszym Sklejanie (bindowanie) macierzy wielowymiarowych require(abind) w1 &lt;- array(NA, c(5,2)) #macierz dwuwymiarowa o wymiarach 5x2 m1 &lt;- matrix(1:10, c(5,2)) # nastepna macierz dwuwymiarowa 5x2 w2 &lt;- abind::abind( w1 , m1 , along = 3) #bindujemy po trzecim wymiarze - wiec dostane trojwymiarowa kostke sklejona z dwoch dwuwymiarowych macierzy dim(w2) # moj nowy obiekt ma wymiar 5x2x2 4.5 Generic list [Listy generyczne] Tutaj zajmiemy się dwoma najbardziej podstawowymi: list [lista] - najbardizej ogolny typ listy. Wszyskie inne sa jej szczegolnymi przypadkami i modyfikacjami data.frame [ramka danych] - cos co jest mniej wiecej odpowiednikiem tabeli w SQL, czyli prostokatna tabela z danymi gdzie kazda ma tyle samo elementow ale moze byc innego typu 4.5.1 List Przedstawiamy najpowszechniej spotykana i najbardziej ogolna postac listy generic, czyli list. Uwagi ogolne Lista jest typu recursive (mozna ja zagniezdzac). W R mozna ustawić limit rekursji przez f:options (options(expressions=10000)). Dosylnie mozna dokonac rekursji 5000 razy. Elementami listy moga byc funkcje i srodowiska. w &lt;- list(z=mean); w$z(1:50, na.rm=TRUE) Nazwy elementow listy NIE musza byc unikatowe. Atrybut names moze byc NULL-em. Jest to najbardziej ogolny typ list wiec wiekszosc atrybutów i cech powinna sie odnosci tez do innych list (np. data.frame) Elementem listy moze byc obiekt NULL (w przeciwienstwie do listy atomowej) Pusta lista (list()), nie jest obiektem typy NULL. Ma dlugosc rowna 0 Do list mozna dodawac elementy o indeksie przekraczajacym aktualny rozmiar listy. Przerwy sa wypalniane przez NULL (lista ma dlugosc 6 a my przypisujemy elemento do 8 to w 7 bedzie automatycznie przypisany NULL) Do listy mozna dodawac elementy o nazwie ktorej nie ma w liscie is.vector(list(1,2,3)) - zroci TRUE. Nalezy pamietac ze kazdy typ danych to w ogolnosci lista. Glowne atrybuty: length-ilosc elementow names - nazwy elementow # utworzenie listy moja_lista &lt;- list( a = 1:10 # wektor liczbowy ,b = &#39;ala&#39; # wektor teksotwy ,c = list(a=10, z=200) # w liscie moge zagniezdzic nastepna liste bo to typ generyczny ,d = NULL # w liscie moge umiescic NULL bo to typ generyczny ) # 5 sposobow wyciagniecia pierwszego elementu listy moja_lista[1] # wyciagam pierwsza element listy class(moja_lista[1]) # ale jest to dalej lista tylko ze jedno elementowa - nie dobralem sie bezposrednio do wektora liczbowego !!! # teraz dobiore sie do pierwszego elementu bezposrednio moja_lista[[1]] class(moja_lista[[1]]) # mam wektor liczbowy - dobralem sie bezposrednio do niego!!! # analogicznie dziala to dla pobieraniu elementow po nazwach moja_lista[&#39;a&#39;] moja_lista[[&#39;a&#39;]] moja_lista$a # tu znowu dobieram sie bezposrednio po nazwie !!! class(moja_lista$a) Teraz wazne pytanie: skoro elementy w liscie mozna zagniezdzac to czy jak odwolac sie do zagniezdzonych elementow. Nie stanowi to problemu bo odwolania mozna ukladac z lancuchy: # drugi element w wektorze liczbowym moja_lista[[&#39;a&#39;]][2] #lub moja_lista[[1]][2] #lub moja_lista$a[1] # drugi element w zagniezdzonej liscie moja_lista[[&#39;c&#39;]][[&#39;z&#39;]] #lub moja_lista[[1]][[&#39;z&#39;]] #lub moja_lista$c$z Jezeli w wystapiloby wielokrotne zagniezdzenie to teki lancuszek mozna dalej ciagnac. ** f:list a f:as.list** require(ggplot2) d &lt;- head(diamonds) list(d) # jednolementontowa lista as.list(d) # lista wektorow Modyfikacja listy moja_lista &lt;- list( a = 1:10 # wektor liczbowy ,b = &#39;ala&#39; # wektor teksotwy ,c = list(a=10, z=200) # w liscie moge zagniezdzic nastepna liste bo to typ generyczny ,d = NULL # w liscie moge umiescic NULL bo to typ generyczny ) # podmieniam pierwsze 2 elementy listy nowymi wartosciami. Warto zwrocic uwage na to ze nazwy pierwszych dwoch elementow sie nie zmiania mimo ze lista nowych elementow ma inne nazwy (&#39;ab&#39; i &#39;wz&#39;) moja_lista[1:2] &lt;- list(ab = 1000, wz = 200) moja_lista # dodaj nowa zagniezdzona liste na koncu naszej listy moja_lista &lt;- append( moja_lista , values = list(nowa_lista = list(a=200))) # dodaj wektor liczbowy po 3 elemencie listy moja_lista &lt;- append( moja_lista , values = list(nowy_wektor=1:5) , after = 3) #usuniecie drugiego elementu z listy moja_lista[2] &lt;- NULL # usun NULL-e z listy moja_lista &lt;- purrr::compact(moja_lista) # ZOSTAW w liscie tylko te elementy ktore spelniaja okresony warunek purrr::keep( moja_lista , .p = function(x) length(x) &gt; 1 ) # element listy musi miec dlugosc co najmniej 2. &#39;x&#39; symbolizuje tu element listy #teraz odwrotnie: USUN w listy tylko te elementy ktore spelniaja okresony warunek purrr::discard( moja_lista , .p = function(x) length(x) &gt; 1 ) # usuwam elementy ktore maja dlugosc co najmniej 2 Atrybuty listy # ilosc elementow glownych (nie zlicza zagniezdzonych itp) length(moja_lista) # nazwy elementow glownych names(moje_lista) # glebokosc listy (jak glebokie jest zagniezdzenie) purrr::vec_depth(moja_lista) Laczenie list (merge) lista_1 &lt;- list(a=10 , b=20 , c=30 ) lista_2 &lt;- list( b=200, d=300 ) lista_3 &lt;- list( b=2000, w=3000) rlist::list.merge( lista_1 , lista_2 # tu nadpiszemy &#39;b&#39; i dodamy &#39;d&#39; , lista_3) # tutaj znowu nadpiszemy &#39;b&#39; i dodamy &#39;w&#39; funkcje mapujaca dla list lapply lista &lt;- list(a=2, b=4) lapply(lista, function(x) x^2) # podnies do kwadratu kazdy element listy # to samo purrr::map(lista, .f = function(x) x^2) # podnies do kwadratu tylko wybrane elementy lista2 &lt;- list(a=2, b=3, c=4) purrr::map_at( .x = lista2 , .at = c(&#39;a&#39;, &#39;b&#39;) # podnosze elementy o nazwach &#39;a&#39; i &#39;b&#39; , .f = function(x) x^2 ) # podnies do kwadratu tylko wybrane elementy purrr::map_at( .x = lista2 , .at = c(1, 3) # podnosze element pierszy i trzeci , .f = function(x) x^2 ) # podnies do kwadratu tylko wybrane elementy purrr::map_if( .x = lista2 , .p = function(x) x &gt;2 # podnosze elementy wieksze niz 2 , .f = function(x) x^2 ) 4.5.1.1 List recursion ################ list - podstawowe konstrukcje # PROSTE DRZEWO - latwo stworzyc ulepszona wersje rapply lista &lt;- list(a=list(b=20, c=list(d=100, e=200)), b=list(i=40, w=90), p=100) lista f &lt;- function(l){ if(is.numeric(l)){ l^2 }else{ lapply(l, f) } } wynik_1 &lt;- f(lista) # w wyniku dostajemy liste ale liczby sa tylko na lisciach print(wynik_1) listviewer::jsonedit(wynik_1) unlist(wynik_1) # dodajemy liscie przeksztalcone w wektor # AGREGOWANIE WSPINAJACE - z uzyciem p:data.tree lista &lt;- list(&#39;a&#39;=list(&#39;z&#39;=9), &#39;b&#39;=list(&#39;c&#39;=list(&#39;z&#39;=20), &#39;d&#39;=list(&#39;z&#39;=30, &#39;w&#39;=40))) # uwaga na taki zestaw danych: # lista &lt;- list(&#39;z&#39;=9, &#39;b&#39;=list(&#39;c&#39;=list(&#39;z&#39;=20), &#39;d&#39;=list(&#39;z&#39;=30, &#39;w&#39;=40))) - pierwszy element nie jest lista require(data.tree) nod &lt;- FromListSimple(lista, nodeName = &#39;lista&#39;) print(nod, &#39;z&#39;,&#39;w&#39;) # uwaga moze byc problem z kolejnoscia zaladowania pakietow Aggregate(node = nod, attribute = &#39;z&#39;, aggFun = sum) # sumujemy tylko po &#39;z&#39; a nie po &#39;w&#39; !!! nod$Get(Aggregate, &quot;z&quot;, sum) # sumujemy w sposob wsponajacy po zmiennaj &#39;z&#39; # CIAGNIECIE DANYCH W DOL f_mean &lt;- function(l, n=&#39;&#39;){ nazwy &lt;- names(l) n_nazwy &lt;- paste(n, nazwy, sep=&#39;_&#39;) # zestaw nazw - tyle elementow ile elemetow listy (nie ma w paste parametru collapse wiec nie dostajemy jednego elementu) mapply(function(x,y){ # poczatek mapply if(is.list(l)){ f_mean(x,y) }else{ y } }, l, n_nazwy) # nazwy ktore przekazuje w dol - inna dla kazdego elementu listy # koniec mapply } wynik_3 &lt;- f_mean(lista, &#39;&#39;) # dostajemy liste ktora ma wartosci tylko na lisciach listviewer::jsonedit(wynik_3) unlist(wynik_3) # AGREGACJA SEGMENTAMI - bez stosowania p:data.tree f_mean_c &lt;- function(l,n=NULL){ srednia &lt;- mean(unlist(l)) # licze srednia z wszystkich lisci poprzed przeksztalcenie w wezle wszystkiego na wektor n_srednia &lt;- c(n, srednia) lapply(l, function(x,y){ if(is.list(x)){ f_mean_c(x,y) }else{ y } } ,n_srednia ) } f_mean_c(lista, NULL) ### AGREGACJA SEGMENTAMI - ulepszona wersja z bardziej czytelnymi wynikami bez storowania p:data.tree lista &lt;- list(&#39;a&#39;=list(&#39;z&#39;=9), &#39;b&#39;=list(&#39;c&#39;=list(&#39;z&#39;=20), &#39;d&#39;=list(&#39;z&#39;=30, &#39;w&#39;=40))) f_mean_c1 &lt;- function(l,n=NULL){ lapply(l, function(x,y){ if(is.list(x)){ srednia &lt;- mean(unlist(x)) # bedziemy liczyc srednia return(list(srednia,f_mean_c1(x,y))) }else{ &#39;&#39; # z liscmi na samym dole nic nie robimy } } ,n ) } wyn_1 &lt;- f_mean_c1(lista) wyn_2 &lt;- unlist(wyn_1) wyn_3 &lt;- wyn_2[wyn_2!=&#39;&#39;] require(data.tree) nod_1 &lt;- FromListSimple(wyn_1, nameName = &#39;lista&#39;) 4.5.1.2 Other issues # listy mozna powielac funkcja &#39;rep&#39; lista &lt;- list(a=1, b=2) rep(lista, 3) 4.5.2 pairlist Section 2.1.11 from R documentation states this: Pairlists are handled in the R language in exactly the same way as generic vectors (“lists”). In particular, elements are accessed using the same [[]] syntax. The use of pairlists is deprecated since generic vectors are usually more efficient to use. When an internal pairlist is accessed from R it is generally (including when subsetted) converted to a generic vector. 4.5.3 data.frames Jest to typ z ktorego korzysta sie najczesciej Tworzenie 4.5.3.1 Atrybuty i odwolywanie sie do elementow Odwolywanie do pustej tabeli - powoduje blad f &lt;- data.frame() j &lt;- 1 maks &lt;- max(f[,j], na.rm=T) # zakladamy ze &#39;f&#39; jest pusta Jaki ma numer kolumna o okreslonej nazwie? which(names(dane_sql)==&#39;kwota&#39;) 4.5.3.2 Columns removing require(ggplot2) d &lt;- data(diamonds) d &lt;- diamonds #usuwanie kolumn# d &lt;- diamonds d &lt;- d[1:20 , -c(&#39;cut&#39;, &#39;clarity&#39;, &#39;price&#39;, &#39;carat&#39;) ] #nie dziala!!! d &lt;- diamonds d &lt;- d[1:20 , c(-1,-2,-3) ] #dziala d &lt;- diamonds d &lt;- d[1:20 , -c(1,2,3) ] #dziala 4.5.3.3 Columns adding #zakladaem ze nie ma kolumny o nazwie &#39;z&#39; ramka$z &lt;- wektor ramka[,&#39;z&#39;] &lt;- wektor #dodanie kolumny po okreslonej kolumnie append(x = ramka, values = wektor , after = numer_kolumny_po_ktorej_dokladamy ) 4.5.3.4 Rows adding use functions from p:dplyr 4.5.3.5 Sorting require(ggplot2) z&lt;-diamonds names(z) dim(z) #pierwszy sposob z1&lt;-z[ with(z, order(depth, -price)) ,] #uprzadkowanie po zmiennej &#39;depth&#39; rosnaca, a nastepnie malejaco po &#39;price&#39; #drugi sposob library(taRifx) sort(z, f= ~ depth + -price) #trzeci sposob library(plyr) arrange(z, depth, desc(price)) 4.5.3.6 Duplicates #MACIERZ i RAMKI DANYCH require(ggplot2) z&lt;-diamonds #zwroci wiersze ktore sie zduplikowaly ze wzgledu na zmienne depth i price z2&lt;-z[duplicated(z[,c(&#39;depth&#39;, &#39;price&#39;)]),] #usuniecie duplikatow ze wzgledu na zmienne depth i price z2&lt;-z[!duplicated(paste(z[&#39;depth&#39;], z[&#39;price&#39;])),] #Usuwanie calych zduplikowanych wierszy z[ !duplicated(z) , ] #lub unique(z) #Zliczanie zduplikowanych wierszy sum(duplicated(z) ) 4.5.3.7 Missing data #DANE: m &lt;- data.frame( a = c(1,4,3,1,2,7) , b = c(NA,4,NA,1,4,6) , c = c(NA,1,4,NA,NA,6) , d = c(NA,2,4,5,6,NA)) #usuwanie wierszy ze wzgledu na braki danych w ktorychkolwiek kolumnach (sprawdzic czy jest dobrze) m1 &lt;- m[ ifelse(apply( !is.na(m), 1, FUN=prod ), TRUE, FALSE) , ] #usuniecie wierszy po ze wzgledu na braki danych w kolumnach 2 i 3 m1 &lt;- m[!is.na(m[,2]) &amp; !is.na(m[,3]),] #zliczenie wszystkich komorek z brakami danych w ramce danych sum(is.na(m)) #zliczenie brakow danych po zmiennych apply(is.na(m),2, FUN=sum) #stosujemy apply poniewaz funkcja is.na zwroci nam tu typ matrix!!! #zliczanie brakow danych po wierszach apply(is.na(m),1, FUN=sum) #INNE PROBLEMY z &lt;- data.frame(a=c(1,2,2,3, NA, NA, 5 )) z1 &lt;- z[ z[,1]==2 ,] z1 #dostaniemy elementy rowne 2 ale rowniez braki danych NA!!! #Trzeba zastosowac z1 &lt;- z[ !is.na(z[,1]==2 ) &amp; (z[,1]==2 )==TRUE , ] 4.5.3.8 Binding data.frames by rows f:rbind r1 &lt;- data.frame() #pusta ramka danych. r1 &lt;- rbind(r1, c(1:10)) r1 &lt;- rbind(r1, c(10:1)) r1 &lt;- rbind(r1, list(c(1,5), letters[6:10])) #wywali blad f:rbind.fill(plyr) #Zastosowanie funkcji rbind.fill (pakiet plyr) #Funkcja binduje po wierszach ramki danych, dopasowujac dane z kolumn o odpowiadajacych sobie nazwach. Jezeli nazwy nie pasuja to powstaje kolumna z brakami danych. ez problemowo dziala laczenie kolumn typu factor. Jesli zakresy leveli sie nie zgzdzaja w nowej polaczonej ramce beda poszerzone. require(plyr) a1&lt;-data.frame(a=1:5, b=5:1) a2&lt;-data.frame(b=letters[1:5], c=1:5) a1 a2 rbind.fill(a1,a2) f:rbind_all(dplyr) and f:rbind_list(dplyr). It works like f:rbind.all(plyr), but are much faster. (Warning Warning: when you are joinning factor columns bevaviour is slightly differen. Namely, if levels of factor don’t fit new column will be conwerted to factor) Bindowanie ramek o innej strukturze po kolumnach - musza do siebie pasowac nazwy w pierwszej kolumnie #Bindowanie ramek po kolumnach-jedna kolumna. z1 &lt;- data.frame(a=c(1,2,3,4,5), b=letters[1:5]) z2 &lt;- data.frame(a=c(2,3,4,5,6), b=letters[6:10]) m1 &lt;- match(z2[,1],z1[,1]) d1 &lt;- m1[is.na(m1)==F] d2 &lt;- z2[is.na(m1)==F,2:ncol(z2)] z1[d1,3] &lt;- d2 #tutaj mamy z1[,3]. W petli numeracje zaczynamy od ncol(z1)+1 #Uogolnienie na wiele kolumn #Bindowanie ramek po kolumnach-jedna kolumna. Zrobic cos co jest odpowiednikiem dla find.matches dla wierszy. z1 &lt;- data.frame(a=c(1,2,3,4,5), b=letters[1:5]) z2 &lt;- data.frame(a=c(2,3,4,5,6), b=letters[6:10], c=c(10,11,12,13,14)) m1 &lt;- match(z2[,1],z1[,1]) d1 &lt;- m1[is.na(m1) == FALSE] d2 &lt;- z2[is.na(m1) == FALSE,2:ncol(z2)] f &lt;- ncol(z1) for(i in 1:ncol(d2)) { #i=2 z1[d1,c(f+i)] &lt;- as.vector(d2[,i]) } #Uwaga. Cos takiego nie zadziala: # f1&lt;-ncol(z1) # f2&lt;-ncol(d2) # z1[d1,c(f1+1:f1+f2)]&lt;-d2 See also f:rlist.bind(rlist). 4.5.3.9 Binding data.frames by columns Generally it is good to use functions like f:join or f:merge to add column if no all names fits. r2 &lt;- data.frame() #empty data.frame. r2 &lt;- cbind(r2, c(1:10)) #we will get error r2 &lt;- cbind(r2, c(10:1)) #we will get error r2 &lt;- cbind(r2, letters[10:1]) #we will get error 4.5.3.10 Subsets require(ggplot2) data(diamonds) #pierwszy sposob: p1 &lt;- d[ d[,&#39;clarity&#39;]==&#39;SI2&#39; &amp; d[,&#39;z&#39;]&gt;2.8 ,c(-3,-7)] #drugi sposob: subset(diamonds, price&gt;2000 &amp; x&gt;6 , select=cut:x ) #select wybiera zmienne (tutaj od cut do x) subset(diamonds, select=c(cut,x) ) #select wybiera zmienne (tutaj od cut do x) subset(diamonds, price&gt;1500 &amp; color==&#39;E&#39; ) subset(diamonds, price&gt;1500 | color==&#39;E&#39; ) 4.5.3.11 Other issues Funkcja do konwertowania typu kolumn convert.magic &lt;- function(obj,types){ for (i in 1:length(obj)){ FUN &lt;- switch(types[i],character = as.character, numeric = as.numeric, factor = as.factor) obj[,i] &lt;- FUN(obj[,i]) } obj } foo&lt;-data.frame(a=1:5, b=6:10,c=as.character(c(&#39;1&#39;,&#39;2&#39;,&#39;3&#39;,&#39;4&#39;,&#39;9&#39;))) sapply(foo,class) out &lt;- convert.magic(foo,c(&#39;character&#39;,&#39;character&#39;,&#39;numeric&#39;)) sapply(out, class) Utworzenie nowej pustej tabeli z odziedziczonj struktury po innej tabeli (te same nazwy kolumn i typy danych) a&lt;-data.frame(a=1:10, b=11:20, c=letters[1:10]) a sapply(a,class) b&lt;-a[0,] b sapply(b,class) 4.6 Different data structures convetring and merging 4.6.1 Converting from matrix to data.frame Nazwy przy konwertowaniu z data.frame na matrix i odwrotnie #utrata nazw przy konwertowaniu data.frame na matrix z&lt;-data.frame(a=c(1,2), b=c(1,2)) z1&lt;-as.matrix(z) names(z1) #utrata nazw #utrata nazw przy konwertowaniu matrix na data.frame m&lt;-matrix(c(1,2,3,4), c(2,2), dimnames=list(c(&#39;a&#39;,&#39;b&#39;),c(&#39;c&#39;,&#39;d&#39;))) m1&lt;-as.data.frame(m) names(m1) #nie ma utraty!!! 4.6.2 Merging data.frames and matrices #merge merge(df1,df2, all=T) #df1 i df2, to nazwy table. Zlaczenie nastepuje domyslnie po kolumnach o tych samych nazwach #all=T full outer #all.x=T left outer #all.y=T right outer #sqldf require(sqldf) sqldf(&quot;select df1.id, df2.cov as covariate from df1 join df2 on df1.id=df2.id where class=&#39;case&#39; and cov&gt;3 order by cov&quot;) 4.6.3 Converting to list #WEKTOR as.list(c(a=1,b=2,3)) #zachowuje nazwy elementow tam gdzie sa podane #MACIERZ m&lt;-matrix(1:4, 2, dimnames=list(aa=c(&#39;a&#39;,&#39;b&#39;),bb=c(&#39;w&#39;,&#39;z&#39;) )) names(m)&lt;-letters[6:9] #po elementach as.list(m) #zachowa nazwy elementow #po wierszach require(plyr) alply(m,1) #zachowa nazwy kolumn #po kolumnach alply(m,2) #zachowa nazwy wierszy #ARRAY a&lt;-array(1:27, c(3,3,3)) #po elementach as.list(a) #po wymiarach require(plyr) alply(a,1) alply(a,2) alply(a,c(1,2)) alply(a,c(1,2,3)) #DATA.FRAME require(ggplot2) #po kolumnach as.list(head(diamonds)) #zachowuje nazwy kolumn #DATA.TABLE require(data.table) d&lt;-as.data.table(head(diamonds)) #po kolumnach as.list(d) #zachowa nazwy kolumn 4.6.4 Converting from list Skomplikowane zagadnienie bo lista moga miec zlozona strukture. #TUTAJ DOSTANIEMY WEKTORY-dziale koercja l &lt;- list(a=1, b=c(10,20), c=&#39;dcdsc&#39;,d=T ) unlist(l) #dziala mechanizm koercji l &lt;- list(m=matrix(1:4,2), c=c(&#39;1&#39;,2)) unlist(l) d &lt;- data.frame(a=c(1,2), z=c(2,4)) unlist(d) l &lt;- list(z=data.frame(a=c(1,2), z=c(2,4)), w=c(1,2,3)) unlist(l) l &lt;- list(list(a=1,b=2), c=c(1,&#39;2&#39;,3)) unlist(l) l &lt;- list(c(1,2,3)) unlist(l, recursive=FALSE) l &lt;- list(c(1,2,3), c(3,4)) unlist(l, recursive=FALSE) #TU NIE DOSTANIEMY WEKTORA ALE LISTE-recursive=FALSE #jest jakas lista l &lt;- list(c(1,2,3), list(1,2,3)) unlist(l, recursive=FALSE) #jest jakas ramka l &lt;- list(data.frame(a=c(1,2),b=c(2,3)), c=c(1,2,3)) unlist(l, recursive=FALSE) "],
["data-types.html", "Chapter 5 DATA TYPES 5.1 Missing values [Braki danych] 5.2 NULL 5.3 O typach danych 5.4 logical 5.5 numeric i complex 5.6 character 5.7 date and POSIX 5.8 factor 5.9 Other things", " Chapter 5 DATA TYPES 5.1 Missing values [Braki danych] 5.1.1 about missing values W jezyku R odpowiednikiem NULL-a SQL-owego, czyli braku danych jest NA i NaN. NaN od NA rozni sie tym, ze stosuje sie go do oznaczenia sytuacji kiedy nie mamy danych bo dzialanie bylo niewykonalne np. dzielenie zera przez zero (0/0). W R istnieje też słowo NULL, ale nie jest to brak danych ale nazwa obiekt w strukturze jezyka R ktory spelnia rozne funkcje (patrz nastepny podrozdzial o nullach link). wektor &lt;- c(1, 2, NA, NA, 3) # wektor z dwoma brakami danych # ponizej dostaniemy NaN 0/0 NA - (not available) zapisane w cudzyslowie jest stringiem a nie typem NA!!!!. F:is.na sprawdza czy element jest typu NA lub NaN. NA wystepuje w roznych odmianach w zaleznosci od typu danych e.g. NA_integer_. NaN (not a number). Mozna otrzymac np. w wyniku nie wykonalnej operacji arytmetycznej (np. 0/0). f:is.nan sprawdza czy element jest typu NaN ale nie NA na.omit() pomija brak. W data.frame usuwa wszystkie wiersze w których wystepuje chociaz jeden brak danych (nie dotyczy NaN). na.fail() zwraca obiekt tylko jezli jest w nim komplet danych (nie ma NA). na.pass() nie robi nic, zwraca pelny obiekt z brakami danych. na.exlude() to samo co f:omit, ale drobna róznica przy stosowaniu funkcji w modelach ekonometrycznych exclude przy robieniu prognoz robi puste miejsca nie skracajac dlugosci prognozowanego szeregu w przeciwienstwie do f:omit. 5.1.2 Some functions for missing values NA vs NaN d &lt;- c(NA,NaN) is.na(d) is.nan(d) is.na(d) &amp; !is.nan(d) f:na.omit d &lt;- data.frame(a=1:4, b=c(&#39;a&#39;,&#39;b&#39;,NA,NaN)) d na.omit(d) f:complete.cases: Use to return only complete rows (without missing values). This function don’t concern NaN! (see results of example below). d &lt;- data.frame(a=1:4, b=c(&#39;a&#39;,&#39;b&#39;,NA,NaN)) d[complete.cases(d),] 5.2 NULL Jest to oddzielny obiekt i stanowi oddzielna klase There is only one NULL object NULL length is 0 There are objects with length 0 whitch are not nulls (e.g. list()) NULL can not be included in atomic vector. Podstawiony do zwyklego wektora powoduje jego skrocenie, tzn pomijane sa indeksy w ktorych jest NULL. W przypadku macierzy sa trudne do przewidzenia zachowania (jesli po obcienciu nie pasuja wymiary macierzy) Co to jest typ NULL? z &lt;- NULL class(z) #to oddzielna klasa i oddzielny obiekt #this gives NULL: z &lt;- {} z # functions dont&#39;t return NULL even if they doesn&#39;t include &#39;return&#39; &lt;small class=&#39;&#39;&gt;Watch out&lt;/small&gt; w &lt;- function(){ 10 } w 5.3 O typach danych W R sa nastepujace PODSTAWOWE typy danych: logical [logiczny] numeric [liczby calkowite i niecalkowite] complex [liczby zespolone] character [tekst] Typ numeric dodatkowo dzieli sie na 2 podtypy: integer (calkowitoliczbowy) i double (ulamkowy). Jest tez cos takiego jak typ Raw, ale nigdy nie widzialem zastosowania i rzadko sie o nim wspomina. Kolejnosc wymienionych typow nie jest przypadkowo - sa to typy od najmniej do najbardziej ogolnego. Ta kolejnosc definiuje tzw. reguly koersji [coersion rules], ktore okreslaja jak rozwiazac sytuacje konfliktowe miedzy typami danych. Jest to konieczne, aby zachować informacje w danych: # Ponizej jest konflikt bo do dwoch liczb dodalismy tekst. Pytanie: czy wektor wynikowy bedzie typu liczbowego czy tekstowego? wektor &lt;- c(1,2,&#39;3&#39;) # otoz zgodnie z hierarchia przchodzimy do typu bardziej ogolnego czyli dostaniemy tekst class(wektor) wektor &lt;- c(1,TRUE,FALSE) # konflikt liczby z typem logicznym class(wektor) # dostaniemy typ liczbowy a wartosc TRUE bedzie przekonwertowana na 1, a FALSE na 0. Warto sobie przypomniec ze MS SQL chcialby na sile nasza tekstowa liczbe 3 skonwertowac na liczbe i tam dostlibysmy typ liczbowy. UWAGA Przechodząc dalej zapewne zastanawiasz sie dlaczego na liscie typow nie bylo np. typu danych do przechowywania dat. W R jest kilka typow sluzacych do przechowywania dat a najbardziej popularny nazywa sie Date. Ale Date nie jest typem PODSTAWOWYM !!!. Date bazuje na typie numerycznym. Tutaj wyjdzie wspomniana przy wektorach roznice miedzy klasami i typami podstawowymi: moja_data &lt;- as.Date(&#39;2017-01-01&#39;) # klasa wektora to rzeczywiscie &#39;Date&#39; class(moja_data) # ale typ podstawowy to &#39;numeric&#39; !!! mode(moja_data) # oprocz f:mode jest jeszcze f:typeof. Od mode rozni sie tym ze w typie &#39;numeric&#39; robi jeszcze rozroznienie czy jest to &#39;integer&#39; czy &#39;double&#39; typeof(moja_data) Na bazie typow podstawowych jest powstalo oczywiscie wiecej typow pochodnych. Wiekszosc na bazie typu numeric i character. Teraz przejdziemy do szczegolowego przeanalizowania poszczegolnych typow danych. 5.4 logical 5.4.1 General notes W przypadku typu numeric jezeli przekonwertujemy na typ logical to 0 jest traktowane jako FALSE a liczby rozne od 0 jako TRUE. Jest to np. ważne przy f:if, ktora akceptuje liczby jako wartosci logiczne zgodnie ze wspomniana logika Jest cos takiego jak nieokreslona wartosc logiczna logical(0). Mozemy ja zidentyfikowac przez f:length (rowne 0), i f:is.logical (TRUE) # konwersja na typ logiczny as.logical(c( 0 , 1 , 2 , 300 , 10.86 # ulamek , -50 # liczba ujemna , 0.1 # ulamek bliski 0 , complex(1, 0, 0) # liczba zespolona z dwoma zerowymi argumentami , complex(1, 2, 4) # liczba zespolona )) 5.4.2 Logical operators l1 &lt;- c(T,T,T,T) l2 &lt;- c(F,F,T,T) #wersja wektorowa l1 &amp; l2 l1 | l2 #wersja niewektorowa-pod uwage sa brane tylko pierwsze elementy wyrazen skladowych l1 &amp;&amp; l2 l1 || l2 #Watch out: prod(c(T,F,T)) #cos takiego zwraca liczbe a nie wartosc logiczna any(c(TRUE, FALSE, TRUE)) all(c(TRUE, FALSE, TRUE)) lazy vs eager evaluation [ewaluacja leniwa vs gorliwa] # eager y &lt;- 5 x &lt;- 5 (x == 6) &amp; (y == (y &lt;- y + 10)) y # lazy y &lt;- 5 x &lt;- 5 (x == 6) &amp;&amp; (y == (y &lt;- y + 10)) y 5.5 numeric i complex 5.5.1 Types of variables Sa dwa glowne typy liczb 1. numeric ktory sie dzieli na integer , double 2. complex - jest to typ podstawowy (f:mode i f:typeod zwroca complex) Ustalanie typu liczby 1. class-zwroci numeric jestli obiekt nie jest jakos rozbudowany w ramach programowania obiektowego 2. mode-zwroci numeric lub complex 3. typeof-bardziej jest szczegolowy od mode, tzn. w przypadku liczb niezespolonych typeof poda czy to jest integer czy double. Funkcje do konwertowania typow liczbowych: as.double as.integer as.numeric (tutaj sa wszystki typy liczbowe wymienione wyzej-bez complex) as.complex 10L-liczba 10 typu integer. Domyslnie liczby sa typu double . Watch out: w starszych wersjach R-a było cos takiego jak as.real, czy as.float. pmax(wektor1, wektor2) # porownuje dla dwoch wektorow kady element z kazdym i z takich par wymieram element wiekszy pmin(wektor1, wektor2) # 5.5.2 Infitinive values [wartosci nieskonczone] Wartosc Inf wystepuje rowniez z minusem c(1, Inf, -Inf) 5.5.3 Imposible operations [dzialania niewykonalne] #Działania wykonalne Inf/1 1/Inf Inf+Inf #Działania niewykonalne Inf-Inf 0/0 Inf/Inf 5.5.4 Replacing Inf in data.frame This function (unlike f:is.na) doesn’t work with data.frames. z &lt;- data.frame(a=c(1:3,Inf,5), b=c(4,Inf,6:8)) do.call(&#39;data.frame&#39;, lapply(z,function(x) replace(x,is.infinite(x),NaN))) 5.5.5 complex [zespolone] #defining complex number z &lt;- complex(real = 1, imaginary = 2) #or z &lt;- 1 + 2i Re(z) #real part Im(z) #imaginary part Mod(z) #modul Arg(z) #wartosc argumentu z postaci trygonometrycznej Conj(z) #sprzezenie [conjugate] 5.6 character 5.6.1 Extracting 5.6.1.1 By index require(stringr) #atomowo string &lt;- &#39;ala ma kota&#39; str_sub(string, 1, 6) #atomowo od konca string &lt;- &#39;ala ma kota&#39; str_sub(string, -4, -1) #atomowo zlozony string &lt;- &#39;ala ma kota&#39; str_sub(string, start = c(1,5), end = c(2,6) ) #wektorowo string_2 &lt;- c(&#39;ala ma kota&#39;, &#39;jest piekny poranek&#39;) str_sub(string_2, 2, 4) #tak samo dla wszystkich elementow str_sub(string_2, start = c(2,3), end = c(4,5)) #roznie dla poszczegolnych elementow 5.6.1.2 By pattern str_extract_all(&#39;12a45&#39;, &#39;\\\\d&#39;) #wyciagniecie cyfr oddzielnie str_extract_all(&#39;12a45&#39;, &#39;\\\\d+&#39;) #wyciagniecie calych ciagow cyfr stri_extract_last_regex(&#39;12a45&#39;, &#39;\\\\d+&#39;) 5.6.1.3 By words sentences &lt;- c(&#39;Jane saw a cat&#39;, &#39;Jane sat down&#39;) stringr::word(sentences, 1) #pierwszy wyraz stringr::word(sentences, 2) stringr::word(sentences, -1) #pierwszy wyraz od konca stringr::word(sentences, 2, -1) stringr::str_extract_all(&#39;aa bb cc&#39;, stringr::boundary(type = &#39;word&#39;) ) stringr::str_extract_all(&#39;Aa bb cc. Dd ee ff.&#39;, stringr::boundary(type = &#39;sentence&#39;) ) stringi::stri_extract_all_words(&#39;dsca sdc sadc sadc&#39;) 5.6.2 Replacing 5.6.2.1 By index Jest problem z podstawieniami zlozlonymi #atomowo string &lt;- &#39;ala ma kota&#39; str_sub(string, 1, 6) &lt;- &#39;PpP&#39; string #atomowo od konca string &lt;- &#39;ala ma kota&#39; str_sub(string, -1,-4) &lt;- &#39;PpP&#39; #atomowo zlozony-nie zadowala mnie to rozwiazanie string &lt;- &#39;ala ma kota&#39; str_sub(string, c(1,5), c(2,6) ) &lt;- &#39;PpP&#39; string # otrzymamy dwa oddzielne wektory #wektorowo string_2 &lt;- c(&#39;ala ma kota&#39;,&#39;jest piekny poranek&#39;) str_sub(string_2, 2, 4) &lt;- &#39;PpP&#39; # tak samo dla wszystkich elementow string_2 string_2 &lt;- c(&#39;ala ma kota&#39;,&#39;jest piekny poranek&#39;) str_sub(string_2, start = c(2,3), end = c(4,5)) &lt;- &#39;PpP&#39; # roznie dla poszczegolnych elementow string_2 5.6.2.2 By pattern string &lt;- c(&#39;ala ma kota ala&#39;) str_replace(string, &#39;ala&#39;, &#39;krysia&#39;) # pierwsze napotkane str_replace_all(string, &#39;ala&#39;,&#39;krysia&#39;) # wszystkie stri_replace_last_fixed(string, &#39;ala&#39;, &#39;PpP&#39;) # ostatni # n-ty string &lt;- c(&#39;ala ma kota ala ala&#39;) p &lt;- str_locate_all(string, &#39;ala&#39;) str_sub(string, p[[1]][2,1], p[[1]][2,2] ) &lt;- &#39;PpP&#39; # drugi string string &lt;- c(&#39;ala ma kota ala ala&#39;) p &lt;- str_locate_all(string, &#39;ala&#39;) str_sub(string, p[[1]][c(2,3), 1], p[[1]][c(2,3), 2] ) &lt;- &#39;PpP&#39; # drugi i trzeci string # niestety dostaniemy dwa oddzielne wektory 5.6.3 Detecting #funkcja str_detect nie ma odmiany &#39;all&#39;, gdyz w jej wypadku nie ma ona sensu. z &lt;- c(&#39;alala cmcmc &#39;, &#39;cmcmcmc&#39;, &#39;alalala&#39;) str_detect(z, &#39;al&#39;) 5.6.4 Find position #lokalizacja pierwszego napotkanego wzorca z &lt;- c(&#39;ala ma kota &#39;, &#39;jest piekny poranek&#39;) str_locate(z, &#39;kot&#39;) #zostanie zwrocona macierz z pozycjami. W przypadku stringow gdzie nie wykryto wzorca jest im poswiecony wiesz wypelniony wartosciami &#39;NA&#39; #lokalizacja wszystkich wzorcow z &lt;- c(&#39;al bl al &#39;, &#39;al al cl cl al&#39;, &#39;cl cl cl&#39;) str_locate_all(z, &#39;al&#39;) #otrzmuje liste gdzie kazdemu stringowi jest przypisana oddzielne macierz. Tutaj w przypadku braku wykrycia elementow macierz jest pusta (nie ma jak przy wykrywaniu pierwszego napotkanego wzroca wartosci &#39;NA&#39;) 5.6.5 Counting z &lt;- &#39;clcl cl cl&#39; str_count(z, &#39;cl&#39;) 5.6.6 Joining 5.6.6.1 f:str_c str_c(letters[-26], sep=&quot; comes before &quot;, letters[-1]) 5.6.6.2 f:paste #sklej 3 stringi polaczone w jeden. Separatorem jest spacja paste(&#39;ala&#39;, &#39;ma&#39;, &#39;kota&#39;, sep=&#39; &#39;) a1 &lt;- c(&#39;a&#39;) a2 &lt;- c(&#39;b&#39;) a3 &lt;- c(&#39;c&#39;) paste(a1, a2, a3) paste(a1, a2, a3, sep=&#39;,&#39;) a1 &lt;- c(&#39;a&#39;,&#39;b&#39;) a2 &lt;- c(&#39;c&#39;) paste(a1, a2) paste(a1, a2, sep=&#39;,&#39;) paste(a1, a2, collapse=&#39;:&#39;) paste(a1, a2, collapse=&#39;:&#39;, sep=&#39;,&#39;) a1 &lt;- c(&#39;a&#39;,&#39;b&#39;) a2 &lt;- c(&#39;c&#39;,&#39;d&#39;) paste(a1, a2) paste(a1, a2, sep=&#39;,&#39;) paste(a1, a2, collapse=&#39;:&#39;) paste(a1, a2, collapse=&#39;:&#39;, sep=&#39;,&#39;) a1 &lt;- c(&#39;a&#39;,&#39;b&#39;,&#39;e&#39;) a2 &lt;- c(&#39;c&#39;,&#39;d&#39;) paste(a1, a2) paste(a1, a2, sep=&#39;,&#39;) paste(a1, a2, collapse=&#39;:&#39;) paste(a1, a2, collapse=&#39;:&#39;, sep=&#39;,&#39;) a1 &lt;- c(&#39;a&#39;,&#39;b&#39;) a2 &lt;- c(&#39;c&#39;,&#39;d&#39;,&#39;e&#39;) paste(a1, a2) paste(a1, a2, sep=&#39;,&#39;) paste(a1, a2, collapse=&#39;:&#39;) paste(a1, a2, collapse=&#39;:&#39;, sep=&#39;,&#39;) a1 &lt;- c(&#39;a&#39;,&#39;b&#39;) a2 &lt;- c(&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;) paste(a1, a2) paste(a1, a2, sep=&#39;,&#39;) paste(a1, a2, collapse=&#39;:&#39;) paste(a1, a2, collapse=&#39;:&#39;, sep=&#39;,&#39;) a1 &lt;- c(&#39;a&#39;,&#39;b&#39;) a2 &lt;- c(&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;,&#39;g&#39;,&#39;h&#39;,&#39;i&#39;,&#39;j&#39;) paste(a1, a2) paste(a1, a2, sep=&#39;,&#39;) paste(a1, a2, collapse=&#39;:&#39;) paste(a1, a2, collapse=&#39;:&#39;, sep=&#39;,&#39;) #macierze a1 &lt;- matrix(c(&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;), c(2,2)) a2 &lt;- matrix(c(&#39;g&#39;,&#39;h&#39;,&#39;i&#39;,&#39;j&#39;), c(2,2)) paste(a1,a2) paste(a1, a2, sep=&#39;,&#39;) paste(a1, a2, collapse=&#39;:&#39;) paste(a1, a2, collapse=&#39;:&#39;, sep=&#39;,&#39;) 5.6.6.3 Duplicated fruit &lt;- c(&quot;apple&quot;, &quot;pear&quot;, &quot;banana&quot;) str_dup(fruit, 2) 5.6.7 Upper Lower Case 5.6.7.1 Ignoring case stringr::str_detect(&#39;AB&#39;, fixed(&#39;a&#39;, ignore_case = TRUE )) stringr::str_detect(&#39;AB&#39;, regex(&#39;a&#39;, ignore_case = TRUE )) 5.6.7.2 Conversion tolower(&#39;SDAC&#39;) #na male toupper(&#39;asdcas&#39;) #na duze require(Hmisc) capitalize(&#39;dsac sadc&#39;) #zamiana pierwszej litery na wielka 5.6.8 Length Warning #zliczenie dlugosci bez uwzglednienia wartosci NA, oraz z uwzglednieniem spacji. str_length( c(&#39;a a a&#39;,NA) ) #zliczenie dlugosci z uwzglednieniem wartosci NA (zwracana dlugosc dla NA to 2), oraz z wuzglednieniem spacji. nchar( c(&#39;a a a&#39;,NA) ) 5.6.9 Splitting str_split(&#39;lala&#39;, &#39;l&#39;) #rozdzielenie stringu-kazdy element osobno z &lt;- &#39;alala ala lal&#39; str_split(z, &#39;&#39;, nchar(z)+1) 5.6.9.1 Splitting into columns #funkcja colpslit require(reshape) x &lt;- c(&quot;a_1&quot;, &quot;a_2&quot;, &quot;b_2&quot;, &quot;c_3&quot;) vars &lt;- colsplit(x, &quot;_&quot;, c(&quot;trt&quot;, &quot;time&quot;)) vars str(vars) df &lt;- data.frame(a=c(&#39;a_b&#39;, &#39;c_d&#39;, &#39;e_r&#39;), stringsAsFactors = FALSE) tidyr::separate(df, col = a, into = c(&#39;A&#39;, &#39;B&#39;), sep = &#39;_&#39;) 5.6.10 Trimming padding #usuwa spacje z krancow ciagu (both, lefh, right) str_trim(&#39; cdd &#39;, side=&#39;both&#39;) #doda 30 spacji z lewej strony str_pad(&#39;hadley&#39;, 30, &#39;left&#39;) 5.6.11 Other 5.6.11.1 ’f:gsubfn require(gsubfn) # PRACA Z LISTA - przyklad usuwania polskich znakow # uwaga ponizsza operacje mozna wykonac przy pomocy funkcji chartr(base) z1 &lt;- c(&#39;ą&#39;,&#39;ć&#39;,&#39;ę&#39;,&#39;ł&#39;,&#39;ń&#39;,&#39;ó&#39;,&#39;ż&#39;,&#39;ź&#39;) z2 &lt;- list(&#39;a&#39;,&#39;c&#39;,&#39;e&#39;,&#39;l&#39;,&#39;n&#39;,&#39;o&#39;,&#39;z&#39;,&#39;z&#39;) names(z2) &lt;- z1 s &lt;- &#39;[ąćęłńóżź]&#39; gsubfn(s, z2 , &#39;sdę ć csd ódsc&#39;) # PRACA Z FUNKCJAMI gsubfn(&quot;[[:digit:]]+&quot;, function(x) as.numeric(x)+1, &quot;(10 20)(100 30)&quot;) # PRACA Z FORMULAMI-dziala troche jak uproszczenie skladni dla funkcji gsubfn(&quot;[[:digit:]]+&quot;, ~ as.numeric(x)+1, &quot;(10 20)(100 30)&quot;) gsubfn(&quot;[[:digit:]]+&quot;, ~ paste(rep(&quot;X&quot;, n), collapse = &quot;-&quot;), &quot;5.2&quot;) #n - jest pobierane z elementow zdefiniowanych w pierwszy argumencie &#39;gsubfn&#39; 5.6.11.2 f:strapply(gsubfn) Use to operate on atoms of string. Atom in a single sign/element or elements in round braces. require(gsubfn) strapply(X = &#39;asdcsac&#39;, pattern = &#39;[[:alpha:]]&#39;) strapply(X = &#39;asdcsac&#39;, pattern = &#39;([[:alpha:]]+)&#39;) strapply(X = &#39;45365asdcsac&#39;, pattern = &#39;[[:digit:]]+|[[:alpha:]]+&#39;) 5.6.11.3 f:charmatch(base) charmatch(&quot;med&quot;, c(&quot;mean&quot;, &quot;median&quot;, &quot;mode&quot;)) 5.6.11.4 sklejanie ramek danych i dodatkowe argumenty do f:do.call sklejone_dane &lt;- do.call(paste, c(OD_zm_robocza_1[,which(names(OD_zm_robocza_1)%in%names(kod_tab_1[,-ncol(kod_tab_1)]))], sep=&#39;&#39;) ) 5.6.11.5 f:match #zwraca pierwszy napotkany podciag znakow zgodny z wzorem str_match(&#39;kotalalalala&#39;, &#39;al&#39;) 5.6.12 Inne #ODWOCENIE KOLEJNOSCI ELEMENTOW STRINGU require(Kmisc) str_rev(&#39;abc&#39;) #PRZYCINANIE STRINGU require(BBmisc) clipString(c(&#39;sdcasc sadcsadc&#39;, &#39;sdc asdc&#39;), len=10, tail=&#39;...&#39;) 5.6.13 p:stringr - dzialanie wetorowe require(stringr) #wektorowe dzialanie na funkcji str_sub m.s &lt;- matrix(c(c(1,3,5,7,9), c(1,4,7,10,NA)), byrow=TRUE, nrow=2) m.e &lt;- matrix(c(c(2,4,6,8,10), c(3,6,9,12,NA)), byrow=TRUE, nrow=2) matrix(str_sub(c(&#39;alalalalalala&#39;,&#39;klsklsklsklsklskls&#39;), m.s, m.e), byrow=TRUE, ncol=2 ) matrix(str_sub(c(&#39;alalalalalala&#39;,&#39;klsklsklsklsklskls&#39;), m.s, m.e), byrow=FALSE, nrow=2 ) # wektorowe dzialanie na funkcji str_detect str_detect(c(&#39;lupa&#39;,&#39;kot&#39;), c(&#39;lu&#39;,&#39;ko&#39;)) 5.6.14 regular expressions [wyrazenia regularne] 5.6.14.1 Zamiana stringu na regular expression require(utils) glob2rx(&quot;abc.*&quot;) 5.6.14.2 Rodzaje regular expressions W r są dwa rodzaje regular expression: extended regular expression perl Perl jest tak naprawdę rozszerzeniem extended. W helpie do hasła ‘regex’ jest jeden wyjątek opisujący sprzeczność miedzy tymi dwoma systemami. Turning off regular regular expression in p:stringr string &lt;- c(&#39;a.a&#39;, &#39;b.b&#39;) stringr::str_detect(string, pattern = &#39;...&#39;) # turned ON stringr::str_detect(string, pattern = stringr::fixed(&#39;...&#39;)) # turned OFF 5.6.14.3 Rodzaje uzywanych symboli Tzn. matcharacters: $ * + . ? [ ] ^ { } | ( ) \\ Definicje: “.” matches everything except for the empty sting &quot;&quot;. “+” the preceding item will be matched one or more times. &quot;*&quot; the preceding item will be matched zero or more times. “^” matches the empty string at the at the beginning of a line. UWaga w ‘character class’ ma to inne znaczenie When used in a character class (see explanation about character classes in the following section) means to match any character but the following ones. “$” matches empty string at the end of a line. “|” infix operator: OR “(”, “)” brackets for grouping. “[&quot;, &quot;]” character class brackets (see next section). Rozszerzenie o Perl: (?=…) - PRZED wyrazeniem na byc wyrazenie okreslone przez trzykropek (?!…) (?&lt;=…) - PO wyrazeniem na byc wyrazenie okreslone przez trzykropek (?&lt;!…) Dodatkowe symbole pomocznice [:alnum:] - litery i cyfry [:alpha:] - male i duze litery [:lower:] - male litery [:upper:] - duze litery [:digit:] - cyfry [:punct:] - znaki takie jak: ! &quot; # $ % &amp; ’ ( ) * + , - . / : ; &lt; = &gt; ? @ [ ] ^ _ ` { | } ~ 5.6.14.4 Hierarchia operatorow () {},? ^ Kolejnosc operatorow wzieta ze strony. Moim zdaniem jedynka z dwójką powinny być odwrocony. Next remarks obout operators ^ - $ - - do rozdzielenia nawiasow okraglych oraz calych wyrazen () - dobrze organizuje kod [] - {} - dotyczy jednego symbolu poprzedzajcego lub wyrazenia w nawiasie okraglym \\ - dotyczy pojedynczych symboli 5.6.14.5 Przyklady uzycia symboli str_extract_all(&#39;abc&#39;, pattern = &#39;a.&#39;) # &#39;a&#39; and any symbol that is next to str_detect(c(&#39;abc&#39;, &#39;bac&#39;), pattern = &#39;^a&#39;) # if string starts with &#39;a&#39; str_detect(c(&#39;abc&#39;, &#39;acb&#39;), pattern = &#39;c$&#39;) # if string ends with &#39;c&#39; str_detect(c(&#39;aa&#39;,&#39;bb&#39;), &#39;a|b&#39;) # if string contains &#39;a&#39; or &#39;b&#39; # see the differnce!!! str_replace(&#39;abcd&#39;, pattern = &#39;ab|cd&#39;, replacement = &#39;c&#39;) # only &#39;ab&#39; was replaced with &#39;c&#39; str_replace(&#39;abcd&#39;, pattern = &#39;(ab)|(cd)&#39;, replacement = &#39;c&#39;) # only &#39;ab&#39; was replaced with &#39;c&#39; str_replace_all(&#39;abcd&#39;, pattern = &#39;ab|cd&#39;, replacement = &#39;c&#39;) # &#39;ab&#39; and &#39;cd&#39; was replaced with &#39;c&#39; str_replace_all( &#39;aabcdef&#39;, &#39;(^a)|b&#39; , &#39;c&#39; ) # replace &#39;a&#39; if it is firt sign or &#39;b&#39; str_replace_all( &#39;aabcdef&#39;, &#39;[abf]&#39; , &#39;C&#39; ) # replace &#39;a&#39; or &#39;b&#39; or &#39;f&#39; str_replace_all( &#39;aabcdef&#39;, &#39;[^abf]&#39; , &#39;C&#39; ) # replace NOT &#39;a&#39;, &#39;b&#39; or &#39;f&#39; string &lt;- c(&#39;ala&#39;,&#39;aa&#39;,&#39;allllla&#39;) str_extract(string, &#39;a?&#39;) str_extract(string, &#39;a+&#39;) str_extract(string, &#39;a*&#39;) str_extract(string, &#39;a{2}&#39;) str_extract(string, &#39;a{1,2}&#39;) str_extract(&#39;abc.efg.hij&#39;, &#39;([^\\\\.]{1,})$&#39;) str_extract(&#39;abcZabc&#39;, &#39;.{0,}(?=Z)&#39;) str_extract(&#39;abc.efg.hij&#39;, &#39;(?&lt;=\\\\.)[^\\\\.]{0,}$&#39;) # elementy ktore sa po ostatniej kropce str_extract(&#39;abc.efg.hij&#39;, &#39;([^\\\\.]{1,})$&#39;) # elementy ktore sa po ostatniej kropce (second way) str_extract(&#39;abc.efg.hij&#39;, &#39;.{0,}(?=(\\\\.[^\\\\.]{1,})$)&#39;) # elementy ktore sa przed ostatnia kropka str_extract(c(&#39;zabc&#39;, &#39;wabc&#39;), &#39;(z)(?=abc)&#39;) # &#39;abc&#39; poprzedzone przez &#39;z&#39; str_extract(c(&#39;zwgr&#39;, &#39;zabc&#39;), &#39;(z)(?!abc)&#39;) # cos innego niz &#39;abc&#39; poprzedzone przez &#39;z&#39; str_extract(c(&#39;alac&#39;, &#39;alaw&#39;), &#39;(?&lt;=ala)(w)&#39;) # &#39;abc&#39; za ktorym jest &#39;w&#39; str_extract(c(&#39;rtgw&#39;, &#39;alaw&#39;), &#39;(?&lt;!ala)(w)&#39;) # cos innego niz &#39;abc&#39; za ktorym jest &#39;w&#39; # znaki specjalne - kropka str_locate(&#39;a.a&#39;, &#39;.&#39;) str_locate(&#39;a.a&#39;, &#39;\\\\.&#39;) str_locate_all(&#39;a(a)b&#39;, &#39;(|)&#39;) str_locate_all(&#39;a(a)b&#39;, &#39;\\\\(|\\\\)&#39;) str_locate(&#39;a|a&#39;, &#39;|&#39;) str_locate(&#39;a|a&#39;, &#39;\\\\|&#39;) 5.7 date and POSIX Patrz artykuly/Dates_and_Times_Made_Easy_with_lubridate.pdf}{artykul} na temat pakietu lubridate. Zrodla: Artykul: ‘Dates and Times in R ze strony Berkley’ 5.7.1 Data types W R-cran sa 4 podstawowe sposoby przechowywania informacji o datach i czasie Date-przechowuje date z dokladnoscia do dni. Date jest typem numeric. Przy konwertowaniu liczby na date trzeba podac parametr origin. chron (wymaga pakietu chron)-przechowuje date i godzine jako oddziele elementy listy (thetimes = chron(dates=?2002-06-09?,times=12:45:40,format=c('y-m-d','h:m:s'))) POSIXlt-przechowuje date i godzine jako liste oddzielnych elementow. Jako ze jest to lista elementy mozna wyciagac z przy uzyciu dolara. Poprzez funkcje ‘structure’ mozna latwo zobaczyc wszystkie elementy skladajace sie na obiekt. POSIXct-tak jak typ Date przechowuje data w postaci liczby. Ale tutaj liczba oznacza ilosc sekund wiec mamy do czynienia z wieksza precyzji. Istnieje zmienna origin w p:lubridate przechowujaca domyslnie date ‘1970-01-01’. 5.7.2 Zapisywanie dat i konwertowanie na daty 5.7.2.1 Typ Date as.Date(&#39;1915-6-16&#39;) as.Date(&#39;1990/02/17&#39;) as.Date(&#39;1/15/2001&#39;,format=&#39;%m/%d/%Y&#39;) as.Date(&#39;April 26, 2001&#39;,format=&#39;%B %d, %Y&#39;) #if converting from number origin is necessery. (For convenience use variable &#39;origin&#39; from p:lubridate) as.Date(2345, origin=&#39;1970-01-01&#39;) Kod dla typu ‘Data’ Wartosc %d dzien miesiaca ——————– ——– %m miesisc-liczba ——————– ——– %b miesisc-skrot ——————– ——– %B miesisc-pelna nazwa ——————– ——– %y rok-2 cyfry ——————– ——– %Y rok-4 cyfry 5.7.2.2 Typ chron require(chron) d &lt;- dates(&#39;11/14/92&#39;) #kolejnosc-miesiac/dzien/rok (po amerykansku) t &lt;- times &lt;- &#39;23:45:32&#39; z &lt;- chron(d,t) dates &lt;- dates(c(&quot;02/27/92&quot;, &quot;02/27/92&quot;, &quot;01/14/92&quot;, &quot;02/28/92&quot;, &quot;02/01/92&quot;)) times &lt;- times(c(&quot;23:03:20&quot;, &quot;22:29:56&quot;, &quot;01:03:30&quot;, &quot;18:21:03&quot;, &quot;16:56:26&quot;)) #now connect dates and times into one. z4 &lt;- chron(dates = dates, times = times) #default origin is 1970-01-01 Dla dat i godzin mozna okreslac parametr format: Kod Wartosc m miesiac-liczba —- ——– d dziel-liczba —- ——– y rok-4cyfry —- ——– mon miesiac-skrot —- ——– month miesiac-pelna nazwa Kod Wartosc h godzina —- ——– m minuta —- ——– s sekunda 5.7.2.3 POSIX #If converting from number giving origin is essencial. z &lt;- 1472562988 z2 &lt;- as.POSIXct(z, origin = &quot;1960-01-01&quot;) W przypadku POSIXlt i POSIXct mozna uwzgledniac zagadnienie stref czasowych (parameter tz - short for time zone). 5.7.3 Date NA, NaN and Inf as.Date(c(&#39;1999-09-09&#39;, NaN, Inf)) #NA and Inf are converted into NA as.POSIXct(c(Sys.time(), NaN, Inf)) as.POSIXlt(c(Sys.time(), NaN, Inf)) #Converting value in Date vector into NaN is immpossible z &lt;- as.Date(Sys.time()) replace(z, is.infinite(z), NaN) 5.7.4 Extracting element from date 5.7.4.1 p:base x &lt;- as.Date(&#39;1985-06-16&#39;) base::weekdays(x) base::months(x) base::quarters(x) 5.7.4.2 p:lubridate require(lubridate) x &lt;- as.Date(&#39;1985-06-16&#39;) lubridate::second(x) lubridate::minute(x) lubridate::hour(x) lubridate::day(x) lubridate::days(x) lubridate::days_in_month(x) #number of days in month lubridate::week(x) #ktory tydzien lubridate::month(x) lubridate::quarter(x) lubridate::years(x) lubridate::year(x) #ktory rok lubridate::yday(x) #ktory dzien roku lubridate::wday(x) #ktory dzien tygodnia lubridate::mday(x) #ktory dzien miesiaca lubridate::decimal_date(x) #ile procent roku uplynelo od pierwszego stycznia 5.7.4.3 p:lubridate- converting strings to dates Pakiet ma funkcje do bezposredniego konwertowania stringow na daty: z = ymd(&quot;1970-10-15&quot;) z =mdy(&quot;10/15/1970&quot;) z = dmy(15101970) 5.7.5 Dates differences time1 &lt;- as.Date(&#39;2013-12-11&#39;) time2 &lt;- as.Date(&#39;2013-02-09&#39;) d &lt;- difftime(time1, time2, tz,units = c(&quot;secs&quot;)) #UNITS WYSTEPUJE W WARIANTACH: &quot;auto&quot;, &quot;secs&quot;, &quot;mins&quot;, &quot;hours&quot;, &quot;days&quot;, &quot;weeks&quot; class(d) #dostajemy diffdate-moe podowodowac problemy i lepiej przekonwertowac na zwykla liczbe mode(d) Number of months between dates. Pretty easy: convert to POSIXlt, then use something like: 12*x\\(year + x\\)month and subtract those. You could set up a class for ‘months’ and have as.months and a ‘-’ method. 5.7.6 Arithmetic operations on dates 5.7.6.1 Rounding dates [zaokroglanie dat] require(lubridate) round_date(z, &quot;month&quot;) #round date to first of month round_date(z, &quot;year&quot;) #zaokraglanie do pierwszego najblizszego dnia roku round_date(z, &quot;week&quot;) #zaokraglanie do pierwszego najlizszego dnia tygodnia ceiling_date(z, &#39;week&#39;) floor_date(z, &#39;week&#39;) 5.7.6.2 Date incrementation [inkrementacja daty] z &lt;- as.Date(&#39;1980-09-07&#39;) z + 2 #dodanie dwoch dni do daty require(lubridate) z + seconds(552) z + minutes(552) z + hours(87) z + days(2) z + weeks(5) z + months(1) z + years(3) 5.7.6.3 Date sequences [Ciagi dat] seq(as.Date(&#39;1976-7-4&#39;),by=&#39;days&#39;,length=10) seq(as.Date(&#39;2000-6-1&#39;),to=as.Date(&#39;2000-8-1&#39;),by=&#39;2 weeks&#39;) seq(as.Date(&#39;2000-6-1&#39;),to=as.Date(&#39;1999-5-1&#39;),by=&#39;-2 weeks&#39;) #malejacy ciag Warning! Jezeli uzywamy typu chron w parametrze by nie mozna wstawiac liczby (np. by=&quot;2 weeks&quot;) W przypadku dat mozna stosowac f:cut: cut(thetimes,&quot;year&quot;) 5.7.7 Inne 5.7.7.1 Czy zadana data znajduje sie w okreslonym interwale czasowym: require(lubridate) w &lt;- new_difftime(days=30) z &lt;- as.Date(&#39;2014-11-06&#39;) i &lt;- as.interval(w, z) #zdefiniowanie interwalu g &lt;- ymd(&quot;2012/05/02&quot;) #data g %within% i #czy data g znajduje sie w interwale i 5.8 factor 5.8.1 Atrybuty x &lt;- factor(c(1:5)) table(x) #faktyczna ilosc roznych czynnikow unique(x) #faktyczne czynniki levels(x) #czynniki dopuszczalne nlevels(x) #ilosc czynnikow dopuszczalnych labels(x) #etykiety bedace liczbami naturalnymi length(x) #ilosc elementow sum(is.na(x)) #ilosc brakow danych 5.8.2 Podstawowe operacja zwiazane z typem factor #Tworzenie czynnika z &lt;- factor(c(2,4,6), levels=c(1,2,3,4,5,6)) c &lt;- factor(c(&#39;A&#39;,&#39;B&#39;,&#39;A&#39;),levels=c(&#39;A&#39;,&#39;B&#39;,&#39;C&#39;)) #Tworzenie czynnika wedlug wzorca g &lt;- gl(2,5,labels=c(&#39;a&#39;,&#39;b&#39;)) #otrzymamy: a a a a a b b b b b g #Zmiana poziomu atrybutu (levels) dla czynnika attr(c,&#39;levels&#39;) &lt;- c(&#39;zly&#39;, &#39;dobry&#39;) levels(c) &lt;- c(1,2,3,4,5,10) c #Funkcja attr-zmienia atrybut names - przypisanie nowych nazw elementow wektora x: x &lt;- factor(c(1,2,3)) attr(x, &#39;names&#39;) &lt;- c(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;) x 5.8.3 Co to jest levels #dopuszczalne wartosci leveli #dopuszczalne wartosci leveli #braki danych #domyslnie NA nie jest poziomem (exclude=NA) factor(c(1,NA)) #brak danych moze byc oddzielnym levelem, jezeli parametr &#39;exclude&#39; ma wartosc NULL. z3 &lt;- factor(c(1,2,NA), exclude=NULL) levels(z3) #parametrem exclude mozna wykluczyc inne elementy z &lt;- factor(c(1,2,3,4), exclude=c(3,4)) #levels musi sie pokrywac z wartosciami faktycznymi bo to nie sa etykiety!!!! z4 &lt;- factor(x=c(1,2,3,4), levels=c(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;)) z4 #wywali braki danych bo wartosci 1,2,3,4 i niepasuja do zadnych leveli levels(z4) labels(z4) 5.8.4 labels #labels oznacza kolejnosc. Sluzy np. do sortowania.Labels sa zawsze liczbami naturalnymi. z5 &lt;- factor(c(3,2), labels=c(2,1)) sort(z5) labels a duplikaty: z6 &lt;- factor(c(1,1,2,2,4,4,3,3)) labels(z6) #uwaga. nie mozna przypisac dwom roznym elementom tych samych labels. Nawet jezeli elementy maja ta sama wartosci. Dlatego tez labels jest dokladnie tyle ile elementow i kazdy ma swoj identyfikatow z7 &lt;- factor(c(1,1,2), labels=c(1,1,2) ) 5.8.5 Usuwanie i dodawanie poziomow czynnika #dodawanie i usuwanie leveli z factor #dodawanie z9 &lt;- factor(c(1,2,3)) levels(z9) &lt;- c(1,3,4,5) #wypisujemy stare levele oraz dodajemy nowe # levels(z9) &lt;- c(1,2) #Blad. leveli przypisywanych jest mniej niz w zmiennej #Error in `levels &lt;- .factor`(`*tmp*`, value = c(1, 2, 3)) : number of levels differs #Uwaga. Blad ten bedzie nawet jezeli w zbiorze wartosci nie bedzie brakujacego czynnika a=factor(c(1:4)) a &lt;- a[1:3] a levels(a) &lt;- c(1,2,3) #usuwanie #jezeli ze zbioru usunelismy czesc obserwacji i chcemy zeby levele odpowiadaly faktycznie wystepujacym wartoscia w nowym podzbiorze danych po prostu dokonujemy nadpisania z &lt;- factor(z) #jezeli chcemy sterowac usuwaniem leveli recznie stosujemy drop.factor. Funkcja dziala dla nadmiarowych leveli. Nie usuwa leveli dla ktorych wystepuje wartosc. require(gdata) z9 &lt;- factor(c(1,2,3)) z9 &lt;- z9[1:2] drop.levels(z9) #drop.level dziala tez na ramce danych z czynnikami. Zwroc uwage ze trzeci element nie jest typu factor i nie bedzie brany pod uwage dane &lt;- data.frame(a=factor(c(1:4)), b=factor(letters[1:4]), c=c(1,2,3,4)) dane &lt;- dane[1:3 levels(dane[,1]) levels(dane[,2]) levels(dane[,3]) drop.levels(dane) levels(dane[,1]) levels(dane[,2]) levels(dane[,3]) #jezeli ze zbioru zniknely np. 2 czynniki a chcemy z leveli usunac tylko jeden postpeujemy tak: z &lt;- factor(c(1:5)) z &lt;- z[1:3] z &lt;- factor(z) levels(z) &lt;- c(1,2,3,4) #co jezeli w zdefuniowanym factor levels nie pokrywaja wartosci z &lt;- factor(c(1,2,3,4,5), levels=c(1,2)) #nie wywali bledu, ale w miejscu elemento gdzie ktorym nic nie odpowiada na liscie czynnikow sa wartosci NA z 5.8.6 Transformowanie na inne typy danych #jak R automatycznie transformuje czynnik factor #numeric c1 &lt;- c(1,2,3) c2 &lt;- factor(c(&#39;a&#39;,&#39;b&#39;)) c3 &lt;- c(c1,c2) c3 class(c3) #dostajemy &#39;numeric #character c1 &lt;- c(&#39;x&#39;,&#39;y&#39;,&#39;z&#39;) c2 &lt;- factor(c(&#39;a&#39;,&#39;b&#39;)) c3 &lt;- c(c1,c2) c3 &gt; c3 #dostajemy labels [1] &quot;x&quot; &quot;y&quot; &quot;z&quot; &quot;1&quot; &quot;2&quot; class(c3) #dostajemy &#39;character&#39; #inny factor c1 &lt;- factor(c(&#39;x&#39;,&#39;y&#39;,&#39;z&#39;)) c2 &lt;- factor(c(&#39;a&#39;,&#39;b&#39;)) c3 &lt;- c(c1,c2) c3 class(c3) #dostajemy &#39;integer&#39; z lista labels pierwszego i drugiego wektora #data c1 &lt;- as.Date(c(&#39;2013-09-09&#39;, &#39;2012-11-06&#39;)) c2 &lt;- factor(c(&#39;a&#39;,&#39;b&#39;)) c3 &lt;- c(c1,c2) c3 class(c3) #dostajemy &#39;data&#39; &gt; c3 #dostajemy labels [1] &quot;2013-09-09&quot; &quot;2012-11-06&quot; &quot;1970-01-02&quot; &quot;1970-01-03&quot; #logical c1 &lt;- c(TRUE, FALSE) class(c1) c2 &lt;- factor(c(&#39;a&#39;,&#39;b&#39;)) c3 &lt;- c(c1,c2) c3 class(c3) #dostajemy &#39;integer&#39; require(BBmisc) h1 &lt;- factor(c(&#39;a&#39;,&#39;b&#39;), levels=c(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;)) h2 &lt;- factor(c(&#39;r&#39;,&#39;s&#39;), levels=c(&#39;r&#39;,&#39;s&#39;,&#39;t&#39;)) droplevels(cFactor(h1,h2)) 5.8.7 Duplikaty #WEKTORY w &lt;- c(1,1,2,2,3,3) unique(w) duplicated(w) #wartosci logiczne ktore elementy sa duplikatami !duplicated(w) #wartosci logiczne ktore elementy NIE sa duplikatami 5.8.8 Uwaga przy rekodowaniu czynnikow Warning! Trzeba uwazac przy rekodowaniu czynnikow. Jesli przekodujemy na wielkosc ktorej nie ma ustalonej w levels wywali nam blad. Trzeba wtedy dodac dany poziom to levels: h &lt;- factor(c(1,2,3,2,3,2,3,2), levels=c(1,2,3,4,5)) h h[h==2] &lt;- 10 #wywli blad bo nie ma takiego levelu levels(h) &lt;- c(1,2,3,4,5,10) h[h==2] &lt;- 10 #teraz zadziala h 5.8.9 Factor a automatyczne sortowanie Utworzenie zmiennej typu factor nie powoduje zadnego sortowania tych elementow: c &lt;- c(2,1,5,4,7,2,4,1) b &lt;- c(&#39;b&#39;,&#39;a&#39;,&#39;w&#39;,&#39;g&#39;) factor(c) factor(b) factor(c(3,1,4,3,2,5)) d &lt;- data.frame(a=c(1,3,2,5), b=c(2,3,1,2)) d[,3] &lt;- factor(d[,2]) d 5.8.10 Sortowanie factor (wg. wartosci czy wg etykiet) z1 &lt;- factor(x=c(5,4,3,2,1), labels=c(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;)) z2 &lt;- factor(x=c(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;), labels=c(5,4,3,2,1)) sort(z2) Wniosek: sortowanie nastepuje wg. etykiet. 5.8.11 Factor a dzialania arytmetyczne Niestety nie mozna ich wykonac (w przypadku uporzadkowanego czynnika mozna badac znakami nierownosci!!!) z1 &lt;- factor(c(5,4,3,2,1)) z1 + 5 5.8.12 basic functions Especially functions from p:forcats fac_a &lt;- factor(c(letters[1:4],NA), levels=letters[1:8]) fac_b &lt;- addNA(fac_a) levels(factor(&#39;c&#39;, levels=c(&#39;c&#39;,&#39;d&#39;, NA))) # this will not NA as a level!!! nlevels(fac_b) fac_1 &lt;- fct_drop(fac_b, only=&#39;e&#39;) # NA will be dropped????? (it shouldn&#39;t) fac_2 &lt;- droplevels(fac_b) fct_c(factor(&#39;a&#39;, levels=c(&#39;a&#39;,&#39;b&#39;)), factor(&#39;c&#39;, levels=c(&#39;c&#39;,&#39;d&#39;))) fct_recode(fac_a , NEW_a=&#39;a&#39;, NEW_b=&#39;b&#39;) fct_expand(f = fac_a, &#39;z&#39;, NA) # NA will be added fct_relevel(fac_a, &#39;c&#39;, &#39;d&#39;, after=1L) 5.9 Other things 5.9.1 Atrybuty i podstawowe operacja z &lt;- integer() #pusty wektor/macierz typu integer z &lt;- rep(NA_real_, 10) #pusty wektor 10-elementowy typu real (liczby rzeczywiste) z &lt;- numeric() #pusty wektor/macierz o niezdefiniowanych rozmiarach #czy kazdy kolejny elementow jest sobie rowny? a1 &lt;- c(1:4) b1 &lt;- c(1:4) a1 == b1 #czy wektory ogolnie sa sobie rowne? all.equal(a1,b1) #dostaniemy jedna wartosc logiczna. W tej funkcji mozemy rowniez stosowac parametr &#39;tolerance&#39; ktory nie do konca wiem jak jest zdefiniowany (trzeba przeanalizowac dokladnie skladnie funkcji). 5.9.2 Sortowanie #wektory z &lt;- c(2,3,5,4,3,5,6,7) sort(z, decreasing = T, na.last=T) #sort sluzy tylko do sortowania wektoroW. &#39;decreasing&#39; ma domyslnie wartosc FALSE rev(z) #to samo co sort(z, decresing=T) z &lt;- c(&#39;b&#39;,&#39;a&#39;,&#39;z&#39;,&#39;f&#39;) sort(z) #sortowanie alfabetyczne stringoW z &lt;- c(TRUE, FALSE, TRUE) sort(z) #sortowanie wartosci logicznych order(z, na.last=T, decreasing=F) #okresla na ktorej pozycji powinny byc kolejne elementy jezeli bysmy je posortowali 5.9.3 f:rank(base), f:dense_rank(dplyr), f:min_rank(dplyr), f:order(base) See also rank function in p:dplyr. z1 &lt;- c(1,2,2,5,4) rank(z1, na.last=TRUE, ties.method = &#39;first&#39;) rank(z1, na.last=TRUE, ties.method = &#39;max&#39;) rank(z1, na.last=TRUE, ties.method = &#39;min&#39;) # in p:dplyr equivalent is f:min.rank rank(z1, na.last=TRUE, ties.method = &#39;average&#39;) rank(z1, na.last=TRUE, ties.method = &#39;random&#39;) # there is not possible to get from f:rank results like from function below: dplyr::dense_rank(z1) order(z1) Difference between f:rank and f:order: Example: z1 &lt;- c(1,2,2,5,4) rank(z1, ties.method = &#39;first&#39;) order(z1) z2 &lt;- c(4,5,2,2,1) rank(z2, ties.method = &#39;first&#39;) order(z2) z2[order(z2)] f:order only show as place where element should be placed (element is pointed by its index) to get sorted vector. 5.9.4 f:order, f:sort Unlike in f:rank there is only one algotyhm. We can just choice between ascending and descending ordering. number &lt;- c(2,1,4,3,6,10) text &lt;- c(&#39;al&#39;, &#39;bw&#39;, &#39;-op&#39;, &#39;*uio&#39;) date &lt;- as.Date(c(4589, 4305), origin=&#39;1970-01-01&#39;) date_posix &lt;- as.Date(c(45389, 43905), origin=&#39;1970-01-01&#39;) order(number, na.last = TRUE, decreasing = TRUE) order(text) order(date) order(date_posix) sort(number, decreasing = TRUE, na.last = TRUE) sort(text) sort(date) sort(date_posix) 5.9.5 f:which , f:match i f:%in% #which zwraca indeksy pozycji wektora/macierzy, spelniajace okreslone warunki. z &lt;- c(2,3,4,2,3,4,3,2,1,4,5,6,5,4,5) which(z &gt; 2) w &lt;- c(3,2,4,1) w %in% z #zwraca wartosci logiczne okreslajace ktore kolejne elementy wektora &#39;w&#39; maja odpowiednik w wektorze &#39;z&#39; #match-informuje ktorym indeksom drugiego wektora-macierzy odpowiadaja kolejne elementarz pierwszego wektora/macierzy. z1 &lt;- c(1, 2, 3, 4) z2 &lt;- c(3, 2, 1, 4, 5) match(z1, z2) #Uwaga. Funckcja informuje jedynie o pierwszym napotkaniu wystapienia danej wartosci: a1 &lt;- c(1,2,3,4) b1 &lt;- c(1,2,10,2) #funkcja nie wzkaze ze wartosc 2 jest nie tylko na drugiej ale i na czwartek pozycji wektora b1. match(a1,b1) #Aby rozwiazac powyzszy problem mozna zastosowac funkcje find.matches require(Hmisc) find.matches(a1, b1) #wiecej o f:find.matches patrz indeks funkcji) Above functions and NA which.min(c(1,2,3,NA,4,5)) # works for NA values which.max(c(1,2,3,NA,4,5)) # works for NA values which(c(1,2,3,4,NA)&gt;2) # works for NA c(1,2,3,NA) %in% c(NA,3,5) # works for NA match(c(1,2,3,NA), c(2,3,4,6,7,8,NA)) # f:match works for NA 5.9.6 f:find.matches #ZASTOSOWANIE FUNKCJI find.matches (pakiet Hmisc) require(Hmisc) y &lt;- rbind(c(.1, .2),c(.11, .22), c(.3, .4), c(.31, .41), c(.32, 5)) x &lt;- rbind(c(.09,.21), c(.29,.39)) y x w &lt;- find.matches(x, y, maxmatch=5, tol=c(.05,.05)) #Nie wolno stosowac wartosci ujemnych dla tolerancji. Tolerancja jest +/- symetrycznie w obie strony w Interpretacja wynikow: Pierwszy wiersz ramki x pasuje do wiersza 1 i 2 ramki y. Drugi wiersz ramki x pasuje do wiesza 3 i 4 ramki y. This funciton does not work correctly with NA: find.matches(c(1,2,3,NA), c(2,3,4,6,7,8,NA)) # f:find.matches does not work for NA. "],
["own-data-types-and-structures.html", "Chapter 6 OWN DATA TYPES AND STRUCTURES 6.1 what is dispatching 6.2 S3 6.3 S4 6.4 RC-references classes 6.5 R6 6.6 Prototypes 6.7 Pointers 6.8 Other issues", " Chapter 6 OWN DATA TYPES AND STRUCTURES 6.1 what is dispatching First let’s say what a message and a method are: A message is a name that can be sent from one object to another, possibly with additional objects as arguments. For example in account withdraw: 100 The message is withdraw: (Smalltalk syntax.) (Other languages might write account.withdraw(100).) The object receiving the message, in this example account, is called the receiver. A method is an implementation that can be invoked in response to a message. These ideas are shared among a wide variety of object-oriented languages, sometimes under different names. For example, C++ calls a message a ‘virtual member function’. Now: Method dispatch is the algorithm used to decide which method should be invoked in response to a message. Algorithms vary dramatically across languages: Languages like Smalltalk, which have classes and single inheritance, consult the class of the receiver. If the method is defined on that class, that method is invoked. Otherwise the algorithm checks the unique superclass, and so on. In C++, the method is still determined by the class of the receiver, but because a class can have multiple superclasses, the problem of deciding which method to invoke is more complicated. In languages like Self, which have methods but no classes, the method is either found in a named slot on the receiver itself, or possibly is found in the prototype from which the object was cloned. In more advanced object-oriented languages, the method-dispatch algorithm examines not only the receiver but the arguments that are passed along with the message. This idea is sometimes referred to as &#39;multimethods&#39;. (To a degree, this technique can be simulated using what Smalltalk calls double dispatch, but there&#39;s a programming cost and a performance cost.) I believe the languages Cecil, Diesel, and Dylan all use some form of multimethod dispatch, but I&#39;m teetering on the edge of my expertise. Patrz 6.2 S3 6.2.1 useful functions #see methods methods(&#39;mean&#39;) methods(&#39;t.test&#39;) require(pryr) df &lt;- data.frame(x = 1:10, y = letters[1:10]) otype(df) otype(df$x) otype(df$y) ftype(t.data.frame) # data frame method for t() ftype(t.test) 6.2.2 creating new class and new object foo &lt;-list() class(foo) &lt;- &#39;ff&#39; #assing object to class class(foo) inherits(foo, &#39;ff&#39;) #checking if object is foo-class 6.2.3 creating new generics and new methods (overloading) see: Biecek1 s. 51 #new generic f &lt;- function(x) UseMethod(&quot;f&quot;) f.a &lt;- function(x) &quot;Class a&quot; a &lt;- structure(list(), class = &quot;a&quot;) class(a) #overloading #przeciazymy funkcje plot dla obiektu typu logical: plot.logical()&lt;-function(obj) { cat(ifelse(obj, &#39;prawda&#39;, &#39;nieprawda&#39;)) } #dla wartosci logicnej &#39;TRUE&#39; funkcja &#39;plot&#39; wyswietli &#39;prawda, a dla &#39;FALSE&#39; wyswietli &#39;nieprawda&#39; pamietac o f:NexMethod przy definiowaniu funkcji w S3-wazne jezeli obiekt nalezy do kilku klas 6.3 S4 6.3.1 utworzenie nowej klasy setClass( Class=&#39;l1&#39;, #nazwa klasy slots=c(x=&#39;numeric&#39;, y=&#39;character&#39;), #nazwy slotow i typy danych jakie przechowuja contains=NULL, #z jakich klas sa dziedziczone sloty i metody prototype=NULL, #wartosci domyslne dla slotow #representation=NULL, # zrgument &#39;slots&#39; i &#39;cantains&#39; w jednym. Nie moze byc uzyty jezeli wczesniej uzyto argumentu &#39;slots&#39;!!!. Nie zaleca sie jego uzywania. validity=NULL, #reguly integralnosci sealed=F, #czy klasa jest zadokowana (nie mozna jej nadpisac nowa klasa o tej samej nazwie) ) getClass(&#39;l1&#39;) #informacja o nowej klasie &#39;l1&#39; z&lt;-new(&#39;l1&#39;, x=10, y=&#39;a&#39;) z@x removeClass(&#39;l1&#39;) #ustawianie wartosci domyslnych setClass( Class=&#39;l1&#39;, slots=c(x=&#39;numeric&#39;, y=&#39;character&#39;), contains=NULL, prototype=NULL ) removeClass(&#39;l1&#39;) #usuwanie klasy. Uwaga: nie powoduje automatycznego usuniecia metod zwiazanych z klasa!!! #wartosci domyslne setClass( Class=&#39;l2&#39;, slots=c(x=&#39;numeric&#39;,y=&#39;character&#39;), prototype=c(x=matrix(c(4,5)), y=&#39;ble&#39;) ) #ustawianie ograniczen-validacja 1 sposob-bezposrednio w setClass przy pomocy argumentu valitity 2 sposob-utworzyc klase przy pomocy funkcji setClass, a nastenie uzyc funkcji setValidity ad1: setClass( Class=&#39;l1&#39;, #nazwa klasy slots=c(x=&#39;numeric&#39;, y=&#39;character&#39;), validity=function(object){ if(object@x&gt;100) { cat(&#39;niedopuszczalna wartosc&#39;) stop(&quot;niedopuszczalna wartosc&quot;) #przerwanie tworzenia obiektu }else TRUE}, #reguly integralnosci ) new(&#39;l1&#39;, x=110, y=&#39;fv&#39;) ad2: setClass( Class=&#39;l1&#39;, #nazwa klasy slots=c(x=&#39;numeric&#39;, y=&#39;character&#39;), ) setValidity(&#39;l1&#39;, function(object){ if(object@x&gt;100) { cat(&#39;niedopuszczalna wartosc&#39;) stop(&quot;niedopuszczalna wartosc&quot;) #przerwanie tworzenia obiektu }else TRUE}, #reguly integralnosci ) } new(&#39;l1&#39;, x=110, y=&#39;fv&#39;) #dziedzicznie slotow (na na razie bez funkcji) #sloty nie moga miec tych samych nazw (nawet jesli sa przypisane inne typy)!!!. setClass(Class=&#39;l1&#39;, slots=c(x=&#39;numeric&#39;,y=&#39;character&#39;,z=&#39;numeric&#39;)) setClass(Class=&#39;l2&#39;, slots=c(x=&#39;numeric&#39;,y=&#39;numeric&#39;, w=&#39;numeric&#39;)) setClass(Class=&#39;l3&#39;, slots=c(t=&#39;character&#39;), contains=c(&#39;l1&#39;,&#39;l2&#39;) ) #tutaj wywali blad #ponizej bedzie ok: setClass(Class=&#39;l1&#39;, slots=c(x=&#39;numeric&#39;,y=&#39;character&#39;,z=&#39;numeric&#39;)) setClass(Class=&#39;l2&#39;, slots=c(x1=&#39;numeric&#39;,y1=&#39;numeric&#39;, w=&#39;numeric&#39;)) setClass(Class=&#39;l3&#39;, slots=c(t=&#39;character&#39;), contains=c(&#39;l1&#39;,&#39;l2&#39;) ) getClass(&#39;l1&#39;) getClass(&#39;l2&#39;) getClass(&#39;l3&#39;) #metody przypisane bezposrednio do obiektu setClass(&#39;l1&#39;, slots=c(x=&#39;numeric&#39;,y=&#39;numeric&#39;)) setGeneric( name=&#39;metoda&#39;, #nazwa definiowanej metody def=function(x){ #przyjmowac wartosci (value) standardGeneric(&#39;metoda&#39;) # } ) setMethod(&#39;metoda&#39;,&#39;l1&#39;, definition=function(x){ #&#39;x&#39; poniewaz w funkcji generycznej tez jest &#39;x&#39; z&lt;-x@x+x@y return(z) } ) z1&lt;-new(&#39;l1&#39;, x=100, y=100) metoda(z1) #dziedziczenie metod setGeneric( name=&#39;metoda&#39;, #nazwa definiowanej metody def=function(x){ #przyjmowac wartosci (value) standardGeneric(&#39;metoda&#39;) # } ) setGeneric( name=&#39;metoda1&#39;, #nazwa definiowanej metody def=function(x){ #przyjmowac wartosci (value) standardGeneric(&#39;metoda1&#39;) # } ) setClass(Class=&#39;l1&#39;, slots=c(x=&#39;numeric&#39;,y=&#39;character&#39;,z=&#39;numeric&#39;)) setMethod(&#39;metoda&#39;,&#39;l1&#39;, definition=function(x){ #&#39;x&#39; poniewaz w funkcji generycznej tez jest &#39;x&#39; z&lt;-x@x+x@z return(z) } ) z1&lt;-new(&#39;l1&#39;, x=100, z=100) z1 metoda(z1) setClass(Class=&#39;l2&#39;, slots=c(x1=&#39;numeric&#39;,y1=&#39;numeric&#39;, w=&#39;numeric&#39;)) setMethod(&#39;metoda&#39;,&#39;l2&#39;, definition=function(x){ #&#39;x&#39; poniewaz w funkcji generycznej tez jest &#39;x&#39; z&lt;-x@x1*x@w return(z) } ) z2&lt;-new(&#39;l2&#39;, x1=100, w=100) z2 metoda(z2) setMethod(&#39;metoda1&#39;,&#39;l2&#39;, definition=function(x){ #&#39;x&#39; poniewaz w funkcji generycznej tez jest &#39;x&#39; z&lt;-x@x1/x@w return(z) } ) metoda1(z2) setClass(Class=&#39;l3&#39;, slots=c(t=&#39;character&#39;), contains=c(&#39;l1&#39;,&#39;l2&#39;) ) z3&lt;-new(&#39;l3&#39;, x=100, z=100 ,x1=100, w=100) z3 metoda(z3) #zadzialala metoda przejeta z pierwszej funkcji metoda1(z3) getMethod(&#39;l1&#39;) getMethods(&#39;l3&#39;) getMethods(&#39;l3&#39;) getMethod(&#39;metoda&#39;, signature=&#39;l1&#39;) #okreslona metoda dla okreslonej klasy getMethods(&#39;metoda&#39;) #informacje o metodzie &#39;metoda&#39; #Wniosek #sa przejmowane metody z obu obiektow. Jezeli oba obiekty maja przeciazenia dla tej samej funkcji to przjmowane jest przeciazanie dla pierwszej funkcji 6.3.2 Tworzenie nowych funkcji dla obiektow setGeneric( name=&#39;metoda&#39; #nazwa definiowanej metody def=function(x) #przyjmowac wartosci (value) { standardGeneric(&#39;metoda&#39;) # } ) #powyzej wygenerowana nowa metoda mozemy teraz modyfikowac szczegolowo poleceniem setMethod #There is no control over the existence of a setGeneric: if a setGeneric existed, the new definition destroyed the old one-in the same way as when you assign a value to a variable it destroys the preceding one-. A redefinition is often a mistake, the programmer was unaware that the function already existed. To protect oneself from this problem, it is possible to &#39;&#39;lock&#39;&#39; the definition of a method by using lockBinding: lockBinding(&#39;metoda&#39;,.GlobalEnv) showMethods(&#39;samochod&#39;)#pokazywanie metod dla danej klasy getMethod(f=&#39;plot&#39;, signature=&#39;samochod&#39;) #dostep do definicji metody 6.3.3 Redefiniowanie istniejacych funkcji dla obiektow removeClass(&#39;samochod&#39;) setClass(&#39;samochod&#39;, representation(moc=&#39;numeric&#39;, kolor=&#39;character&#39;), prototype(moc=255)) setMethod( f=&#39;plot&#39;, #nazwa funkcji ktora redefiniujemy!!! signature=&#39;samochod&#39;, #okrelam rodzaj klasy (nie konkretny obiekt) definition=function(x) #co robi metoda { g&lt;-x@moc*10 w&lt;-nchar(x@kolor) return(list(g,w)) } ) plot(z) plot.samochod(z) #wywali blad #uwaga. Przed redefiniowaniem funkcji dobrze jest zobaczyc jakie przyjmuje argumenty: args(plot) 6.3.4 obiekt w obiekcie setClass(Class=&#39;l1&#39;, slots=c(x=&#39;numeric&#39;)) setClass(Class=&#39;l2&#39;, slots=c(x1=&#39;numeric&#39;,y1=&#39;l1&#39;, w1=&#39;numeric&#39;)) t&lt;-new(&#39;l1&#39;,x=100) t@x&lt;-200 w&lt;-new(&#39;l2&#39;, x1=100 , y1=t ,w1=60) #y1 trzeba niestety zadeklarowac wczesniej 6.4 RC-references classes 6.5 R6 # moja pierwsza klasa: require(R6) # klasa jest ogolen # obiekt definiuje polaczenie z konkretna baza - podajemy wszystkie paramatry polaczenia # praca z baza postgresql # info o polaczeniu # info o liscie tabel # info o strukturze danej tabeli con &lt;- R6Class( classname = &#39;con&#39; , public = list( user = NA , password = NA , host = NA , dbname = NA , port = NA , initialize = function(user, password, dbname, port){ if(!missing(user)) self$user &lt;- user else self$user &lt;- &#39;postgres&#39; if(!missing(password)) self$password &lt;- password else self$password &lt;- &#39;Cognition_1&#39; if(!missing(host)) self$host &lt;- host else self$host &lt;- &#39;localhost&#39; if(!missing(dbname)) self$dbname &lt;- dbname else self$dbname &lt;- &#39;temporary&#39; if(!missing(port)) self$port &lt;- port else self$port &lt;- &#39;5432&#39; } ) active = list( connection_info &lt;- function(){RPostgreSQL::} tables_list &lt;- function(){RPostgreSQL::} RPostgreSQL::dbConnect( drv = &quot;PostgreSQL&quot; , user = user , password = password , host = host , dbname = dbname , port = port) ) ) ) # kopiowanie require(R6) # class creation kl_1 &lt;- R6Class( public=list( a=10 ) ) # creation of new object kl_1_1 &lt;- kl_1$new() # assigning object to new variable ww1 &lt;- kl_1_1 ww1$a ww1$a &lt;-20 ww1$a kl_1_1$a # dostajemy ta samo wartosc # sklonowanie ww2 &lt;- kl_1_1$clone() ww2$a &lt;- 30 ww2$a kl_1_1$a # przekazywanie do funkcji f1 &lt;- function(a){ a$a &lt;- 50 a } f1(kl_1_1) kl_1_1$a # dziala przez referencje!!! # dostepy wewnatrz a &lt;- rnorm(10) kl_2 &lt;- R6Class( public = list( a = 20 , fpb = function(){ private$b } , fpb_pr = function(){ private$fpr() } ), private = list( b = 20 , fpr = function(a=self$a){ list(a) } ) ) kl_2_1 &lt;- kl_2$new() kl_2_1$fpb() kl_2_1$fpb_pr() # rozne obiekty wewnatrz (s3, s4, r6) #R6 y&lt;-100 kl_3_a &lt;- R6Class( public=list( a=10 ,f2=function(){ return(y) } )) kl_3 &lt;- R6Class( public=list( s = NULL , y = -50 , f3 = function(){ y } , initialize = function(){ self$s &lt;- kl_3_a$new() } ) ) kl_3_1 &lt;- kl_3$new() # pytanie czy zwroci -50 czy 100 kl_3_1$s$f2() kl_3_1$f3() 6.6 Prototypes 6.7 Pointers UWAGA: wskaznik i referencja to chyba nie to samo (patrz moja ksiakzka c++ w 21 dni str 295). Roznica na przykladzie jezyka c++ jest opisana na stronie: http://stackoverflow.com/questions/57483/what-are-the-differences-between-a-pointer-variable-and-a-reference-variable-in Pointers and passing by reference in R I’ve been using an approach that Andy Houseman showed me to create pointers and allow passing by reference in R. The basic idea is to create a class constructor and have each instantiation of the class be its own environment. One can then pass the object/environment into a function and it will be passed by reference rather than by value, because unlike other R objects, environments are not copied when passed to functions. Changes to the object in the function will change the object in the calling frame. In this way, one can operate on the object and change internal elements without having to create a copy of the object when the function is called nor pass the entire object back from the function. For large objects, this saves memory and time. The elements of the object, e.g., ‘myFun’, are local variables within the environment, accessed via list-like syntax, e.g., myFun$value. Note that care must be taken when assigning such objects/pointers because environments are not copied when used in assignments. You need to create an explicit copy function; assignment merely creates an additional name (i.e., pointer) referencing the existing object. These ideas are used extensively in the spectralGP library. You may also want to look into the R.oo package. Here’s a basic example with a constructor, newPointer(), a copy S3 method, and an S3 method for updating the referenced value, updatePointerValue(): newPointer=function(inputValue){ object=new.env(parent=globalenv()) object$value=inputValue class(object)=&#39;pointer&#39; return(object) } copy=function (object, ...) { # create S3 generic UseMethod(&quot;copy&quot;) } copy.pointer=function(object1,object2=NULL,...){ if (is.null(object2)) { object2 = new.env(parent = globalenv()) class(object2) = class(object1) nullFlag = TRUE } elements = names(object1) for (index in 1:length(elements)) { assign(elements[index], get(elements[index], env = object1, inherits = FALSE), env = object2) } if (nullFlag) { return(object2) } else { return(NULL) } } updatePointerValue=function (object, ...) { # create S3 generic UseMethod(&quot;updatePointerValue&quot;) } updatePointerValue.pointer=function(object,newValue){ # create S3 method if (!is(object, &quot;pointer&quot;)) { stop(&quot; &#39;object&#39; argument must be of class &#39;pointer&#39; .&quot;) } object$value=newValue return(NULL) } ##### Example myP=newPointer(7) print(myP$value) # returns &#39;7&#39; newP=copy(myP) copyP=myP updatePointerValue(myP,9) print(copyP$value) # returns &#39;9&#39; print(newP$value) # returns &#39;7&#39; Keywords: R, pointer, call by reference, pass by reference, object orientation, environments, classes 6.8 Other issues "],
["data-processing-philosopies.html", "Chapter 7 DATA PROCESSING PHILOSOPIES 7.1 p:plyr 7.2 p:dplyr 7.3 p:purrr 7.4 p:tidyr 7.5 p:rlist 7.6 p:data.table 7.7 p:data.tree 7.8 apply family 7.9 p:muir 7.10 fuzzyjoin", " Chapter 7 DATA PROCESSING PHILOSOPIES 7.1 p:plyr melting and casting data dane&lt;-data.frame(a=rep(c(&#39;a&#39;,&#39;b&#39;), each=5), b=rep(c(&#39;z&#39;, &#39;y&#39;),5 ), c=sample(c(&#39;r&#39;,&#39;w&#39;),10, replace=T) , d=10:1, e=runif(10), f=runif(10), g=1:10) #proste topienie po wybranej zmiennej dane_1&lt;-melt(dane, id=c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;,&quot;d&quot;)) #trzeba wymienic WSZYSTKIE zmienne typu nienumerycznego. Dodatkowo mozna podac zmienne numeryczne #opcja measure wybiera zmienne metrczne. Informacje to w obiekcie stworzonym przez &#39;melt&#39; wykorzystuje &#39;cast&#39; i decast. #proste topienie z ustawieniami domyslnymi dane_2&lt;-melt(dane) #w tym przypadku zmienne nienumeryczne sa domyslnie uzyte jako grupujace a zmienne numeryczne sa jaki variable-one sa topione w jedna kolumne. dane_3&lt;-melt(dane, id=c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;), measured=c(&quot;f&quot;, &quot;g&quot;)) melt(dane, id=c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;), measured=c(5,6)) #Tabela przestawna z uzyciem reshape i reshape2 require(reshape) dane&lt;-data.frame(a=rep(c(&#39;a&#39;,&#39;b&#39;), each=5), b=rep(c(&#39;z&#39;, &#39;y&#39;),5 ), c=sample(c(&#39;r&#39;,&#39;w&#39;),10, replace=T) ,d=10:1, e=runif(10), f=runif(10), g=1:10) dane1&lt;-dane[,c(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;)] #ograniczamy aby byla jedna zmienna numetyczna (tutaj &#39;d&#39;). Jak jest wiecej zmiennych trudno jest interpretowac wynik cast(dane1, a~b, mean) cast(dane1, a~b~c, mean) cast(dane1, a~b+c, mean) cast(dane1, a+b~c, mean) cast(dane1, a~b+c, c(mean, sd, max, min)) cast(dane1, a+b~c, c(mean, sd, max, min)) cast(dane1, a+b~c, margins=T ,c(mean, sd, max, min)) #Parametr &#39;margins&#39; powoduje ze sa wyswietlane sumy po kategoriach. require(reshape2) dcast(dane1, a~b, mean) #tutaj mozna podac tylko JEDNA funkcje agregujaca niestety. #Tabela przestawna z uzyciem pakietu plyr. Mozna tu stosowac wieksza ilosc funkcji numerycznych na ktorych sa obliczenia. Jednak jest mniejsza elastycznosc przy konfogurowaniu struktury tabeli przestawnej dane&lt;-data.frame(a=rep(c(&#39;a&#39;,&#39;b&#39;), each=5), b=rep(c(&#39;z&#39;, &#39;y&#39;),5 ), c=sample(c(&#39;r&#39;,&#39;w&#39;),10, replace=T) ,d=10:1, e=runif(10), f=runif(10), g=1:10) ddply(dane, .(a,b), summarise, sredni=mean(d), odch1=sd(d), odch2=sd(e) ) #cos takiego wywali blad. Zmienne w formule daje sie tylko po kropce ddply(dane, (a,b). , summarise, sredni=mean(d), odch1=sd(d), odch2=sd(e) ) ddply(dane, (a,b).(c) , summarise, sredni=mean(d), odch1=sd(d), odch2=sd(e) ) #Przyklad zastosowanie melt do ggplot z&lt;-data.frame(a=c(2,3,2,1,2,3), b=c(3,4,2,3,4,5), id=1:6) dane&lt;-as.data.frame(melt(z, id=&#39;id&#39;)) ggplot() + geom_line(data=dane, aes(x=id, y=value ,col=variable)) 7.1.1 Dodanie margins do tabeli #dodanie margins to tabeli require(reshape) require(reshape2) d&lt;-data.frame(a=c(&#39;a&#39;,&#39;a&#39;,&#39;b&#39;,&#39;b&#39;), b=c(&#39;c&#39;,&#39;d&#39;,&#39;c&#39;,&#39;d&#39;), c=c(1:4), d=c(5:8)) m&lt;-melt(d, id.vars=c(&#39;a&#39;,&#39;b&#39;)) cast(m, a+b~variable, margins=T, fun.aggregate=sum) 7.1.2 Polaczenie funkcji melt i cast #recast polaczenie funkcji melt i cast require(reshape) recast(french_fries, time ~ variable, id.var=1:4) 7.1.3 f:cast a braki danych #cast a braki danych d&lt;-data.frame(a=c(1,1,1,2,2,2,2,NA,NA,NA), b=c(1:10)) require(reshape) require(reshape2) r&lt;-melt(d, id.vars=&#39;a&#39;, measure.var=&#39;b&#39;) t&lt;-cast(r, a~. , fun.aggregate=sum, na.rm=T) #funkcja traktuje NA jako kategorie przy grupowaniu. 7.2 p:dplyr 7.2.1 basic syntax 7.2.2 dplyr and list d2 &lt;- diamonds %&gt;% group_by(cut, color) %&gt;% nest(.key = &#39;dane&#39;) %&gt;% # we will use different models for different groups mutate(model=case_when( color == &#39;E&#39; ~ &#39;x~y+price&#39; , TRUE ~ &#39;z~y+table&#39;)) %&gt;% mutate(wynik_modelu = pmap( .l = list(x=dane, y=model) , .f = function(x,y){summary(lm(data = x, formula = y )) })) %&gt;% mutate( R_square = map_dbl( wynik_modelu , function(x) x$r.squared ) , formula = map( wynik_modelu , function(x) deparse(x$terms) ) %&gt;% unlist ) # filtering based on extracting elements which are nested in a list d2 %&gt;% arrange( map_dbl(wynik_modelu, function(x) x$r.squared ) ) 7.2.3 do diamonds %&gt;% group_by(cut) %&gt;% do(a={lm(data = ., formula=x~y)}) %&gt;% mutate(podsumowanie = list(summary(a)), r_sq= unlist(podsumowanie[&#39;r.squared&#39;])) %&gt;% # filter(r_sq &gt; 0.98) %&gt;% filter(podsumowanie[&#39;r.squared&#39;] &gt; 0.98) .dots=setNames(list(expression_1, expression_2),c(&#39;new_name_1&#39;,&#39;new_name_1&#39;)) z1 &lt;- &#39;cut&#39;; z2 &lt;- &#39;color&#39;; dplyr::rename_(.data = ddd, .dots=setNames(list(z1, z2), c(&#39;ble&#39;, &#39;b&#39; ))) 7.2.4 dynamic arguments dane &lt;- head(diamonds, 100) gr &lt;- c(&#39;cut&#39;, &#39;color&#39;) # dynamic columns dane %&gt;% group_by(!!! lapply(gr, as.name) ) %&gt;% summarise(suma = sum(price)) # dynamic column name cut_1 &lt;- &#39;new_cut&#39; dane %&gt;% group_by(!! cut_1 := tolower(cut)) %&gt;% summarise(suma = sum(price)) # dynamic column and dynamic name gr1 &lt;- c(cut_1 = &#39;cut&#39;, color_1 = &#39;color&#39;) dane %&gt;% group_by(!!!lapply(gr1, as.name) ) %&gt;% summarise(suma = sum(price)) # dynamic calculation var &lt;- &#39;price&#39; dane %&gt;% group_by(cut) %&gt;% summarise(suma = sum(!!!as.name(var))) 7.3 p:purrr 7.4 p:tidyr 7.5 p:rlist Pakiet rlist sluzy do pracy z lisa list. require(rlist) x &lt;- list(p1 = list(type=&quot;A&quot;, score=list(c1=10, c2=8)), p2 = list(type=&quot;B&quot;, score=list(c1=9, c2=9)), p3 = list(type=&quot;B&quot;, score=list(c1=9, c2=7)) ) #list.all-czy dla wszystkich list jest spelniony warunek list.all(x,type==&quot;B&quot;) list.all(x,mean(unlist(score))&gt;=6) #list.any-czy dla jakiejkolwiek listy jest spelniony warunek list.any #list.append-dodanie elementy do listy x &lt;- list(a=1,b=2,c=3) list.append(x,d=4,e=5) list.append(x,d=4,f=c(2,3)) #list.cases-wybierz elementy po wyrazeniu x &lt;- list(p1 = list(type=&quot;A&quot;,score=list(c1=10,c2=8)), p2 = list(type=&quot;B&quot;,score=list(c1=9,c2=9)), p3 = list(type=&quot;B&quot;,score=list(c1=9,c2=7))) list.cases(x,type) list.cases(x,mean(unlist(score))) #list.cbind-zbindowanie po kolumnach elementow x &lt;- list(data.frame(i=1:5 , x=rnorm(5)), data.frame(y=rnorm(5), z=rnorm(5))) list.cbind(x) # list.class ??? # list.clean-wyrzuc elementy nie spelniajace warunku #domyslnie wywala NULL oraz elementy o dlugosci 0 #list.count-ile elementow spelnia warunek # list.do-wykonanie funkcji ktorej argumenty sa cale elementy naszej listy glownej # list.exclude-usuc elementy spelniajace warunek # list.extract ??? (chyba malo ciekawe) # list.filter-filtruj wedlug okreslonego warunku list.find list.findi list.group list.if list.insert list.iter list.join list.load list.map list.maps list.mapv list.match list.merge list.order list.parse list.prepend list.rbind list.remove list.reverse # list.sample-wybierz losowo elementy list.save list.select list.serialize list.skip list.skipWhile # list.sort-sortuj wg. okreslonego warunku x &lt;- list(p1 = list(type=&quot;A&quot;, score=list(c1=10, c2=8)), p2 = list(type=&quot;B&quot;, score=list(c1=9, c2=9)), p3 = list(type=&quot;B&quot;, score=list(c1=9, c2=7))) list.sort(x,type,desc(score$c2)) list.sort(x,min(score$c1,score$c2)) list.stack list.table list.take # list.takeWhile-pobiera elementy az do spelnienia warunku list.ungroup list.unserialize list.update # list.which-numery elementow ktore spelniaja warunek x &lt;- list(p1 = list(type=&quot;A&quot;,score=list(c1=10,c2=8)), p2 = list(type=&quot;B&quot;,score=list(c1=9,c2=9)), p3 = list(type=&quot;B&quot;,score=list(c1=9,c2=7))) list.which(x,type==&quot;B&quot;) list.which(x,min(score$c1,score$c2) &gt;= 8) list.zip 7.6 p:data.table Intruductory notes tlumaczenie z dplyr na data.table: http://stackoverflow.com/questions/21435339/data-table-vs-dplyr-can-one-do-something-well-the-other-cant-or-does-poorly na dysku jest cheat sheet o dynamicznych nazwach w data.table: http://stackoverflow.com/questions/12391950/variably-selecting-assigning-to-fields-in-a-data-table # tworzenie tabel data.table(a=1:2, b=1:10) # vektory nie musza byc rownej dlugosci d &lt;- diamonds[1:50,] %&gt;% as.data.table # filtrowanie d[1:10] d[between(price, 300, 400)] d[color==&#39;E&#39;] # selekcja kolumn d[,.(price, cut)] d[c(TRUE, FALSE)] #elementy nieparzyste d[,1:4, with=FALSE] d[,c(&#39;price&#39;, &#39;cut&#39;), with=FALSE] # obliczenia kolumn d[,.(x, sum(x), sum(y))] # mutowanie/updatowanie kolumn (uwaga: to dziala przez referencje!!!) d[, c(&#39;a&#39;):=(sum(price))] d[, &#39;:=&#39; (a=sum(price), b=sum(x))][] # grupowanie d[,.(sum(price)), by=.(cut, color)] d[,.(sum(price)), by=.(price &gt; 1000)] # dodatkowe skroty d[,.(.N, .GRP), by=cut] # operacje po wszystkich kolumnach d[, lapply(.SD, sum), by=cut, .SDcols=c(&#39;price&#39;,&#39;x&#39;,&#39;y&#39;,&#39;z&#39;)] d[, lapply(.SD, sum), by=cut, .SDcols=5:7] d[, lapply(.SD, sum), by=cut, .SDcols=cut:z] d[,.SD[which.min(price)],by=color][] d[, .SD[1:10] ] DT[,sum(v),by=list(y%%2)] # by expression DT[,.SD[2],by=x] # 2nd row of each group DT[,tail(.SD,2),by=x] # last 2 rows of each group DT[,lapply(.SD,sum),by=x] # apply through columns by group # chaining d[] # ekwiwalent f:do z p:dplyr d1 &lt;- diamonds %&gt;% as.data.table d1[, as.list(summary( x )), by=cut] d1[, as.list(summary( .SD )), by=cut] # joiny df1 &lt;- data.table(a=c(1,3,5,7,9), b=letters[1:5]) df2 &lt;- data.table(c=c(-1,2,6,9,12,NA), b=LETTERS[1:6]) df1[df2, on=c(a=&#39;c&#39;), nomatch=NA] #right_join from df2 to df1 df2[df1, on=c(c=&#39;a&#39;), nomatch=NA] #left join from df1 to df2 df1[df2, on=c(a=&#39;c&#39;), nomatch=0] # inner join # rolling joiny df1 &lt;- data.table(a=c(1,3,5,7,9), b=letters[1:5]) df2 &lt;- data.table(c=c(-1,2,6,9,12,NA), b=LETTERS[1:6]) df2[df1, on=c(c=&#39;a&#39;), roll=&#39;nearest&#39;] # najblizej df2[df1, on=c(c=&#39;a&#39;), roll=Inf] # w dol df2[df1, on=c(c=&#39;a&#39;), roll=-Inf] # w gore #update z innej tabeli df1 &lt;- data.table(a=c(1,3,5,7,9), b=letters[1:5]) df2 &lt;- data.table(c=c(-1,2,6,9,12,NA), b=LETTERS[1:6]) df2[df1, b:=i.b ,on=c(c=&#39;a&#39;), ] # dla wielu kolumn stosuje kontrukcje z &#39;:=&#39; !!! # dynamiczne programowanie - niestety najlepiej jest szukac z &#39;eval&#39;. d[,(a=eval(parse(text=paste0(&#39;sum(price)&#39;))))] # mozna jeszcze dynamicznie selekcjonowac kolumny w tym w .SDcols i nadawa? dynamicznie nazwy przy mutowaniu. 7.6.1 How to work woth keys-duplicates and joining tabels Setting key #USTAWIANIE KLUCZA #Ustawianie klucza po nazwach kolumn DT&lt;-data.table(a=c(1:10), b=letters[1:10], c=c(1,2,4,7,6,2,3,7,5,7)) setkey(DT,a,c) #Ustawianie klucza po numerach kolumn. Zamiast &#39;setkey&#39; uzywam &#39;setkeyv&#39; setkeyv(DT, colnames(DT)[c(1,3)] ) 7.6.2 Duplicates #duplikaty po kluczu DT&lt;-data.table(a=c(1,1,2,2,3,3), b=letters[1:6], c=c(1,1,2,3,3,3)) setkey(DT,a,c) #dostaniemy duplikaty po kluczu duplicated(DT) #duplikaty a braki danych-braki danych sa tutaj traktowane tak samo jak inne dane DT_b_d&lt;-data.table(a=c(NA,NA), b=c(NA,NA)) duplicated(DT_b_d) #usuwanie duplikatow po kluczu unique(DT) #usuwanie duplikatow a braki danych unique(DT_b_d) Joining tables using keys- f:merge f:merge ma nieco inne parametry w przypadku data.frame i data.table. W merge wymieniajac kolumny tabel (np. przy podawaniu kluczy) stosujemy cudzyslowie. #laczenie po kluczach DT1&lt;-data.table(a=1:6, b=letters[1:6], c=1:6) DT2&lt;-data.table(a=c(3,3,4,5,6,7), b=letters[c(1,2,3,9,10,11)], c=c(3,3,4,5,9,10), d=letters[6:1]) #ustawiamy identyczne klucze setkey(DT1, a,c) setkey(DT2, a,c) merge(DT1, DT2) #polaczenie bedzie po kluczach zdefiniowanym wczesniej tzn. kolumnach &#39;a&#39; i &#39;c&#39; #ustawiamy rozne klucze setkey(DT1, a,c) setkey(DT2, a,b) merge(DT1, DT2) #polaczenie bedzie po elementach wspolnych kluczy czyli po kolumnie &#39;a&#39;. #mozna laczyc po z gory okreslonym kluczu merge(DT1, DT2, by=c(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;)) #polaczenie bedzie po ustalonym kluczu #nie mozna loczyc bez zdefiniowania klucza przez &#39;by&#39; jezeli wczesniej nie ustalono kluczy przez setkey (patrz nastepny liting) 7.6.3 Bledy w laczeniu kluczami DT1&lt;-data.table(a=1:6, b=letters[1:6], c=1:6) DT2&lt;-data.table(a=c(3,3,4,5,6,7), b=letters[c(1,2,3,9,10,11)], c=c(3,3,4,5,9,10), d=letters[6:1]) merge(DT1, DT2) Wywali blad. Data.table musi miec okreslony klucz jezeli chcemy aby funkcja sama okreslila kolumny. f:merge a braki danych DT_1&lt;-data.table(a=c(NA, 1,2,3,4,5), b=letters[1:6]) DT_2&lt;-data.table(a=c(2,3,NA,1,4,5), c=letters[7:12]) merge(DT_1, DT_2, by=&#39;a&#39;) Wniosek jest taki ze braki danych NA nie sa brane pod uwag?. f:merge a duplikaty #merge a duplikaty DT1&lt;-data.table(a=c(1,1,2,2), b=c(4,4,5,6)) DT2&lt;-data.table(a=c(1,1,2,2), b=c(4,4,5,6)) merge(DT1, DT2, b=c(&#39;a&#39;,&#39;b&#39;), allow.cartesian=T) Wniosek-duplikaty nie sa usuwane 7.7 p:data.tree 7.7.1 basic methods data(acme) acme$leaves # liscie acme$leafCount acme$level # na jaki poziomie jestem acme$Accounting$level acme$children acme$count acme$totalCount acme$levelName acme$height # jak wysoko jestesmy od najnizszego liscia acme$Accounting$parent acme$path acme$pathString acme$fields acme$fieldsAll acme$Research$`New Product Line`$position acme$Research$`New Product Line`$parent$parent$children #&gt; creation of simple tree B &lt;- Node$new(&#39;B_&#39;) B1 &lt;- B$AddChild(&#39;B1_&#39;) B11 &lt;- B1$AddChild(&#39;B11_&#39;) B12 &lt;- B1$AddChild(&#39;B12_&#39;) B2 &lt;- B$AddChild(&#39;B2_&#39;) B$p &lt;- 10 B1$p &lt;- 20 B11$p &lt;- 30 B12$p &lt;- 40 B2$p &lt;- 50 #&lt; print(B) B$isRoot B$isLeaf; B$B1_$isLeaf; B$B1_$B11_$isLeaf # element &#39;is not Leaf and not Root&#39; is Node (but not Root Node!!!) B$height; B$B1_$height # depth of node B$count ;B$B2_$count # number of element in node B$totalCount # total number of elements (nodes, leaf and root) B$fields # files with data B$fieldsAllll a1 &lt;- B$Get(&#39;p&#39;); a2 &lt;- B$B1_$Get(&#39;p&#39;) a1; a2 sum(a1); sum(a2) 7.7.2 Creation Creation from list # be careful when you build list structure. It must be logical. List in Nodes should be NA if you want to use aggregate function. lista &lt;- list(a=list(l_=100), b=list(l_=200, c=list(l_=400))) e1 &lt;- as.Node(lista, nodeName = &#39;lista&#39;) e2 &lt;- FromListSimple(lista, nodeName = &#39;lista&#39;) print(e1, &#39;l_&#39;) print(e1, &#39;l_&#39;) Creation from data.frame require(ggplot2) d1 &lt;- head(diamonds[, c(&#39;cut&#39;, &#39;color&#39;, &#39;clarity&#39;, &#39;price&#39;)], 100) d2 &lt;- d1 d2$pathString &lt;- paste(&#39;main&#39;, d2$cut, d2$color, d2$clarity, sep=&#39;/&#39;) d3 &lt;- as.Node(d2) d3 print(d3, &#39;price&#39;) #what about categories with NA d4 &lt;- rbind(d1, c(&#39;Ideal&#39;,NA,&#39;VS1&#39;,2500), c(&#39;Ideal&#39;,&#39;D&#39;,&#39;NA&#39;,2500)) dim(d4) d4$pathString &lt;- paste(&#39;main&#39;, d4$cut, d4$color, d4$clarity, sep=&#39;/&#39;) d5 &lt;- as.Node(d4) d5 print(d5, &#39;price&#39;) # NA is not included Normal creation A &lt;- Node$new(&#39;A_&#39;) A1 &lt;- A$AddChild(&#39;A1_&#39;) A11 &lt;- A1$AddChild(&#39;A11_&#39;) A12 &lt;- A1$AddChild(&#39;A12_&#39;) A2 &lt;- A$AddChild(&#39;A2_&#39;) A21 &lt;- A2$AddChild(&#39;A21_&#39;) A22 &lt;- A2$AddChild(&#39;A22_&#39;) A3 &lt;- A$AddChild(&#39;A3_&#39;) A31 &lt;- A3$AddChild(&#39;A31_&#39;) A32 &lt;- A3$AddChild(&#39;A32_&#39;) A4 &lt;- A$AddChild(&#39;A4_&#39;) A41 &lt;- A4$AddChild(&#39;A41_&#39;) A411 &lt;- A41$AddChild(&#39;A411_&#39;) A412 &lt;- A41$AddChild(&#39;A412_&#39;) A42 &lt;- A4$AddChild(&#39;A42_&#39;) A421 &lt;- A42$AddChild(&#39;A421_&#39;) A422 &lt;- A42$AddChild(&#39;A422_&#39;) A11$p &lt;- 30 A12$p &lt;- 40 A21$p &lt;- 10 A22$p &lt;- 10 A31$p &lt;- 10 A32$p &lt;- 25 A411$p &lt;- 10 A412$p &lt;- 10 A421$p &lt;- 10 A422$p &lt;- 10 # number in node A42$p &lt;- 40 A1$p &lt;- 40 A$p &lt;- 45 print(A, &#39;p&#39;) #&lt; 7.7.3 Filtering and prunning #&gt; filtrowanie - sprawdza wszystkie elementy w przeciwienstwie do przycinania A$Get(&#39;p&#39;, filterFun = function(x) sum(x$p, na.rm=TRUE)&gt;20, traversal = &#39;pre-order&#39;) # sprawdza warunek z gory w dol??? A$Get(&#39;p&#39;, filterFun = function(x) sum(x$p, na.rm=TRUE)&gt;20, traversal = &#39;post-order&#39;) # sprawdza warunek z dolu do gory?? A$Get(&#39;p&#39;, filterFun = function(x) sum(x$p, na.rm=TRUE)&gt;20 || !x$isLeaf, traversal = &#39;pre-order&#39;) # zwroci tez elementy ktore nie sa liscmi (nawet jezeli maja przpisane NA) A$Get(&#39;p&#39;, filterFun = function(x) sum(x$p, na.rm=TRUE)&gt;20 || !x$isLeaf, traversal = &#39;post-order&#39;) #&lt; #&gt; przycinanie - np. idziemy w dol - w momencie gdy warunek nie jest spelniony nie schodzimy dalej w dol - przycinamy A$Get(&#39;p&#39;, pruneFun = function(x) sum(x$p, na.rm=TRUE)&gt;20, traversal = &#39;pre-order&#39;) A$Get(&#39;p&#39;, pruneFun = function(x) sum(x$p, na.rm=TRUE)&gt;20, traversal = &#39;post-order&#39;) # zeby cos zostalo chyba musimy sie wspiac z warunkiem az do pnia A$Get(&#39;p&#39;, pruneFun = function(x) sum(x$p, na.rm=TRUE)&gt;20 || !x$isLeaf, traversal = &#39;pre-order&#39;) A$Get(&#39;p&#39;, pruneFun = function(x) sum(x$p, na.rm=TRUE)&gt;20 || !x$isLeaf, traversal = &#39;post-order&#39;) #&lt; 7.7.4 Recursion A &lt;- Node$new(&#39;A_&#39;) A1 &lt;- A$AddChild(&#39;A1_&#39;) A11 &lt;- A1$AddChild(&#39;A11_&#39;) A12 &lt;- A1$AddChild(&#39;A12_&#39;) A2 &lt;- A$AddChild(&#39;A2_&#39;) A21 &lt;- A2$AddChild(&#39;A21_&#39;) A22 &lt;- A2$AddChild(&#39;A22_&#39;) A3 &lt;- A$AddChild(&#39;A3_&#39;) A31 &lt;- A3$AddChild(&#39;A31_&#39;) A32 &lt;- A3$AddChild(&#39;A32_&#39;) A4 &lt;- A$AddChild(&#39;A4_&#39;) A41 &lt;- A4$AddChild(&#39;A41_&#39;) A411 &lt;- A41$AddChild(&#39;A411_&#39;) A412 &lt;- A41$AddChild(&#39;A412_&#39;) A42 &lt;- A4$AddChild(&#39;A42_&#39;) A421 &lt;- A42$AddChild(&#39;A421_&#39;) A422 &lt;- A42$AddChild(&#39;A422_&#39;) A11$p &lt;- 30 A12$p &lt;- 40 A21$p &lt;- 10 A22$p &lt;- 10 A31$p &lt;- 10 A32$p &lt;- 25 A411$p &lt;- 10 A412$p &lt;- 10 A421$p &lt;- 10 A422$p &lt;- 10 A$p &lt;- 5 #1 Cost &lt;- function(node) { result &lt;- node$p if(length(result) == 0) result &lt;- sum(sapply(node$children, Cost)) return (result) } print(A, &quot;p&quot;, cost = Cost) #2 Cost &lt;- function(node) { result &lt;- node$p if( isNotLeaf(node) ) result &lt;- sum(sapply(node$children, Cost)) return (result) } print(A, &quot;p&quot;, cost = Cost) #3 Cost &lt;- function(node) { result &lt;- node$p if( isNotLeaf(node) ) result &lt;- sum(node$Get(&#39;p&#39;), na.rm=TRUE) return (result) } print(A, &quot;p&quot;, cost = Cost) #4 Cost &lt;- function(node) { result &lt;- node$p if( isNotLeaf(node) ) result &lt;- sum(node$Get(&#39;p&#39;, filterFun=function(x) isLeaf(x) ), na.rm=TRUE) return (result) } print(A, &quot;p&quot;, cost = Cost) A_dt_1 &lt;- ToDataFrameTable(A, &#39;name&#39;, &#39;pathString&#39;, &#39;p&#39;, &#39;level&#39;) A_dt_2 &lt;- ToDataFrameTree(A, &quot;level&quot;, &quot;p&quot;) A_dt_3 &lt;- ToDataFrameNetwork(A, &quot;level&quot;, &quot;p&quot;) A_dane &lt;- print(A, &#39;name&#39;, &#39;p&#39;) require(DiagrammeR) nodes &lt;- create_nodes(nodes = A_dane$name, label=paste(A_dane$name, ifelse(is.na(A_dane$p),&#39;&#39;,A_dane$p), sep=&#39;\\n&#39;) ) edges &lt;- create_edges(from= A_dt_3$from, to= A_dt_3$to) graph &lt;- create_graph(nodes_df = nodes, edges_df = edges) render_graph(graph) 7.7.5 Plotting A &lt;- Node$new(&#39;A_&#39;) A1 &lt;- A$AddChild(&#39;A1_&#39;) A11 &lt;- A1$AddChild(&#39;A11_&#39;) A12 &lt;- A1$AddChild(&#39;A12_&#39;) A2 &lt;- A$AddChild(&#39;A2_&#39;) # dendrogram plot(as.dendrogram(A)) # p:igraph require(igraph) plot(as.igraph.Node(A, direction=&#39;climb&#39;, directed=TRUE)) # p:networkD3 require(networkD3) net &lt;- ToDataFrameNetwork(A, &#39;name&#39;) simpleNetwork(net) 7.8 apply family How to substitute new values to column in data.frame d &lt;- data.frame(a=c(1,2,Inf), b=c(3,Inf,4)) d sapply(d, function(x) is.infinite(x) ) sapply(d, function(x) replace(x,is.infinite(x),NA)) # PROBLEM mapply WEKTOR - WEKTOR mapply(function(x,y){ x*y },1:10,1:10) LISTA-LISTA #listy z ramkami danych #dziala ale trzeba wylaczyc simplify mapply(function(x,y){ rbind(x,y) }, list(w=data.frame(a=1:5, b=6:10), z=data.frame(a=1:5, b=6:10) ) , list(w=data.frame(a=1:5, b=6:10), z=data.frame(a=1:5, b=6:10) ) , SIMPLIFY=FALSE) MACIERZE - COS INNEGO #DUPA mapply(function(x,y){ x*y }, as.matrix(diamonds[,c(&#39;price&#39;,&#39;x&#39;,&#39;y&#39;)]) , list(2,5,8) ) RAMKI DANYCH - RAMKA DANYCH require(ggplot2) mapply(function(x,y){ x*y }, diamonds[1:4,c(&#39;price&#39;,&#39;x&#39;)] , data.frame(a=c(2,2,2,2), b=c(9,9,9,9)) ) PROGRAMOWANIE DYNAMICZNE Wykonuje rozne funkcje po roznych kolumnach ramki danych mapply(function(x,y){ eval(parse(text=paste(y,&#39;x)&#39;,sep=&#39;&#39;))) }, diamonds[,c(&#39;price&#39;,&#39;x&#39;,&#39;y&#39;)], list(&#39;sum(&#39;,&#39;mean(&#39;,&#39;sd(&#39;) ) #nie moze byc wektor !!! #KONIEC MAPPLY ARGUMENTY mapply(mean, data.frame(diamonds[1:4,c(&#39;price&#39;,&#39;x&#39;,&#39;y&#39;)],w=c(1,2,NA,NA)), MoreArgs = list(na.rm=T, trim=.2)) TRZY ARGUMENTY mapply(function(x,y,z){ x*y*z },1:10,1:10,1:10) 7.8.1 f:mlapply(ENmisc) require(ENmisc) mlapply(list(list(1,2,3),list(4,5,6),list(6,7,8)),function(x,y,z)x2+y2+z) 7.8.2 Agregacja #suma po kilku roznych zmiennych stats::aggregate(price~cut+color, data=diamonds, FUN=sum, simplify=TRUE) apply(,,) #dla macierzy. Trzeba podac argument okreslajacy czy funkcja ma byc wykonywana po wierszach czy kolumnach. Apply mozna tez stosowac do macierzy wielowymiarowych czyli array lapply #dla ramek danych i list. Zwraca liste sapply #dla ramek danych i list. Zwraca wektor require(ggplot2) sapply(USArrests, class) #jakiej typu dane sa w kolejnych kolumnach ramki danych zawieracjacej dane USArrests. mapply #argumentem jest funkcja ktora jest wykonywana po kolejnych elementach zadanych kilku struktur danych (np. sumowanie kolejnych odpowiadajacych sobie elementow macierzy) z1&lt;-matrix(c(1,2,3,4), ncol=2) z2&lt;-matrix(c(1,2,3,4), ncol=2) mapply(FUN=sum, z1, z2, z1) mapply(rep, 1:4, 4:1) #tapply #rozbcie jednego wektora ze wzgledu na drugi. To samo mozna uzyskac split-em #UWaga!!! w przypadku wszystkich powyzszych funkcji jako kolejne argumenty mozna podawac argumenty dla funkcj podanych przy FUN. 7.9 p:muir Package makes it easy to work with data.frames as if they were trees. Examples require(muir) # data without NA data &lt;- diamonds[1:1000,] # data with NA data_na &lt;- bind_rows( data , setNames( as.data.frame(t(rep(NA, ncol(data)) )) , names(data)) ) table(data$cut) # display no more than 4 most common categories muir::muir( data, node.levels = c(&#39;cut:*&#39;, &#39;color:*&#39;) , node.limit = 4 , tree.height = &#39;1200px&#39;) # display no more than 3 categories (other categories give to category &#39;other&#39;) muir::muir( data , node.levels = &#39;cut:3+&#39; , tree.height = &#39;600px&#39;) # display no more than 3 categories (without other categories) muir::muir( data , node.levels = &#39;cut:3&#39; , tree.height = &#39;600px&#39;) # muir::muir( data , node.levels = &#39;cut:3&#39; , label.vals = c(&#39;min(price, na.rm=TRUE):Min Weight&#39;) , tree.height = &#39;600px&#39;) # provide custom filter criteria and custom node titles in \\code{label.vals} # (criteria could also be read in from a csv file as a data.frame) criteria &lt;- data.frame( col = c(&quot;cyl&quot;, &quot;cyl&quot;, &quot;carb&quot;) ,oper = c(&quot;&lt;&quot;, &quot;&gt;=&quot;, &quot;==&quot;) # or ,val = c(500, 900, 1000) ,title = c(&quot;Less Than 4 Cylinders&quot;, &quot;4 or More Cylinders&quot;, &quot;2 Carburetors&quot;)) criteria_price_1 &lt;- data.frame( col = c(&quot;price&quot;, &quot;price&quot;, &quot;price&quot;,&quot;price&quot;) , oper = c(&quot;&lt;&quot;, &quot;&gt;=&quot;, &quot;==&quot;, &quot;is.na&quot;) # or , val = c(500, 900, 1000, NA) , title = c(&quot;Less Than 500&quot;, &quot;900 or More&quot;, &quot;1000&quot;, &quot;no data&quot;)) muir::muir( data = data_na , node.levels = c(&#39;price&#39;) , level.criteria = criteria_price_1 , tree.height = &#39;600px&#39;) 7.10 fuzzyjoin difference_join library(dplyr) head(iris) # sepal_lengths &lt;- data_frame(Sepal.Length = c(5, 6, 7), Type = 1:3) df_1 &lt;- data.frame( a = letters[1:12] ,b = 1:12 ,c= 1:12 ) df_2 &lt;- data.frame( A = letters[1:12] ,B = c(1, 2.2 ,9.9 ,20, 50, 21:27) ,C = c(1.05, 2.1, 9.9, 32:40) ) fuzzyjoin::difference_inner_join( x = df_1 , y = df_2 , by = c( &#39;b&#39;=&#39;B&#39; , &#39;c&#39;=&#39;C&#39;) , max_dist = c(.3, .2) ) df_1 &lt;- data.frame( a = letters[1:12] ,b = 1:12 ,c= 1:12 ) df_2 &lt;- data.frame( A = letters[1:12] ,B = c(1, 2.2 ,9.9 ,20, 50, 21:27) ,C = c(1.05, 2.1, 9.9, 32:40) ) fuzzyjoin::distance_inner_join( x = df_1 , y = df_2 , by = c( &#39;b&#39;=&#39;B&#39; , &#39;c&#39;=&#39;C&#39;) , max_dist = 1 , method = &#39;euclidean&#39; ) interval_inner_join Joins tables based on overlapping intervals: for example, joining the row (1, 4) with (3, 6), but not with (5, 10). This operation is sped up using interval trees as implemented in the IRanges package require(IRanges) # pacakge from biconductor x1 &lt;- data.frame(id1 = 1:3, start = c(1, 5, 10), end = c(3, 7, 15)) x2 &lt;- data.frame(id2 = 1:3, start = c(2, 4, 16), end = c(4, 8, 20)) # tylko dwie pierwsze pary przedzialow nachodza na siebie (pierwsza para 1-5 i 2-4 a druga 5-7 i 4-8) fuzzyjoin::interval_inner_join(x1, x2) "],
["data-other-packages.html", "Chapter 8 DATA OTHER PACKAGES 8.1 sqldf", " Chapter 8 DATA OTHER PACKAGES 8.1 sqldf Be careful with syntax. If syntax os to complex (you use advanced syntax), function will automatically try to connect with database. # In this example I use f:top require(diamonds) sqldf::sqldf(&#39;select top 10 * from diamonds&#39; , method=&#39;auto&#39;) "],
["data-processing-by-problems.html", "Chapter 9 DATA PROCESSING BY PROBLEMS 9.1 Frequency tables 9.2 Recoding 9.3 Margins 9.4 Transformations", " Chapter 9 DATA PROCESSING BY PROBLEMS 9.1 Frequency tables #Pakiet prettyR require(prettyR) test.df&lt;-data.frame(sex=sample(c(&quot;MALE&quot;,&quot;FEMALE&quot;),1000,TRUE),suburb=sample(1:4,1000,TRUE),social.type=sample(LETTERS[1:4],1000,TRUE)) xtab(sex~suburb+social.type,test.df,chisq=TRUE) xtab(sex~suburb,test.df,chisq=TRUE) #wrzucenie wynikow HTML-a (do TeX-a sie nie da) xtab(secondbit~firstbit,testxtab,html=TRUE,chisq=TRUE,phi=TRUE) #Funkcja table require(ggplot2) #aby miec dostep do diamonds data(diamonds) z&lt;-table(diamonds[,c(2,3,4)]) z round(prop.table(z),4) #Funkcja ftable (flat table) Titanic #Dane o takiej strukturze jak ma zbior Titanic mozna wygenerowac np. funkcja table ftable(Titanic, row.vars = 1:3) #row.vars okresla ktore zmienne sa brane do wierewszy ftable(Titanic, row.vars = 1:2) ftable(Titanic, row.vars = 2:3) #transpozycja wzgledem wyniku z wykonania wiersza powyzej: ftable(Titanic, col.vars = 2:3) #Pakiet gmodels, funkcja CrossTable-bardzo dobra funkcja-niestety mozna dac tylko 2 zmienne. require(gmodels) require(ggplot2) #aby miec dostep do diamonds data(diamonds) CrossTable(diamonds$cut, diamonds$color, expected=T, dnn=c(&#39;cut&#39;, &#39;color&#39;), format=&#39;SPSS&#39;) \\#dnn okresla nazwy dla zmiennych CrossTable( t(as.matrix(diamonds[,c(&#39;cut&#39;,&#39;clarity&#39;)])), diamonds$color, expected=T, dnn=c(&#39;cut&#39;, &#39;color&#39;)) \\#dnn okresla nazwy dla zmiennych #Pakiet Hmisc funkcja summary.formula. W przeciwienstwie do CrossTable mozna uzyc wiecej niz 2 zmienne. Jednak podaje duzo skromniejsze wyniki. library(Hmisc) dd &lt;- data.frame(Q1=sample(1:3, 20, replace=T), Q2=sample(1:3, 20, replace=T), Q3=sample(1:3, 20, replace=T)) \\#fake data summary(~Q1+Q2+Q3, data=dd, fun=table) summary(Q1~Q2+Q3, data=dd, fun=mean) 9.2 Recoding # create 2 age categories mydata$agecat &lt;- ifelse(mydata$age &gt; 70, c(&quot;older&quot;), c(&quot;younger&quot;)) # another example: create 3 age categories attach(mydata) mydata$agecat[age &gt; 75] &lt;- &quot;Elder&quot; mydata$agecat[age &gt; 45 &amp; age &lt;= 75] &lt;- &quot;Middle Aged&quot; mydata$agecat[age &lt;= 45] &lt;- &quot;Young&quot; detach(mydata) #Uwaga. Powyzszego sposobu nie stosujemy do przeksztalcania zmiennych ciaglych jezeli nowa zmienna jest nadpisywana na stara. Prowadzi to do blednych wynikow!!!. require(car) #uwaga. Uzywam funkcji &#39;recode&#39; z pakietu &#39;car&#39;. Ale on tez w pakiecie &#39;epicalc&#39;, dlatego musze wskazac o ktory pakie chodzi #PRZYKLADY: car::recode(diamonds[,&#39;clarity&#39;], &quot; &#39;SI2&#39;=&#39;z&#39; &quot; ) car::recode(diamonds[,&#39;clarity&#39;], &quot; &#39;SI2&#39;=1; &#39;VS2&#39;=2; else=NA &quot; ) #Niestety nie wiem czy &#39;recode&#39; dziala na warunek nierownosci f:cut i f:cut2 #podzial na 4 rowne przedzialy x=c(1,2,3,4,5,6) cut( x, #vektor typu liczbowego breaks=4) cut( x, #vektor typu liczbowego breaks=c(0,2,4,7), #przedzialy podawane jako wektor numeryczny. Punkty breakes musza obejmowac caly zakres bo inaczej bedziemy dostawac wartosc NA (wartosc zmiennej poza zakresem zdefiniowanych przedzialow) #labels = NULL, #nazwy przedzialow podawnane sa w formie wektora labels=c(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;), include.lowest = FALSE, right = FALSE, #czy przedzial prawostronnie domkniety. Dla False bedzie lewostronnie domkniety #diag.lab=3 #jezli nie ma podanych labels to przy wyswietlaniu przedzialow ile mniejc po przecinku podawac dla liczb wyznaczjacych krance przedzialow ) #podzial na przedzialy o rownej dlugosci i roznej liczebnosci require(Hmisc) cut2() #uwaga. &#39;cut2&#39; domyslnie ma przedzialy lewostronnie domkniete w przeciwienstwie do &#39;cut&#39; # UZYCIE FUNKCJI &#39;cut 2&#39;(pakiet Hmisc) set.seed(1) x &lt;- runif(1000, 0, 100) z &lt;- cut2(x, c(10,20,30)) table(z) table(cut2(x, g=10)) # quantile groups table(cut2(x, m=50)) # group x into intevals with at least 50 obs. Trzeba zrobi? w?asne udoskonalenie funkcji cut2. Jezeli jest kategoria ktorej liczebno?? przekracza liczebno?? przedzia?u to uzyskany podzia? na rowne liczebnosci bedzie zly. f:revalue(plyr) #revalue dziala na stringi i factor x &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) revalue(x, c(a = &quot;A&quot;, c = &quot;C&quot;)) revalue(x, c(&quot;a&quot; = &quot;A&quot;, &quot;c&quot; = &quot;C&quot;)) Funkcja mapvlaues(plyr) 9.3 Margins #addmargins(stats) m&lt;-matrix(1:20, c(4,5)) addmargins(A=m, #dane typu &#39;matrix&#39; margin=2, #wektor okreslajacy po jakich wymiarach (domyslnie po wszystkich) FUN = list(Suma=sum), #lista wyliczanych funckji wraz z nazwami nowych kolumn quiet = TRUE) #???nie wiem co jest??? #dodanie kolumny z suma w tabeli (dwie pierwsze kolumny sa kolumnami grupujacymi typu &#39;chaacter&#39;) require(ggplot2) data(diamonds) dane&lt;-diamonds[1:10, c(&#39;cut&#39;,&#39;color&#39;, &#39;carat&#39;, &#39;x&#39;)] dane$suma&lt;-addmargins(A=as.matrix(dane[,c(3,4)]), margin=2 , FUN = list(Suma=sum), quiet = TRUE) [,3] dane 9.4 Transformations 9.4.1 f:transform require(ggplot) z&lt;-diamonds names(z) z&lt;-transform(z, logprice=log(price)) #dodatnie zmiennej bedacej logarytmem &#39;price&#39; z&lt;-transform(z, price=log(price)) #nadpisanie zmiennej &#39;price&#39; jej logarytmem z&lt;-transform(dane_sql, nowa=kwota/dochody_razem) 9.4.2 f:split #rozbicie zmiennej &#39;price&#39; po kategoriach zmiannej &#39;cut&#39; z&lt;-diamonds c1&lt;-split(z[,&#39;price&#39;], z[,&#39;cut&#39;]) #rozbicie calej tabeli na oddzielne tabele ze wzgledu na zmienna cut c2&lt;-split(z, z[,&#39;cut&#39;]) 9.4.3 Przeksztalcanie kilku kolumn na raz #przeksztalcanie kilku kolumn jednoczesnie z&lt;-data.frame(a=1:10, b=1:10, c=1:10) sapply(z, function(x) x/5 ) z[,c(1,3)]&lt;-sapply(z[,c(1,3)], function(x) x/5 ) 9.4.4 Rekodowanie czynnika na zmienna zero-jedynkowa #make_dummy require(Kmisc) z&lt;-factor(rep(c(&#39;a&#39;,&#39;b&#39;),10)) z1&lt;-make_dummy(z) class(z1) #otrzymujemy liste. Tyle elementow ile jest katgorii z1 9.4.5 f:split #rozbicie zmiennej &#39;price&#39; po kategoriach zmiannej &#39;cut&#39; z&lt;-diamonds c1&lt;-split(z[,&#39;price&#39;], z[,&#39;cut&#39;]) #rozbicie calej tabeli na oddzielne tabele ze wzgledu na zmienna cut c2&lt;-split(z, z[,&#39;cut&#39;]) 9.4.6 Przeksztalcanie kilku kolumn na raz #przeksztalcanie kilku kolumn jednoczesnie z&lt;-data.frame(a=1:10, b=1:10, c=1:10) sapply(z, function(x) x/5 ) z[,c(1,3)]&lt;-sapply(z[,c(1,3)], function(x) x/5 ) 9.4.7 Rekodowanie czynnika na zmienna zero-jedynkowa #make_dummy require(Kmisc) z&lt;-factor(rep(c(&#39;a&#39;,&#39;b&#39;),10)) z1&lt;-make_dummy(z) class(z1) #otrzymujemy liste. Tyle elementow ile jest katgorii z1 "],
["data-processing-tricks.html", "Chapter 10 DATA PROCESSING TRICKS 10.1 Remove duplicated columns 10.2 get name of elements in nested list 10.3 moving columns 10.4 Usuwanie wartosci nieskonczonych z ramek danych 10.5 Dynamiczne wygenerowanie pustej ramki danych 10.6 Dynamiczne wygenerowanie listy pustych data.frame 10.7 Selecting columns by condition 10.8 DUPLIKATY z orginalami 10.9 DYNAMICZNE FILTROWANIE PO KOLUMNACH 10.10 PRZETAPIANIE CHARACTER 10.11 Odwolywanie sie do nazw w sapply 10.12 converting lists into vectors in data.frames—- 10.13 SUMOWANIE POPRZEDNICH WARTOSCI 10.14 USUWANIE Z WEKTORA WARTOSCI ODSTAJACYCH PRZY POMOCY BOXPLOT (WARTOSCI ODSTAJACE). Jak to uogólnic na ramke danych? 10.15 patent na sortowanie stringow z cyframi 10.16 wstawienie kolumny miedzy kolumny ramki danych 10.17 dodawanie tego samego elementu do wszystkich rekordow w grupie (problem powstal przy liczeniu WoE) 10.18 Dividing data.frames by vectors 10.19 zagniezdzenie sapply w lappy 10.20 DZIALANIE NA WIERSZACH WEWNATRZ GRUP (jedna z lepszych wersji) 10.21 RELACJA GRUPY W PODGGRUPA SUMY WSZYSTKICH PODGRUP 10.22 dodawanie komentrzy osobno do kazdej kolumny w ramce danych 10.23 f:rep vs f:replicate 10.24 Closest value 10.25 WYSZUKIWANIE ZAKRESU DAT TYGODNIA Z KTOREGO SA DATY 10.26 NA problems in mapping and joining 10.27 Functions by packages 10.28 f:do.call 10.29 f:aggregate 10.30 f:by 10.31 f:outer 10.32 f:summary 10.33 Misselenious", " Chapter 10 DATA PROCESSING TRICKS 10.1 Remove duplicated columns tabela &lt;- dplyr::frame_data( ~a, ~b, ~c, 1,2,1, 2,3,2 ) require(digest) tabela[!duplicated(lapply(tabela, digest))] 10.2 get name of elements in nested list In this case I don’t treat data.frame as list. Hierarchical view: l &lt;- list(a=10, b=list(c=20, d=data.frame(z=10,x=30))) f &lt;- function(x, parent=&quot;&quot;){ if(!(is.list(x) &amp; !is.data.frame(x)) ) return(parent) mapply(f, x, paste(parent,names(x),sep=&quot;$&quot;), SIMPLIFY=FALSE) } f(l) Just names: l &lt;- list(a=10, b=list(c=20, d=data.frame(z=10,x=30))) f &lt;- function(x, parent=&quot;&quot;){ if(!is.list(x)) return(parent) unlist(mapply(f, x, paste(parent,names(x),sep=&quot;$&quot;), SIMPLIFY=FALSE)) } f(l) 10.3 moving columns # move to the end require(dplyr) require(ggplot2) dplyr::select_(diamonds, interp(quote(-x), x=as.name(&#39;cut&#39;)) ,.dots=list(quote(everything()))) %&gt;% head #dynamic argumenst dplyr::select_(diamonds, -cut ,everything()) %&gt;% head #static arguments # move to front dplyr::select_(diamonds, cut ,everything()) %&gt;% head 10.4 Usuwanie wartosci nieskonczonych z ramek danych This doesn’t work: x[is.infinity(x)] &lt;-NaN You have to use e.g.: do.call(data.frame, lapply(x, function(x) replace(x, is.infinity(x), NaN ))) 10.5 Dynamiczne wygenerowanie pustej ramki danych as.data.frame(setNames(replicate(5, numeric(0), simplify = FALSE), letters[1:5])) 10.6 Dynamiczne wygenerowanie listy pustych data.frame Elementy listy beda posiadaly nazwy setNames(lapply(1:5, function(x) data.frame()), letters[1:5]) 10.7 Selecting columns by condition require(ggplot2) d1 &lt;- diamonds[,sapply(diamonds, is.numeric)] d1[,sapply(d1, function(x) sum(x)&gt;1000000)] Creating variables using the elements in a list # First method l &lt;- list(a=1, b=2) for(i in 1:length(l)){ assign(x = names(l)[i] , value = l[[i]]) } rm(a,b) # Second method w &lt;- list(a=1, b=2) list2env(x = w, envir = .GlobalEnv) 10.8 DUPLIKATY z orginalami a&lt;-data.frame(a=c(&#39;a&#39;,&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;), b=c(&#39;w&#39;,&#39;w&#39;,&#39;r&#39;,&#39;c&#39;,&#39;c&#39;,&#39;r&#39;,&#39;t&#39;)) a[ duplicated(a) | duplicated(a[nrow(a):1,])[nrow(a):1],] 10.9 DYNAMICZNE FILTROWANIE PO KOLUMNACH Problem: Tabla musi być przefiltrowana po wszystkie kolumnach o dynamicznie wygenerowanych. Zakładam że warunek na każdą kolumnę jest taki sam require(dplyr) d &lt;- data.frame(a=1:10, b=1:10, c=c(8,9,1:8)) c&lt;-c(&#39;b&#39;,&#39;c&#39;) for(i in 1:length(c)){ # i=1 d &lt;- d %&gt;% filter_(.dots = interp(~ c &lt; 8, c=as.name(c[i]) ) ) } d 10.10 PRZETAPIANIE CHARACTER require(ggplot2) require(reshape2) require(dplyr) d &lt;- data.frame( cut=rep(c(&#39;a&#39;,&#39;b&#39;), each=5 ), color=c(1:10), clarity=letters[1:10] ) recast(d, formula=cut~color, id.var=c(&#39;cut&#39;,&#39;color&#39;), measure.var=c(&#39;clarity&#39;)) 10.11 Odwolywanie sie do nazw w sapply Stosujemy taki trick (przyklad wybierania kolumn typu ‘numeric’ lub o nazwie ‘cut’) diamonds[,unlist(lapply(seq_along(diamonds),function(x,d,n) {is.numeric(d[[x]]) | n[[x]]==&#39;cut&#39;} ,d=diamonds, n=names(diamonds)))] 10.12 converting lists into vectors in data.frames—- require(ggplot2) require(abind) require(dplyr) require(plyr) require(rlist) wynik &lt;- diamonds %&gt;% group_by(cut) %&gt;% do(a={sum(.$price)}) sapply(wynik, class) class(wynik) wynik wynik$a ddd &lt;- do.call(&#39;data.frame&#39;, sapply(as.data.frame(wynik), unlist, simplify = FALSE 10.13 SUMOWANIE POPRZEDNICH WARTOSCI Most advanced version #Assumptions #I will do operation for each group (a-groupuing variable) #fof each grup i have &quot;ordered variable&quot; b and &quot;measure variable&quot; &#39;c&#39;. z&lt;-data.frame(a=rep(c(1,2),each=5),b=c(1,1,2,2,2,3,4,4,4,5), c=1:10) require(dplyr) z &lt;- z %&gt;% group_by(a) %&gt;% mutate(lp=1:n(), rank=dense_rank(b)) %&gt;% ungroup() z1&lt;-z names(z1) &lt;- paste(names(z1),&#39;1&#39;, sep=&#39;&#39;) z1 &lt;-z %&gt;% group_by(a,lp) %&gt;% mutate( sumka=sum( z1[ (z1$rank1==rank &amp; z1$a1==a) | (z1$rank1==rank+1 &amp; z1$a1==a) | (z1$rank1==rank+2 &amp; z1$a1==a) ,&#39;c1&#39;], na.rm=TRUE) ) 10.14 USUWANIE Z WEKTORA WARTOSCI ODSTAJACYCH PRZY POMOCY BOXPLOT (WARTOSCI ODSTAJACE). Jak to uogólnic na ramke danych? x[!x %in% boxplot.stats(x)$out] 10.15 patent na sortowanie stringow z cyframi z001 z002 a nie z1 z2 10.16 wstawienie kolumny miedzy kolumny ramki danych as.data.frame(append(tabela, list(a=...), after=1 )) 10.17 dodawanie tego samego elementu do wszystkich rekordow w grupie (problem powstal przy liczeniu WoE) require(ggplot2) require(dplyr) d &lt;- diamonds d1 &lt;- d %&gt;% group_by(cut,color) %&gt;% summarise(s=sum(price)) d2 &lt;- d1[,c(&#39;s&#39;,&#39;color&#39;,&#39;cut&#39;)] %&gt;% filter(color==&#39;J&#39;) %&gt;% do(left_join(d1,.,by=c(&#39;cut&#39;))) d2 10.18 Dividing data.frames by vectors #dzielenie ramki i macierzy przez wektor z&lt;-data.frame(a=rep(5,5), b=rep(2,5)) w&lt;-c(5,2) z/w # #Jezeli chcemy podzielic odpowiadajace sobie pozycje kazdego wiersza przez pozycje z wektora niestety macirz/ramek musimy transponowac. Niestety ramke bedziemy musli przeksztalcic na macierz i utracimy informacje o nazwach zmiennych z1&lt;-t(z) class(z1) #dostalismy typ matrix po transpozycji z1&lt;-z1/w z1&lt;-t(z1) names(z1)&lt;-names(z) 10.19 zagniezdzenie sapply w lappy require(ggplot2) data(diamonds) a=diamonds[1:1000,c(&#39;carat&#39;,&#39;price&#39;)] b=diamonds[1:1000,c(&#39;x&#39;,&#39;y&#39;)] a[1:10,]&lt;-NA l&lt;-list(a=a, b=b) lapply(l, sapply, mean, na.rm=T) lapply(l, sapply, quantile, probs=c(.2,.5,.7) ,na.rm=T) 10.20 DZIALANIE NA WIERSZACH WEWNATRZ GRUP (jedna z lepszych wersji) # mozena tez z uzyciem abind require(plyr) require(dplyr) require(ggplot2) w &lt;- diamonds %&gt;% group_by(cut, color) %&gt;% dplyr::summarise(., sum=sum(price)) w1 &lt;- w %&gt;% dplyr::do(sum={.[.[,&#39;color&#39;]==&#39;I&#39;,&#39;sum&#39;] / .[.[,&#39;color&#39;]==&#39;J&#39;,&#39;sum&#39;]}) %&gt;% as.data.frame(.$sum) %&gt;% lapply(unlist) %&gt;% as.data.frame rbind.fill(w, cbind(w1, color=&#39;nowy&#39;)) %&gt;% arrange(cut, color) 10.21 RELACJA GRUPY W PODGGRUPA SUMY WSZYSTKICH PODGRUP require(diamonds) require(dplyr) require(data.table) d &lt;- as.data.table(diamonds) d[, pd:=sample(0:1,.N,TRUE)] %&gt;% group_by(cut, pd) %&gt;% dplyr::summarise_(.dots=setNames(list(~sum(price)), c(&#39;suma&#39;))) 10.22 dodawanie komentrzy osobno do kazdej kolumny w ramce danych require(Hmisc) d&lt;-data.frame(a=1, b=2) label(d,FALSE)&lt;-c(&#39;aaaa&#39;,&#39;bbbbb&#39;) 10.23 f:rep vs f:replicate rep(rnorm(1), 10) replicate(10, expr = rnorm(1)) require(microbenchmark) microbenchmark(rep(rnorm(1), 10), replicate(10, expr = rnorm(1))) 10.24 Closest value 10.24.1 ogolnie najblizsze c1&lt;-c(1,2,5,6,7,10) c2&lt;-c(2,4,5,6,6,10,1,1,12) # I will find closest value among &#39;c1&#39; for values in &#39;c2&#39; c1[sapply(c2, function(x) which.min(abs(c1-x))[1])] #[1] - first finded 10.24.2 najwyzej najblizsze #code below wasn&#39;t checked c1&lt;-c(1,3,5,6,7,10) c2&lt;-c(2,4,5,6,6,10,1,1,12) c1[sapply(c2, function(x) which.min(ifelse(c1-x&lt;0,NA,c1-x ))[1])] 10.24.3 najnizej-sprawdziczy czy dobrze dziala c1&lt;-c(1,3,5,6,7,10) c2&lt;-c(2,4,5,6,6,10,1,1,12) #code below wasn&#39;t checked c1[sapply(c2, function(x) which.max(ifelse(c1-x&gt;0,NA,c1-x ))[1])] 10.25 WYSZUKIWANIE ZAKRESU DAT TYGODNIA Z KTOREGO SA DATY require(plyr) require(lubridate) daty&lt;-as.Date(c(&#39;2013-01-03&#39;,&#39;2012-07-28&#39;,&#39;2014-09-12&#39;)) daty_komplet&lt;-data.frame(daty, daty_week=week(daty)) min&lt;-min(daty) max&lt;-max(daty) sekwencja&lt;-seq(min,max, by=&#39;1 day&#39;) tygodnie&lt;-week(sekwencja) ramka&lt;-data.frame(daty=sekwencja, tygodnie=tygodnie) ramka_1&lt;-cbind(ddply(ramka, .(tygodnie_min=tygodnie), summarise, min=min(daty) ), max=ddply(ramka, .(tygodnie_max=tygodnie), summarise, max=max(daty) )[,2] ) cbind(ramka_1[match(daty_komplet[,2], ramka_1[,1]),],daty) 10.26 NA problems in mapping and joining require(plyr) z1 &lt;- c(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,NA) mapvalues(z1, c(NA,&#39;a&#39;), c(&#39;z&#39;,&#39;z1&#39;)) z2 &lt;- factor(c(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,NA)) mapvalues(z2, c(NA,&#39;a&#39;), c(&#39;z&#39;,&#39;z1&#39;)) z3 &lt;- addNA(factor(c(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,NA))) mapvalues(z3, c(NA,&#39;a&#39;), c(&#39;z&#39;,&#39;z1&#39;)) require(car) #character z1 &lt;- c(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,NA) car::recode(z1, &quot;&#39;a&#39;=&#39;z1&#39;; NA=&#39;z2&#39;&quot;) #factor without NA z2 &lt;- factor(c(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,NA)) car::recode(z2, &quot;&#39;a&#39;=&#39;z1&#39;; NA=&#39;z2&#39;&quot;) #factor with NA z3 &lt;- addNA(factor(c(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,NA))) car::recode(z3, &quot;&#39;a&#39;=&#39;z1&#39;; NA=&#39;z2&#39;&quot;) require(dplyr) #character d1 &lt;- data.frame(a=c(&#39;a&#39;,&#39;b&#39;,NA), b=1:3, stringsAsFactors = FALSE) d2 &lt;- data.frame(c=c(&#39;a&#39;,&#39;b&#39;,NA), d=4:6, stringsAsFactors = FALSE) left_join(d1, d2, by=c(&#39;a&#39;=&#39;c&#39;)) #factor without NA as factor d1 &lt;- data.frame(a=factor(c(&#39;a&#39;,&#39;b&#39;,NA)), b=1:3, stringsAsFactors = FALSE) d2 &lt;- data.frame(c=factor(c(&#39;a&#39;,&#39;b&#39;,NA)), d=4:6, stringsAsFactors = FALSE) left_join(d1, d2, by=c(&#39;a&#39;=&#39;c&#39;)) #factor with NA as factor d1 &lt;- data.frame(a=addNA(factor(c(&#39;a&#39;,&#39;b&#39;,NA))), b=1:3, stringsAsFactors = FALSE) d2 &lt;- data.frame(c=addNA(factor(c(&#39;a&#39;,&#39;b&#39;,NA))), d=4:6, stringsAsFactors = FALSE) left_join(d1, d2, by=c(&#39;a&#39;=&#39;c&#39;)) 10.27 Functions by packages 10.28 f:do.call Przekazywanie parametrow do funckji zagniezdzonej w do.call na przykladnie sklejanie kolumn ramki danych do.call(&#39;paste&#39;, c(diamonds[1:10,c(&#39;cut&#39;,&#39;color&#39;)], sep=&#39;_&#39;)) 10.29 f:aggregate require(ggplot2) d&lt;-data(diamonds) #takie zapis jest zly d&lt;-diamonds d&lt;-d[1:20 , c(&#39;cut&#39;, &#39;clarity&#39;, &#39;price&#39;, &#39;carat&#39;) ] #aggeagate #nie ma parametru drop #akceptuje funkcje zwracajace wektory (np. quantile) #parametr symplify=TRUE powoduje ze mamy wynik w postaci wektora lub macierzy. #aggregate a braki danych #wplyw na zmienna grupujaca d&lt;-data.frame(a=c(&#39;a&#39;,&#39;a&#39;,&#39;b&#39;,&#39;b&#39;,NA), b=c(1:5), c=c(6:10)) aggregate(b~a, data=d ,FUN=sum) #braki danych zostaly pominiete dlatego ze tak jest domyslnie ustawione aggregate(b~a, data=d ,FUN=sum, na.action=na.pass) aggregate(b~a, data=d ,FUN=sum, na.action=na.omit) aggregate(b~a, data=d ,FUN=sum, na.action=na.fail) #wplyw na zmienne na ktore dziala funkcja FUN d&lt;-data.frame(a=c(&#39;a&#39;,&#39;a&#39;,&#39;b&#39;,&#39;b&#39;,&#39;b&#39;), b=c(1:4,NA), c=c(6:10)) aggregate(b~a, data=d ,FUN=sum) #braki danych zostaly pominiete dlatego ze tak jest domyslnie ustawione aggregate(b~a, data=d ,FUN=sum, na.action=na.pass) aggregate(b~a, data=d ,FUN=sum, na.action=na.omit) aggregate(b~a, data=d ,FUN=sum, na.action=na.fail) #Wniosek #uwaga. parametr na.action dotyczy elementow na ktore dziala funkcja FUN. Jestli chodzi o kategorie po ktorych sie sumuje nie da sie w zaden sposob uzyska NA jako kategorii. Jedyne rozwiazanie to chyba po prostu przekodowac braki danych na jakis ciag tekstowy 10.30 f:by #funkcja fun musi przetwarzac cala ramke danych. Nie jest to robienie dzialan po kolumnach jak w apply itp. d&lt;-data(diamonds) #takie zapis jest zly d&lt;-diamonds d&lt;-d[1:20 , c(&#39;cut&#39;, &#39;clarity&#39;, &#39;price&#39;, &#39;x&#39;) ] #zastsowanie funkcji w &#39;by&#39; by(d[,c(&#39;price&#39;,&#39;x&#39;)], d[,&#39;clarity&#39;], function(x) lm(price~x, data=x) ) by(d[,c(&#39;price&#39;,&#39;x&#39;)], d[,&#39;clarity&#39;], summary ) 10.31 f:outer #uzycie funkcji a1&lt;-1:3 a2&lt;-c(1:5,NA) outer(a1,a2, function(a,b) mapply(sum,a,b,na.rm=TRUE)) #zagniezdzenie a1&lt;-1:3 a2&lt;-c(1:5,NA) a3&lt;-1:2 outer(a3, outer(a1,a2,&#39;*&#39;),&#39;*&#39;) 10.32 f:summary ## summary dla roznych typow danych i roznych struktur---- ### character z&lt;-rep(c(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;), 100) summary(z) &gt; summary(z) Length Class Mode 300 character character ### logical z&lt;-c(T,F,T) summary(z) &gt; summary(z) Mode FALSE TRUE NA s logical 1 2 0 ### factor z&lt;-factor(c(1,1,2,2,2,2,3)) summary(z) ### matrix z&lt;-matrix(c(1:6), c(2,3)) summary(z) ### data.frame -same libczy z&lt;-data.frame(a=c(1:50), b=51:100) summary(z) ### data.frame-liczby i factor z&lt;-data.frame(a=c(1:50), b=51:100, c=rep(c(&#39;a&#39;,&#39;b&#39;), 25)) summary(z) 10.33 Misselenious 10.33.1 Elementarne funkcje #Sortuje rosnaco wektor Sort(x, decreasing = FALSE) #Zwraca pozycje min (pierwszego, jesli wystepuje kilka elementow najmniejszych)??? which.min(a) #Rozstep, czyli wartosc max i min range() #Roznice dla co drugiego wyrazu wektora (czyli przyrosty) diff(x,lag=1) #Suma skumulowana cumsum(x) #dostaniemy wektor kolejnych skumulowanych sum #Przyklad z helpa zastosowania funkcji sqrt example(sqrt) #Przyrosty dla co drugiej wartosci z wektora x diff(x, lag=2) #Przyrosty 2 rzedy diff(diff(x)) #Jakiego typu jest element x class(x) #Zwracanie wartosci maksymalnej z kolejnych pozycji dla kilku wektorow pmax(a,b,c) #iloczyn elementow wektora prod(x) 10.33.2 Ciagi #Ciag liczb 1:100 X&lt;-c(1:100) #Ciag liczb od -5 do 5 z krokiem rownym 0.3 seq(-5,5,by=0.3) #Ciag stworzony z podzielenia przedzialu [-5;5], na 4 rowne czesci seq(-5,5,length.out=4) #Powtorz wektor x (x to moze byc tez liczba), 5 razy rep(x, Times=5) #Powtorz 5 razy kazdy element wektora x rep(x, each=5) #Powtorz element 2 ,5 razy i element 3, 2 razy rep(c(2,3),c(5,2)) #Zwrocic losowo 4 liczby z wektora x, bez powtarzania sample(x, 4, rep=TRUE) #Ciag malych liter letters[1:10] #Uwaga: lettres(1:10) nie zadziala. Nawiasy sa kwadratowe!!!! #Ciag wielkich liter LETTERS[1:10] 10.33.3 Rangowanie #SKLADNIA: rank(x, #a numeric, complex, character or logical vector na.last = TRUE, #for controlling the treatment of NAs. If TRUE, missing values in the data are put last; if FALSE, they are put first; if NA, they are removed; if &quot;keep&quot; they are kept with rank NA. ties.method = c(&quot;average&quot;, &quot;first&quot;, &quot;random&quot;, &quot;max&quot;, &quot;min&quot;)) #PRZYKLAD: w&lt;-c(3,2,5,6,3,NA,4,5,2) rank(w, na.last=T, ties.method=&#39;average&#39;) #average jest domyslne. Zwroci : 3.5 1.5 6.5 8.0 3.5 9.0 5.0 6.5 1.5 rank(w, na.last=T, ties.method=&#39;max&#39;) #zwroc: 4 2 7 8 4 9 5 7 2 rank(w, na.last=T, ties.method=&#39;min&#39;) #zwroci: 3 1 6 8 3 9 5 6 1 rank(w, na.last=T, ties.method=&#39;random&#39;) #zwrocinp: 3 1 6 8 4 9 5 7 2 rank(w, na.last=T, ties.method=&#39;first&#39;) #zwroci: 3 1 6 8 4 9 5 7 2 10.33.4 Operacje mnogosciowe x&lt;-c(1,2,3,4,5,6,7,8,9, 10) y&lt;-c(6,7,8,9,10,11,12,13,14, 15) union(x, y) #suma intersect(x, y) #elementy wspolne setdiff(x, y) #x-y setequal(x, y) #czy zbiory sa rowne is.element(5, y) is.element(c(3,5,6), y) is.element(x,y) (sum(is.element(x,y)) ==length(x))|(sum(is.element(y,x)) ==length(y)) #czy zbiory sa sobie rowne. Uwaga! to rozwiazanie nie bierze pod uwage elementow powtarzajacych sie zatem np. zbiory {1} oraz {1,1,1} bede rownowazne. ma1&lt;-matrix(x, ncol=2) ma2&lt;-matrix(y, ncol=2) union(ma1, ma2) #macierze sa traktowanej jak wektory # PROBLEM: jak zrobic union wielokrotnie na kilku zbiorach????? 10.33.5 funkcja expand grid x&lt;-c(1,2) y&lt;-c(4,5) z&lt;-factor(c(&#39;a&#39;,&#39;b&#39;) ) u&lt;-c(&#39;w&#39;,&#39;g&#39;) d&lt;-as.Date(c(&#39;2014-09-09&#39;,&#39;1999-09-06&#39;)) expand.grid(x,y,z,u,d) 10.33.6 f:interaction interaction(c(1,2,3),c(2,3,4)) "],
["erros-debugging-profiling.html", "Chapter 11 ERROS DEBUGGING PROFILING 11.1 debuggowanie 11.2 try 11.3 tryCatch 11.4 Funkcja warning 11.5 stop/stopifnot 11.6 assertError assertWarning asserCondition 11.7 przerywanie petli jesli wystapi blad 11.8 Profiling", " Chapter 11 ERROS DEBUGGING PROFILING 11.1 debuggowanie func &lt;- function(a, b) { x &lt;- length(a) y &lt;- mean(c(a, b)) return(x + y) } debug(func) #tryb debuddowania odpalany przed wywolywaniem funkcji func(40, &#39;bleble&#39;) #teraz operujem przyciakami &#39;n&#39; (wykonaj kolejna linijke kodu), &#39;Q&#39; (wyjdz z debuggera), &#39;c&#39; (wykonaj cala funkcje), oraz mozemy przywolywac nazwy kolejnych zmiennych zwiazanych z funkcja aby sprawdzic ich bierzaca wartosc. undebug(func) #wylaczenie trybu debuggowania #traceback func(40) traceback() #traceback wywoluje sie po funkcji w przeciwienstwie do &#39;debug&#39;. Poza tym traceback jest wywolywane tylko dla funkcji w ktorych wystapil error!!! 11.2 try c &lt;- c(&#39;2&#39;, 33) p &lt;- expression(pt &lt;- 5) #wyrazenie ktore bedzie wykonane jezeli wystapi blad cc &lt;- try(sum(c), silent=T) #try wywali blad bo nie da sie zsumowac liczby i stringu #jezeli cc to blad wykonaj wyrazenie &#39;p&#39; if(is(cc,&quot;try-error&quot;)) #to nie to samo co cc==&quot;try-error&quot;!!!!! { eval(p) } pt #otrzymamy 5 bo wyrazenie &#39;p&#39; zostalo wykonane 11.3 tryCatch c &lt;- c(&#39;2&#39;, 33) p &lt;- expression(pt &lt;- 5) #wyrazenie ktore bedzie wykonane jezeli wystapi blad #bez argumentu &#39;finally tryCatch({ sum(c)}, warning=function(w){cat(&#39;ostrzezenie&#39;)}, #funkcje dla warning i error musza miec jakis argument (function() nie bedzie dzialalo) error=function(e){cat(&#39;blad&#39;)}) tryCatch({ sum(c)}, warning=function(w){cat(&#39;ostrzezenie&#39;)}, #funkcje dla warning i error musza miec jakis argument (function() nie bedzie dzialalo) error=function(e){cat(&#39;blad&#39;)}, finally=zk &lt;- 100) #operacje wykonana niezaleznie od wystapienia bledu lub ostrzezenia How to use f:tryCatch to break loop: w &lt;- c(1:5,&#39;a&#39;,7:10); sum &lt;- 0 for(i in 1:10){ if( inherits(tryCatch({sum &lt;- sum + as.numeric(w[i])}, warning=function(w) w, error=function(e) e), c(&#39;warning&#39;, &#39;error&#39;)) ) break } 11.4 Funkcja warning F &lt;- function(z) { ifelse(z &gt; 100, print(&#39;ok&#39;), warning(&#39;we have a problem&#39;)) } F(50) 11.5 stop/stopifnot iter &lt;- 12 z &lt;- 100 if(iter &gt; 10) stop(&quot;too many iterations&quot;) #wyswietli error i komunikat bo nie jest spelniony warunek top &lt;- 100 #oprecja zostanie wykonanana top # stopifnot, list of condidionts (every must be TRUE) stopifnot(1 == 1, all.equal(pi, 3.14159265), 3 &lt; 2) 11.6 assertError assertWarning asserCondition Zwraca blad jezeli nie ma bledu/ostrzezenia require(tools) z &lt;- assertError(sqrt(&#39;abc&#39;)) z u &lt;- assertError(sqrt(4)) # nie ma bledu wiec zwroci blad u w &lt;- assertWarning(matrix(1:8, 4,3)) w r &lt;- assertCondition( &quot;&quot;-1 ) r e &lt;- try( assertCondition(sqrt(2), &quot;warning&quot;) ) e #podsumowanie assertWarning() #musi byc ostrzezenie i tylko ostrzezenie assertError() #musi byc blad i tylko blad assertCondition(matrix(1:8, 4,3), &quot;error&quot;,&quot;warning&quot;)# musi byc blad lub ostrzezenie assertCondition(matrix(1:8, 4,3), &quot;error&quot;) # musi byc blad niezaleznie od tego czy jest warning assertCondition(matrix(1:8, 4,3), &quot;warning&quot;) # musi byc ostrzerzenie niezaleznie od bledu 11.7 przerywanie petli jesli wystapi blad u &lt;- list(1,2,3,&#39;n&#39;,5) s &lt;- 0 for(i in 1:5){ z &lt;- tryCatch(s &lt;- s + u[[i]], error=function(e) e ) if(inherits(z, &#39;error&#39;)) break } 11.8 Profiling 11.8.1 Czas wykonania kodu Rprof(&#39;&#39;profiler.out&#39;&#39;, interval=0.01, memory.profiling=TRUE) #Inicjowanie dzialania profilera. ``Profiler.out(nazwa funkcji z wielkiej litery) Z&lt;-mean(z) Rprof(NULL) #zakonczenie dzialania profilera summaryRprof(&#39;&#39;profiler.out&#39;&#39; memory=&#39;&#39;both&#39;&#39;) #odczywanie danych zarejestrowanych przez profilera unlink(profiler.out) #usuniecie pliku #Prostszy sposob: x&lt;-seq(from=1, to =100000000) system.time(sd(x)) 11.8.2 Czas wykonania kodu od linijki do linijki #pomiar czasu wykonania okreslonych linijek kody przy pomocy funkcji proc.time ptm &lt;- proc.time() for (i in 1:50) mad(stats::runif(500)) z&lt;-10000 proc.time() - ptm Komentarz: Czas ,,zwlekania’’ przez Usera to 0.04, czas wykonania oblicze? przez system to 0.00. oznacza ,,the ‘real’ elapsed time since the process was started’ (z helpa do funkcji)’’. 11.8.3 microbenchmark Funkcja do porownania czasu wykonania roznych kodow. microbenchmark2 &lt;- function(...) { library(&#39;microbenchmark&#39;) x &lt;- do.call(microbenchmark, as.list(match.call()[-1]), envir=parent.frame()) x$time &lt;- microbenchmark:::convert_to_unit(x$time, &#39;t&#39;) res &lt;- aggregate(time~expr, x, median) res &lt;- cbind(res, res[[2]]/min(res[[2]])) colnames(res) &lt;- c(&quot;expr&quot;, &quot;median.time&quot;, &quot;relative&quot;) cat(&quot;Unit: &quot;, attr(x$time, &quot;unit&quot;), &quot;\\n&quot;, sep = &quot;&quot;) print(res) } # # Przyklad: x &lt;- 1:1000 microbenchmark2( sum(x), prod(x) ) ## Measure the time it takes to dispatch a simple function call ## compared to simply evaluating the constant \\code{NULL} f &lt;- function() NULL x&lt;-10000 res &lt;- microbenchmark({mean(x); quantile(x)}, sd(x), times=10L) microbenchmark(NULL, f(), times=1000L) ## Print results: print(res) ## Plot results: boxplot(res) ## Pretty plot: if (require(&quot;ggplot2&quot;)) { plt &lt;- ggplot2::qplot(y=time, data=res, colour=expr) plt &lt;- plt + ggplot2::scale_y_log10() print(plt) } 11.8.4 p:profile 2014-07-15 Pakietu na razie nie ma na Cran-r Uwaga Funkcja testowana nie moze byc zbyt szybka (komunikat: Error: No parsing data available. Maybe your function was too fast?) #instalacja pakietu devtools::install_github(&quot;hadley/lineprof&quot;) #funkcja ktora bedzie testowac pod wzgledem wydajnosci z&lt;-function(){ w&lt;-rnorm(100000000) #duzo losowac aby funkcja nie byla za szybka mean(w) sd(w) quantile(rnorm(100000)) } require(lineprof) l&lt;-lineprof(z()) l #wyniki w formie tekstowej shine(l) #wyniki w formie graficznej w przegladarce internetowej 11.8.5 f:Rprof Rprof(&#39;&#39;profiler.out&#39;&#39;, interval=0.01, memory.profiling=TRUE) #Inicjowanie dzialania profilera. ``Profiler.out(nazwa funkcji z wielkiej litery) Z&lt;-mean(z) Rprof(NULL) #zakonczenie dzialania profilera summaryRprof(&#39;&#39;profiler.out&#39;&#39; memory=&#39;&#39;both&#39;&#39;) #odczywanie danych zarejestrowanych przez profilera unlink(profiler.out) #usuniecie pliku "],
["data-import-and-export-fromto-files.html", "Chapter 12 DATA IMPORT AND EXPORT FROM/TO FILES 12.1 clipboard 12.2 R data 12.3 csv/text 12.4 excel 12.5 Basic web scraping 12.6 Data from api", " Chapter 12 DATA IMPORT AND EXPORT FROM/TO FILES 12.1 clipboard f:read.clipboard.lower(psych) NOTES: useful to import from clipbard triangle matrixes require(psych) z &lt;- read.clipboard.lower() f:readClipboard(utils) NOTES: useful only for character vectors require(utils) z &lt;- readClipboard() 12.2 R data 12.2.1 R Data 12.2.1.1 f:load f:save NOTES about save: file is not default the second argument You can deliver variables names as strings (list), or quoted In file path file extension must be deliverd. You can save any type and number of objects (lists for example) NOTES about load: variables are automatically loaded in to environment. You can’t assignt it to variable (to do this use f:load2 from p:BBmisc) You can specify environment which variables are assigned to. #UWAGA: dodac o RDS!!! z&lt;-data.frame(c=runif(100), b=runif(100)) save(z, file=&#39;C:/Documents and Settings/Lukasz/Pulpit/Quick R/dane.rda&#39;) load(file = &#39;&#39;, envir = pareent.frame(), #environment verbose = FALSE) #if print loaded variables #### f:load2(BBmisc) save2(BBmisc) NOTES: Use to assign loaded Rdata into variable. require(BBmisc) #syntax: z &lt;- load2( file = ,parts = #Elements in file to load. Default is all. ,simplify = ,envir = ,impute = ) save2() 12.2.2 RDS Use to save/load SINGLE object. After loading you can assing to variable Works very fast saveRDS() readRDS() 12.3 csv/text 12.3.1 p:readr library(readr) Book1_csv &lt;- readr::read_delim( &quot;_09/Book1_csv.txt&quot; , delim = &quot;\\t&quot; # delim , escape_double = FALSE , col_types = cols(GBP = col_number()) # type specification only for columns when you want to change default recognized type , locale = locale(encoding = &quot;WINDOWS-1252&quot;) # default UTF-8 , trim_ws = TRUE) # trimming leading and trailing whitespaces 12.4 excel 12.4.1 p:readxl library(readxl) Book1 &lt;- readrxl::read_excel( path = &quot;./_09/Book1.xlsx&quot; , range = &#39;A1:I50&#39; # mtcars!A1:H50 , sheet = &quot;Sheet1&quot; , col_names = TRUE , skip = 0 , na = &quot;&quot; , col_types = c( &quot;date&quot; # nie danemy &#39;Date&#39; ,&quot;text&quot; # nid dajemy &#39;character&#39; ,&quot;numeric&quot; ,&quot;numeric&quot; ,&quot;numeric&quot; ,&quot;numeric&quot; ,&quot;numeric&quot; ,&quot;numeric&quot; ,&quot;numeric&quot;) ) 12.5 Basic web scraping Scrat tables with p:rvest library(rvest) url &lt;- &quot;http://www.espn.com/college-football/rankings&quot; page &lt;- read_html(url) #Creates an html document from URL table &lt;- html_table(page, fill = TRUE) #Parses tables into data frames 12.6 Data from api library(tidyverse) library(httr) library(jsonlite) library(dplyr) # getting data in json format from NBP page dane_json &lt;- fromJSON(txt = &#39;http://api.nbp.pl/api/exchangerates/tables/a/2018-01-01/2018-01-31/?format=json&#39;) # estracking only exchanges rates (without dates) kursy &lt;- dane_json$rates # list of data.frames. Length is equal to number of dates we downloaded # naming each data.frame with appropriate date names(kursy) &lt;- dane_json$effectiveDate # dplyr::bind_rows(kursy, .id=&#39;data&#39;) %&gt;% # binding data frames. Names of data.frames made from dates will create &#39;id column&#39; mutate(data = as.Date(data)) %&gt;% View "],
["tools-and-tricks.html", "Chapter 13 TOOLS AND TRICKS 13.1 Global settings 13.2 Packages and functions 13.3 Funkcje 13.4 Important information 13.5 Parallel computing 13.6 Files and directories manipulation 13.7 Other issues", " Chapter 13 TOOLS AND TRICKS path for RStudio in Users directory C:-Desktop 13.1 Global settings 13.1.1 f:options najwazniejsze parametry to: scipen - od jakiej wielkosci liczby maja byc wyswietlane w postaci wykladniczej digits - ile miejsc po przecinku wyswietlac error - co ma sie dziac w sytuacji wystapienia bledu. Mozna np. ustawic error=browser domsylnie jest error=stop. expressions - ilosc zagniezdzen w obiektach o wlasnosci recursive width - ile znakow szerokosci ma miec output w konsoli. Dosylnie jest 80. encoding - sposob kodowania 13.1.2 working directory setwd() # set current working directory getwd() # get current working directory 13.1.3 changing language Sys.setenv(LANGUAGE=&quot;en&quot;) #change language only for current session 13.2 Packages and functions 13.2.1 f:library a f:require Roznica miedzy f:library i f:require: jezeli ładowanego pakietu nie ma to f:library zwraca error natomiast f:require zwraca warning nazwy pakietow z f:library podaje sie w cudzyslowiu Uwaga: obie funcje moga ladowac tylko jeden pakiet. Funkcja naladowanie jednoczesnie klilku pakietow pokazana jest dalej. 13.2.2 Pakiety Lista zainstalowanych pakietow razem z podanymi szczegółowymi informacjami z&lt;-installed.packages() print(xtable(head(z,3)), type=&#39;html&#39;) z&lt;-installed.packages() print(xtable(head(z)), type=&#39;html&#39;, html.table.attributes=&#39;style=&quot;font-size:11px;&quot;&#39;) #usuwanie pakietu remove.packages(c(&#39;ggplot2&#39;,&#39;xtable&#39;) #instalowanie pakietu install.packages(c(&#39;ggplot2&#39;,&#39;xtable&#39;) ) #sciezka gdzie sa pliki pakietow .libPaths() #lokalizacja plikow pakietu na dysku find.package(&#39;abind&#39;) #opis pakietu packageDescription(&#39;abind&#39;) #how many packages are installed nrow(installed.packages()) #list of data sets in package data(package=&#39;ggplot2&#39;) # lista zawierajaca m.in zaladowane pakiety search() #lista aktualnie zaladowanych pakietow (.packages()) print(.packages()) #wylaczenie pakietu (&#39;odladowanie&#39;) detach(name = &#39;package:ggplot2&#39;, unload=TRUE) #jesli pakiet jest niezaladowany to go zaladuj if (!require(rgl)){ require(rgl) } #jesli pakiet jest niezainstalowany to go zainstaluj if (!require(rgl)){ install.packages(rgl) } #zaladuj lub zainstaluj pakiet require(rgl) || install.packages(rgl) 13.2.3 funkcja do ladowania na raz kilku pakietow l.p.pak&lt;-function(...){ pkg&lt;-unlist(list(...)) #pakiety ktore nie sa zainstalowane brak&lt;-pkg[!(pkg%in%installed.packages()[,&quot;Package&quot;] )] if(length(brak)) warning(paste(&#39;pakiety &#39;,paste(brak, collapse=&#39;, &#39;),&#39; nie sa zainstalowane&#39;, sep=&#39;&#39;)) #pakiety ktore sa z&lt;-setdiff(pkg,brak) #ladowanie pakietow ktore sa if(length(z)) sapply(pkg, require, character.only = TRUE) } l.p.pak(&#39;ggplot2&#39;,&#39;abind&#39;) Pakiety z Bicunductor: # firm we have to install &#39;Biconductor&#39; source(&quot;https://bioconductor.org/biocLite.R&quot;) biocLite() # then we can install packages from &#39;Biconductor&#39; BiocInstaller::biocLite(&#39;IRanges&#39;) # installing p:IRanges 13.3 Funkcje #lista wbudowanych funkcji w R builtins() #lista funkcji w pakiecie ggplot2::&lt;TAB&gt; #lista funkcji w pakiecie zwracana do wektora ls(&#39;package:ggplot2&#39;) #znalezienie w helpie funkcje z konkretnego pakietu ??abind::abind base::&lt;TAB&gt; 13.3.1 f:formatC formatC(300, format=&#39;e&#39;) formatC(c(2.3,4.5,33,9999999), digits = 3, #ilosc cyfr po przecinku flag=&quot;0&quot;, #ilosc zer (dla typy &#39;f&#39; po przecinku, dla typy &#39;d&#39; przed liczba) width=4, #minimalna szerokosc format = &#39;f&#39;, #format d-integer, f-float, e-exponencial big.mark = &quot; &quot;, #separator co 3 cyfry decimal.mark = &quot;,&quot;, ) #decinal separator formatC(c(2.3,4.5,33,9999999), digits = 3, flag=&quot;0&quot;, width=4, format = &#39;f&#39;, big.mark = &quot; &quot;, decimal.mark = &quot;,&quot; ) 13.4 Important information Sys.time() Sys.Date() Sys.timezone() object.size(z) #ilosc pamieci jaka zajmuje obiekt sessionInfo() #informacje o biezacej sesji R-a (wersja R, system operacyjny, zaladowane pakiety, base packages, ustawienia) Sys.info() #informacje o systemie operacyjnym #java version installed on computer system(&#39;java-version&#39;) R.Version() #bardz szczegolowe inforamcje na temat wersji R-a # statystyki na temat pakietow packageStatus() 13.5 Parallel computing 13.6 Files and directories manipulation For more information see: Biecek p.59. #utworz katalog dir.create(&#39;C:/Users/ppp/Desktop/bleble&#39;) #skopiuj plik file.copy(&#39;C:/Users/ppp/Desktop/book.xlsx&#39;, &#39;C:/Users/ppp/Desktop/bleble/book.xlsx&#39;) #wywolaj okno i zwroc sciezke dostepu w &lt;- file.choose() w #usun plik (chyba nie dziala na katalogach) file.remove(&#39;C:/Users/ppp/Desktop/bleble/book.xlsx&#39;) #zmien nazwe pliku file.rename(&#39;C:/Users/ppp/Desktop/bleble/book.xlsx&#39;,&#39;C:/Users/ppp/Desktop/bleble/book111.xlsx&#39;) #lista plikow (z rozszerzeniami) i katalogow w danej lokalizacji list.files(&#39;C:/Users/ppp/Desktop/bleble&#39;, #katalog include.dirs = TRUE, #czy zwrocic katalogi w katalogach all.files = TRUE, #czy pliki ukryte full.names = TRUE) #czy podawac cala sciezke pliku #dir robi to samo i ma takie same parametry jak list.files dir(&#39;C:/Users/ppp/Desktop/bleble&#39;) Wyciagniecie samych plikow bez katalogow (mam nadzieje ze rozwiazanie tymczasowe) (2014-10-25) Po zaistalowaniu open R w f:list.files znowu poprawnie dziala parametr include.dir (2014-11-12) path=&#39;...&#39; setdiff( list.files(path), list.dirs(path,full.names = FALSE, recursive = FALSE) ) 13.7 Other issues gc() #czyszczenie pamieci operacyjnej #lista zbiorow danych we wszystkich zaladowanych pakietach data() ?Syntax #dostepne w R operatory ?Mod #operatory do liczb zespolonych ?Extract #wyciaganie elementow z obiektow "],
["philosopies.html", "Chapter 14 PHILOSOPIES 14.1 graphic systems in R 14.2 p:ggplot 14.3 lattice 14.4 p:rgl 14.5 ggvis", " Chapter 14 PHILOSOPIES 14.1 graphic systems in R 14.1.1 g:graphics 14.1.1.1 useful functions #czyszczenie pola wykresu plot.new() 14.1.1.2 basic-f:par Use f:par to change settings of displayed plot. Setting are valid till you change it again using f:par. Watch out! par( mfcol=c(1,2), #rozmiary siatki po wierszach mfrow=c(1,2), #rozmiary siatki po kolumnach bg=&#39;blue&#39;, #kolor tla wykresu col.main=&#39;black&#39;, #title color col.axis=&#39;black&#39;, #axis color col.lab=&#39;black&#39;, #color of axis label col.sub=&#39;black&#39;, #subtitle color #col=&#39;black&#39;, #all colours are black (except for background) cex=5, #size of elements on a plot (dots). Details can be specified like in the case of &#39;col font=5, #wielkosc czcionki na wszystko. Mozna specyfikowac szczegolowo jak przy &#39;col&#39; mar=c(5, 4, 4, 2), #wielkosc marginesow na okolo pola wykresu, new=F, #when you draw a plot the old one should be removew to get clear pane. Default is &#39;FALSE&#39;, xlog=T, #czy scala x logarytmiczna ylog=T #czy skala y logarytmiczna ) More details see: ‘Przewodnik po pakiecie R’ Biecek p. 264. 14.1.1.3 layout Use if you want to have irregular grid for a plots. # mamy 4 elementy (dlatego ze taki jest rozmiar macierzy zadeklarowanej) layout(matrix(c(1, # wykres nr zajmuje pierwsza kratke 0, # druga kratka jest puste 1, # trzecia kratke zajmuje wykres nr 1 2),# czwarta kratke zajmuje wykres nr 2 ncol=2, nrow=2, byrow = TRUE) ) layout.show(2) # pokaza wszystkie elementu o numerze nie wiekszym niz 2 plot.new() hist(diamonds$price) hist(diamonds$depth) 14.1.2 grid 14.1.2.1 viewports 14.1.2.1.1 general rules viewporty require(grid) #wspolpracuje z ggplotem require(ggplot2) grid.newpage() #nowa czysta strona #poruszanie sie po viewportach #nowa czysta strona grid.newpage() #okreslenie pierwszego vieportu vp &lt;- viewport(width=0.5, height=0.5, name=&#39;A&#39;) #gp okresla parametry graficzne. Grid.rect robi otoczke dla obszaru grid.rect(gp=gpar(col=&#39;blue&#39;)) #robimy pierwszy viewport. Tutaj nie podajemy parametru &#39;name&#39; pushViewport(vp) #obramowanie dla pierwszego vieportu grid.rect(gp=gpar(col=&#39;red&#39;)) #okreslenie drugiego vieportu vp1&lt;-viewport(width=0.5, height=0.5, layout=grid.layout(1,2), name=&#39;B&#39;) #w tym viewporcie zrobie sobie dodatkowo grid&#39;a. Jest zagniezdzony w pierwszym viewporcie. #zrobienie drugiego viewportu pushViewport(vp1) grid.rect(gp=gpar(col=&#39;yellow&#39;)) a1&lt;-data.frame(a=c(3,4,4,5,6,5,6,7,7,6,7,8)) p1&lt;-ggplot()+geom_bar(data=a1, aes(x=a) ) print(p1,vp=viewport(layout.pos.row=1, layout.pos.col=2) ) #drukuje wykres w aktualnym viewport (&#39;B&#39;) #przeniesienie do innego viewport upViewport(0) #przechodze na najwyzszy poziom 0 downViewport(vpPath(&#39;A&#39;, &#39;B&#39;)) a1&lt;-data.frame(a=c(3,4,7,5,4,5,1,1,1,2,2,3)) p2&lt;-ggplot()+geom_bar(data=a1, aes(x=a) ) print(p2,vp=viewport(layout.pos.row=1, layout.pos.col=1) ) #PRZYKLAD Z CHWILOWEK dane1&lt;-data.frame(a= dane[ dane[,&#39;START.ROK&#39;]==2011 &amp; dane[,&#39;ZAROBEK&#39;]&lt;10000, &#39;ZAROBEK&#39;] ) srednia&lt;-mean(dane1[,1], na.rm=T) mediana&lt;-median(dane1[,1], na.rm=T) plot1&lt;-ggplot() + ....... plot2&lt;-ggplot() + ....... plot3&lt;-ggplot() + ....... #ustawienie grida na ktorym beda rozmieszczone wykresy grid.newpage() pushViewport(viewport(layout = grid.layout(3, 2))) #ustawienie ilosci panali: # wiersze i 2 kolumny print(plot3, vp = viewport(layout.pos.row = 1, layout.pos.col = 1)) print(plot2, vp = viewport(layout.pos.row = 1, layout.pos.col = 2)) print(plot1, vp = viewport(layout.pos.row = 2:3, layout.pos.col = 1:2)) #plot 1 zajmuje 2 i 3 wiersz oraz pierwsza i druga kolumne 14.1.2.1.2 ggplot i zwykly wykres na jednej stronie library(grid) library(gridBase) library(ggplot2) # start new page plot.new( ) # setup layout gl &lt;- grid.layout(nrow=1, ncol=2) #kolejne odpalane vieporty beda w kolejnych komorkach grid.layout # grid.show.layout(gl) # setup viewports vp.1 &lt;- viewport(layout.pos.col=1, layout.pos.row=1) vp.2 &lt;- viewport(layout.pos.col=2, layout.pos.row=1) # pierwszy vieport pushViewport(viewport(layout=gl)) # stworzenie vieportu zagniezdzonego w pierwszym pushViewport(vp.1) # start new base graphics in first viewport par(new=TRUE, fig=gridFIG()) #musimy stworzyc par. Nie da sie bezposrednio wkleic wykresu plot(x = 1:10, y = 10:1) #wracam do poczatku (zeby kolejny vieport nie byl zagniezdzony) popViewport() # move to the next viewport pushViewport(vp.2) #vieport znajdzie sie w drugiej komorce grid.layout ktora to wymusi (pierwsza jest juz zajeta) ggplotted &lt;- qplot(x=1:10,y=10:1, &#39;point&#39;) # print our ggplot graphics here print(ggplotted, newpage = FALSE) popViewport(1) 14.2 p:ggplot 14.2.1 General issues 14.2.1.1 Podstawowe parametry wygladu require(ggplot2) require(scales) #zeby mozna bylo ustawic format liczbowy na osiach windowsFonts(Verdana=&#39;TT Verdana&#39;) #nowa czcionka ktora bedzie wykorzystana w wykresie data(diamonds) ggplot(data=diamonds) + geom_histogram(aes(x=price, y=..density..), binwidth=100) + ggtitle(&quot;Tytul \\n wykresu&quot;) + #Tytul wykresu xlab(&#39;bleble&#39;) + ylab(&#39;alala&#39;) + xlim(0,10000) + #ograniczenie zakresu danych z osi x ylim(0,1) + #ograniczenie zakresu danych z osi y guides(fill = guide_legend(title.theme = element_text(size=15, face=&quot;italic&quot;, colour = &quot;red&quot;, angle = 45))) + #formatowanie tytulu legendy scale_x_continuous(breaks=c(5000,10000), labels=c(&#39;a&#39;,&#39;b&#39;)) + scale_y_continuous(labels=comma) + #ustawienie formatowania scale_fill_continuous(guide = &quot;legend&quot;) + theme( plot.title=element_text(colour=&#39;red&#39;,size=9, angle=30, vjust=1, face=&#39;bold&#39;, family=&#39;Verdana&#39;), axis.title.x=element_text(size=9), #tytul osi x axis.title.y=element_text(angle=30), #tytul osi y axis.text.x=element_text(angle=10), #elementy na osi y axis.text.y=element_text(angle=30), #elementy na osi y axis.line.x=element_line(size=1, linetype=&#39;dotted&#39;,colour=&#39;blue&#39;), #linie osi x axis.line.y=element_line(size=1), #linie osi y axis.ticks.x=element_line(linetype=2), #znaczki na osi x axis.ticks.y=element_line(linetype=1), #znaczki na osi y axis.ticks.length=unit(2.3, &#39;cm&#39;), axis.ticks.margin=unit(1.3, &#39;cm&#39;), legend.position=c(.5,.5), #mozna dac &#39; &quot;bottom&quot; ,&#39; &quot;none&quot; &#39;, &#39; &quot;top&quot; &#39; #legend.box=, #jezeli mamy multiple legend to czy ma byc w ukladzie pionowym czy poziomym legend.direction=&#39;vertical&#39;, #moze byc &#39;horizontal&#39; i &#39;vertical&#39; legend.title=element_text(colour=&#39;blue&#39;), #formatowanie wygladu tekstu opisujacego legende legend.text=element_text(colour=&#39;yellow&#39;), legend.justification=c(.3,.2), # mozna dac tez &#39; &quot;center&quot; &#39; legend.background=element_rect(colour=&#39;blue&#39;, fill=&#39;red&#39;, linetype=2 , size=3), # panel.background=element_rect(colour=&#39;green&#39;, fill=&#39;red&#39;), #tlo wykresu #panel.border=element_rect(colour=rgb(.5,.5,.5), fill=&#39;green&#39;), #otoczenie wykresu. Cos kiepsko dziala panel.grid.minor.x=element_line(linetype=2), panel.grid.major.x=element_line(linetype=2), panel.grid.minor.y=element_line(linetype=2), panel.grid.major.y=element_line(linetype=2), panel.margin=unit(.3,&#39;cm&#39;) #wielkosc marginesu na okolo wykresu ) Notes: 1. Gdy chcemy zeby czegos nie bylo w themes dajemy ‘element_blank()’. Wyjatkiem jest ‘legend.position’ gdzie dajemy none 2. W czcionce face moze miec wartosci bold, italic. 3. linetype moze przyjmowac wartosci liczbowe: 0 = blank, 1 = solid, 2 = dashed, 3 = dotted, 4 = dotdash, 5 = longdash, 6 = twodash 4. format moze przyjac wartosci dollar, comma, percent, sientific. Ustawiamy to np. w scale_x_continuous(labels=percent). Potrzeba p:scales. 5. break na wykresie mozna recznie modyfikowac: scale_x_continuous(breaks=c(2,5,8)) 14.2.1.2 facets Parameter Values Comment shrink drop logical Czy nie brac pod uwage; poziomow czynnikow ktore sie nie znalazly w wyswietlanych danych Zroznicowanie zakresu osi ze wzgledu na facet: facet_grid(kateg~. ,scales='fixed') facet_grid(kateg~. ,scales='free') facet_grid(kateg~. ,scales='free_x') facet_grid(kateg~. ,scales='free_y') Example for drop diamonds$cut &lt;- factor(diamonds$cut, levels=c(levels(diamonds$cut) ,&#39;mmm&#39;)) ggplot() + geom_density(data=diamonds, aes(x=price)) + facet_grid(.~cut, drop=FALSE) ggplot() + geom_density(data=diamonds, aes(x=price)) + facet_grid(.~cut, drop=TRUE) 14.2.1.3 fill and colour Umieszczone poza umozliwia wskazanie koloru Jezeli fill jest w aes, to sluzy on wtedy do wskaZwania zmiennej po ktorej jest grupowany wykres fill. Musi byc wtedy typu factor. Dlatego dla bezpieczenstwa lepiej jest uzywaC dodatkowo f:as.factor. Wtedy kolory wypelniania ustawia sie inaczej: scale_fill_manual(values = c(&quot;red&quot;,&quot;blue&quot;, &quot;green&quot;)) scale_fill_brewer(type=&quot;seq&quot;, palette=3) Patrz tez inne funkcje typu scale_fill Reczne ustawianie kolorow dla fill. scale_colour_manual(values = c(&quot;red&quot;,&quot;blue&quot;, &quot;green&quot;)) Opis kategorii na legendzie scale_fill_manual(values=c(',dob,',',zle,')) ',sep='') 14.2.1.4 Pozycjonowanie Jest 5 rodzajow pozycjonowania: 14.2.2 grid.arrange 14.2.3 grid.arrange (gridExtra) Jest to odpowiednik prostej funkcji par stosowanej do podstawowych wykres?w w R require(ggplot2) require(gridExtra) plot1&lt;-ggplot(diamonds, aes(clarity, fill=cut)) + geom_bar() plot2&lt;-ggplot(diamonds, aes(color)) + geom_bar() grid.arrange(plot1,plot2, ncol=2, nrow=1) 14.2.4 Tricks and problems 14.2.4.1 Dynamic elements 14.2.4.1.1 Limits require(ggplot2) limits_1 &lt;- NULL ggplot() + geom_density(data=diamonds, aes(x=price)) + scale_x_continuous(limits=limits_1) limits_2 &lt;- c(10,10000) ggplot() + geom_density(data=diamonds, aes(x=price)) + scale_x_continuous(limits=limits_2) 14.2.4.1.2 fill require(ggplot2) fill_1 &lt;- NULL ggplot() + geom_density(data=diamonds, aes(x=price, fill=eval(fill_1)) ) fill_2 &lt;- quote(cut) ggplot() + geom_density(data=diamonds, aes(x=price, fill=eval(fill_2)) ) 14.2.4.1.3 facets facet_1 &lt;- NULL ggplot() + geom_density(data=diamonds, aes(x=price)) + facet_1 variable &lt;- &#39;cut&#39; facet_2 &lt;- facet_grid(paste0(&#39;.~&#39;,variable)) ggplot() + geom_density(data=diamonds, aes(x=price)) + facet_2 To add empty facet just add NULL to the plot. w &lt;- facet_grid(.~cut) z &lt;- TRUE ggplot() + geom_density(data=diamonds, aes(x=price)) + if(z) NULL else w 14.2.4.2 Zmiana domylsnego stylu require(ggplot2) ble&lt;-theme_set(theme_bw()) ble&lt;-theme_update( panel.border=element_rect(colour=&quot;black&quot;, fill=NA, size=2), panel.grid.major=element_line(colour=rgb(.4,.4,.4), size=.3, linetype=1), axis.title.y=element_text(face=&quot;bold&quot;, size=14), axis.title.x=element_text(face=&quot;bold&quot;, size=13) , axis.text.x=element_text(colour=rgb(.0,.0,.0), size=12, face=&quot;bold&quot;), axis.text.y=element_text(colour=rgb(.0,.0,.0), size=12, face=&quot;bold&quot;) , panel.background=element_rect(fill=rgb(.99,.99,.99)), legend.text=element_text(size=5), legend.title=element_text(size=10), strip.text.x=element_text(size=5)) data(diamonds) ggplot()+geom_histogram(data=diamonds, aes(x=cut),fill=&#39;red&#39;) ggplot()+geom_density(data=diamonds, aes(x=cut)) ggplot()+geom_bar(data=diamonds, aes(x=cut)) 14.2.4.3 Praca na kilku stylach require(ggplot2) t_1 &lt;- theme(panel.background=element_rect(fill=&#39;green&#39;)) t_2 &lt;- theme(panel.background=element_rect(fill=&#39;yellow&#39;)) ggplot() + geom_density(data=diamonds, aes(x=price)) + t_1 ggplot() + geom_density(data=diamonds, aes(x=price)) + t_2 14.2.4.4 Podwojna os x d = data.frame(x = 1:20, y = rnorm(20, 5, 5)) require(ggplot2) ggplot(data = d, aes(x = x, y = y)) + scale_x_continuous(breaks = c(1:20, #braks dla ornego wiersya seq(2.54, 20, 2.54)), #breaks dla dolnego wiersya labels = c(1:20, #labels dla gornego wiersza paste0(&quot;\\n&quot;, 1:as.integer(20/2.54), &quot;\\&quot;&quot;)) ) + #labels dla dolnego wiersza geom_point() 14.2.4.5 Podwojna os y library(ggplot2) library(gtable) library(grid) grid.newpage() # two plots p1 &lt;- ggplot(mtcars, aes(mpg, disp)) + geom_line(colour = &quot;blue&quot;) + theme_bw() p2 &lt;- ggplot(mtcars, aes(mpg, drat)) + geom_line(colour = &quot;red&quot;) + theme_bw() %+replace% theme(panel.background = element_rect(fill = NA)) # extract gtable g1 &lt;- ggplot_gtable(ggplot_build(p1)) g2 &lt;- ggplot_gtable(ggplot_build(p2)) # overlap the panel of 2nd plot on that of 1st plot pp &lt;- c(subset(g1$layout, name == &quot;panel&quot;, se = t:r)) g &lt;- gtable_add_grob(g1, g2$grobs[[which(g2$layout$name == &quot;panel&quot;)]], pp$t, pp$l, pp$b, pp$l) # axis tweaks ia &lt;- which(g2$layout$name == &quot;axis-l&quot;) ga &lt;- g2$grobs[[ia]] ax &lt;- ga$children[[2]] ax$widths &lt;- rev(ax$widths) ax$grobs &lt;- rev(ax$grobs) ax$grobs[[1]]$x &lt;- ax$grobs[[1]]$x - unit(1, &quot;npc&quot;) + unit(0.15, &quot;cm&quot;) g &lt;- gtable_add_cols(g, g2$widths[g2$layout[ia, ]$l], length(g$widths) - 1) g &lt;- gtable_add_grob(g, ax, pp$t, length(g$widths) - 1, pp$b) # draw it grid.draw(g) 14.2.4.6 group Problem polega na tym zeby narysowac geom_line w sytuacji gdy x jest typu factor. Trzeba wtedy ustawic group na 1. ggplot() + geom_point(data=d8, aes(x=factor(miesiac), y=odrzucenie_proc)) + geom_line(data=d8, aes(x=factor(miesiac), y=odrzucenie_proc, group=1)) 14.2.4.7 f:gg_build Tip W przypadku ggplot da sie wyciagnac wszystkie parametry niezbedne do narysowania wykresow (szerokosc bloczkow, wysokosc, dane, zakres osi itp.). Uzywamy do tego funkcji ggplot_build require(ggplot2) require(grid) data(diamonds) d&lt;-diamonds p&lt;-ggplot()+geom_histogram(data=d, aes(x=price)) + annotate(&#39;text&#39;, x=.5, y=.5, label=&#39;bleble&#39;, default.unit=unit(c(.5,.5),&#39;cm&#39;)) ggplot_build(p) 14.2.4.8 slowny opis osi y hwp + scale_y_continuous(breaks=c(50, 56, 60, 66, 72), labels=c(&quot;Tiny&quot;, &quot;Really\\nshort&quot;, &quot;Short&quot;, &quot;Medium&quot;, &quot;Tallish&quot;)) 14.2.4.9 using dodge W geom_text nie używa sie position=‘dodge’ ale: ggplot(data=d1) + geom_bar(aes(x=variable, y=value, fill=statystyka), position=‘dodge’, stat=‘identity’) + geom_text(aes(x=variable, y=value, label=round(value,0), fill=factor(statystyka)), position=position_dodge(width=1)) + facet_grid(PD~.) 14.2.4.10 rodzaje wykresow 14.2.4.10.1 histogram require(ggplot2) data(diamonds) ggplot()+geom_histogram( data=diamonds, aes(x=price, y=..count.. #moze byc ..count.. i ..density.. . Przy density chyba mozna wybierac jadro wygladzania ), binwidth=1 #im mniejsza wartosc tym ciensze bloczki. ) 14.2.4.10.2 Wykres gestosci-[density plot] require(ggplot2) data(diamonds) ggplot()+geom_density( data=diamonds, aes(x=price, y=..count.. #moze byc ..count.. i ..density.. . PPRzy density chyba mozna wybierac jadrow wygladzania ), adjust=.5 #im mniejsza wartosc tym dokladniejsze dopasowanie ) 14.2.4.10.3 Wykres kolowy [pie plot] bez facet require(ggplot2) data(mtcars) ggplot( mtcars, stat=&#39;indentity&#39;, #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! aes(x = factor(1), fill = factor(cyl))) + geom_bar( width = 1) + coord_polar( theta = &quot;y&quot;) + theme( panel.border=element_rect(colour=&quot;black&quot;, fill=NA, size=2), panel.grid.major=element_line(colour=rgb(.4,.4,.4), size=.3, linetype=1), axis.title.y=element_blank(), axis.title.x=element_blank(), axis.text.x=element_text(colour=rgb(.0,.0,.0), size=12, face=&quot;bold&quot;), axis.text.y=element_text(colour=rgb(.0,.0,.0), size=12, face=&quot;bold&quot;), panel.background=element_rect(fill=rgb(.99,.99,.99)), legend.text=element_text(size=5), legend.title=element_text(size=10), strip.text.x=element_text(size=5)) + scale_fill_brewer(palette=1) + scale_y_continuous(breaks=NULL) + scale_x_discrete(breaks=NULL) z facet !!!!! zbadac co ten wykres tak naprawde wyswietla. !!!!! require(ggplot2) data(mtcars) ggplot(mtcars, aes( x = factor(1), fill = factor(cyl))) + geom_bar( width = 1, stat=&#39;bin&#39;, #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! position=&#39;fill&#39;) + facet_grid( .~vs) + coord_polar( theta = &quot;y&quot;) + theme( panel.border=element_rect(colour=&quot;black&quot;, fill=NA, size=2), panel.grid.major=element_line(colour=rgb(.4,.4,.4), size=.3, linetype=1), axis.title.y=element_blank(), axis.title.x=element_blank(), axis.text.x=element_text(colour=rgb(.0,.0,.0), size=12, face=&quot;bold&quot;), axis.text.y=element_text(colour=rgb(.0,.0,.0), size=12, face=&quot;bold&quot;), panel.background=element_rect(fill=rgb(.99,.99,.99)), legend.text=element_text(size=5), legend.title=element_text(size=10), strip.text.x=element_text(size=15)) + scale_fill_brewer(palette=1) + scale_y_continuous(breaks=NULL) #po to aby nie bylo dodatkowych opisow na obreczy Opisy #pie z opisami - wykonywany recznie require(ggplot2) data(diamonds) e&lt;-as.data.frame(prop.table(table(diamonds[,&#39;cut&#39;]))) z&lt;-data.frame(il=e$Var1, naz=e$Freq ) z$ddd&lt;-cumsum(sort(z[,2])) ggplot() + geom_bar(data=z, aes(x=factor(1), y=z[,2] ,fill=z[,1]), stat=&#39;identity&#39;) + geom_text(data=z, aes(x=factor(1), y=z[,&#39;ddd&#39;] ,label=z[,2], fill=z[,1]), colour=&#39;white&#39;, size=10)+ coord_polar(theta=&#39;y&#39;)+ theme( panel.border=element_rect(colour=&quot;black&quot;, fill=NA, size=2), panel.grid.major=element_line(colour=rgb(.4,.4,.4), size=.3, linetype=1), axis.title.y=element_blank(), axis.title.x=element_blank(), axis.text.x=element_text(colour=rgb(.0,.0,.0), size=12, face=&quot;bold&quot;), axis.text.y=element_text(colour=rgb(.0,.0,.0), size=12, face=&quot;bold&quot;), panel.background=element_rect(fill=rgb(.99,.99,.99)), legend.text=element_text(size=5), legend.title=element_text(size=10), strip.text.x=element_text(size=5)) + scale_y_continuous(breaks=NULL) + scale_x_discrete(breaks=NULL) 14.2.4.10.4 Wykres pudelkowy [box plot] Warning! Tutaj w parametrze mapowaniu ‘y’ jest automatycznie zmienna grupujac. Parametru fill mozna uzyc do dodatkowego pogrupowania. Przyklad bez fill require(ggplot2) data(diamonds) ggplot()+geom_boxplot( data=diamonds, aes(y=price, x=cut )) Przyklad z fill require(ggplot2) data(diamonds) ggplot()+geom_boxplot( data=diamonds, aes(y=price, x=cut, fill=clarity ) ) Przyklad jezeli chcemy zrobic BEZ GRUPOWANIA. require(ggplot2) data(diamonds) ggplot()+geom_boxplot( data=diamonds, aes(y=price, x=1 )) Warning! Uwaga. Zmienne grupujace (zarowno x w aes jak i fill) musze byc typu factor. Parametr notch. wykonuje dodatkowe wciecia w boxplotach na wysoko?ci mediany. require(ggplot2) data(diamonds) ggplot()+geom_boxplot( data=diamonds, aes(y=price, x=cut ), notch=.5 ) 14.2.4.10.5 Wykres skrzypcowy [violin plot] require(ggplot2) data(diamonds) ggplot(mtcars, aes(factor(cyl), mpg)) + geom_violin(trim=T) 14.2.4.10.6 Wykres rozrzutu [scatter plot] require(ggplot2) data(diamonds) ggplot() + geom_point( data=diamonds, aes( x=price, y=carat )) 14.2.4.10.7 Wykres rozrzutu z liniow regresji require(ggplot2) data(diamonds) ggplot() + geom_point( data=diamonds, aes( x=price, y=carat )) + stat_smooth( data=diamonds, aes(x=price, y=carat), method=&#39;lm&#39; #do wyboru jest &#39;loess&#39; , &#39;lm&#39; i &#39;glm&#39; , size=2) 14.2.4.10.8 Regresja kwantylowa Uwaga: wymagany pakiet quantreg. require(quantreg) require(ggplot2) data(diamonds) ggplot()+geom_quantile(data=diamonds, aes( x=price, y=carat ) ) 14.2.4.10.9 Wykres kwantyl-kwantyl [qq plot] W wykresie kwantylowym ggplot wymaga aby x i y byly rownoliczne. Jezeli chcemy obejsc ten problem robimy najpierw qq plot wykresem z pakietu basic. Wyciagamy potem wspolrzedne i podkladamy je do ggplota (np. do wykresu rozrzutu). Dwie zmienne r?wnoliczne: require(ggplot2) data(diamonds) ggplot()+stat_qq( data=diamonds, aes( sample=price, theoretical=z) ) Dwie zmienne roznoliczne z1&lt;-rnorm(100) z2&lt;-rnorm(200) z3&lt;-qqplot(z1,z2) x&lt;-z3$x y&lt;-z3$y ggplot()+geom_point(aes(x=x,y=y)) #zmienna i rozklad o zadanych parametrach ggplot()+stat_qq( data=diamonds, aes(sample=price), distribution=qnorm, dparams=list(mean=1, sd=3) ) 14.2.4.11 Wykres paskowy [barplot] Jezeli chcemy po prosty wyswietlic okreslone wartosci zmiennej: z&lt;-data.frame(a=c(2,1,5,4,3), b=letters[1:5]) ggplot()+geom_bar(data=z, aes(x=b, y=a), stat=&#39;identity&#39;) Jezeli chcemy zliczyc (histogram) ggplot() + geom_bar(data=diamonds, aes(x=clarity), stat=&#39;bin&#39;) 14.2.4.12 Wykres powierzchniowy [area plot] z&lt;-data.frame(a=c(1,2,3,4,5), b=c(3,2,4,5,1)) ggplot()+geom_area(data=z, aes(x=a, y=b)) 14.2.4.13 Wykres wstazkowy [ribbon plot] z&lt;-data.frame(a=c(1,2,3,4,5), b=c(3,2,4,5,1), c=c(3,2,2,3,2)) ggplot()+geom_ribbon(data=z, aes(x=a, ymin=b, ymax=c)) 14.2.4.14 Wykres z linia o okreslonym nachyleniu` require(ggplot2) data(diamonds) ggplot()+geom_line(data=diamonds, aes(x=carat, y=price)) 14.2.4.15 Wykres z linia o okreslonym nachyleniu require(ggplot2) data(diamonds) ggplot()+geom_point(data=diamonds, aes(x=price, y=z)) + geom_abline(intercept = 10, slope = .002, colour=&#39;red&#39;) 14.2.4.16 Linia pionowa i pozioma require(ggplot2) data(diamonds) ggplot(diamonds, aes(x=carat, y=price, colour=cut)) + geom_point() + geom_hline(yintercept=6000, colour=&#39;red&#39;) + geom_vline(xintercept=2, size=1) 14.2.4.17 Sciezka [path] z&lt;-data.frame(a=c(1,3,2,4), b=c(3,2,3,4)) ggplot()+geom_path(data=z, aes(x=a, y=b)) 14.2.4.18 Wykres bledu [Error bar] z&lt;-data.frame(a=c(1,2,3,4), b=c(2,3,4,4), c=c(3,5,6,9)) ggplot()+geom_errorbar(data=z, aes(x=a, ymin=b, ymax=c)) 14.2.4.19 Linerange z&lt;-data.frame(a=c(1,2,3,4), b=c(2,3,4,4), c=c(3,5,6,9)) ggplot()+geom_linerange(data=z, aes(x=a, ymin=b, ymax=c)) 14.2.4.20 Crossbar z&lt;-data.frame(a=c(1,2,3,4), b=c(2,3,4,4)) ggplot() + geom_crossbar(data=z, aes(x=factor(a), ymin = b+2, ymax = b-2, y = b)) 14.2.4.21 Pointrange z&lt;-data.frame(a=c(1,2,3,4), b=c(2,3,4,4)) ggplot()+geom_pointrange(data=z, aes(x=a, ymin=b+2, ymax=b-2, y=b)) 14.2.4.22 Wykres termiczn require(ggplot2) data(diamonds) ggplot()+geom_bin2d(data=diamonds, aes(x=carat, y=price)) 14.2.4.23 Wykres gestosci 2D require(ggplot2) data(diamonds) ggplot()+geom_density2d(data=diamonds, aes(x=price, y=carat)) 14.2.4.24 dotplot require(ggplot2) data(diamonds) ggplot(mtcars, aes(x = mpg)) + geom_dotplot() library(gcookbook) # For the data set ggplot(heightweight, aes(x=sex, y=heightIn)) + geom_dotplot(binaxis=&quot;y&quot;, binwidth=.5, stackdir=&quot;center&quot;) 14.2.4.25 segment plot - przykład wykresu gannta dat &lt;- data.frame(person=c(&#39;sam&#39;,&#39;greg&#39;,&#39;teacher&#39;, &#39;sam&#39;), start=c(0,6,11,15), end=c(6,11,15,19)) library(ggplot2) ggplot(dat, aes(colour=person)) + geom_segment(aes(x=start, xend=end, y=person, yend=person), size=3) + xlab(&quot;Duration&quot;) 14.2.5 Piramida test &lt;- data.frame(v=sample(1:20,1000,replace=T), g=c(&#39;M&#39;,&#39;F&#39;)) # Then combined two geom_bar() calls separately for each of g values. For F counts are calculated as they are but for M counts are multiplied by -1 to get bar in opposite direction. Then scale_y_continuous() is used to get pretty values for axis. require(ggplot2) require(plyr) ggplot(data=test,aes(x=as.factor(v),fill=g)) + geom_bar(subset=.(g==&quot;F&quot;)) + geom_bar(subset=.(g==&quot;M&quot;),aes(y=..count..*(-1))) + scale_y_continuous(breaks=seq(-40,40,10),labels=abs(seq(-40,40,10))) + coord_flip() 14.2.6 ggplot-cieniowanie Prostokat: require(ggplot2) library(gcookbook) # For the data set p &lt;- ggplot(subset(climate, Source==&quot;Berkeley&quot;), aes(x=Year, y=Anomaly10y)) + geom_line() p + annotate(&quot;rect&quot;, xmin=1950, xmax=1980, ymin=-1, ymax=1, alpha=.1, fill=&quot;blue&quot;) Cieniowanie pod krzywa: require(ggplot2) # Return dnorm(x) for 0 &lt; x &lt; 2, and NA for all other x dnorm_limit &lt;- function(x) { y &lt;- dnorm(x) y[x &lt; 0 | x &gt; 2] &lt;- NA return(y) } # ggplot() with dummy data p &lt;- ggplot(data.frame(x=c(-3, 3)), aes(x=x)) p + stat_function(fun=dnorm_limit, geom=&quot;area&quot;, fill=&quot;blue&quot;, alpha=0.2) + stat_function(fun=dnorm) 14.2.7 ggplot-Adnotacje 14.2.7.1 Zwykłe adnotacje p &lt;- ggplot(faithful, aes(x=eruptions, y=waiting)) + geom_point() p + annotate(&quot;text&quot;, x=3, y=48, label=&quot;Group 1&quot;) + annotate(&quot;text&quot;, x=4.5, y=66, label=&quot;Group 2&quot;) 14.2.7.2 Adnotacje matematyczne p &lt;- ggplot(data.frame(x=c(-3,3)), aes(x=x)) + stat_function(fun = dnorm) p + annotate(&quot;text&quot;, x=2, y=0.3, parse=TRUE, label=&quot;frac(1, sqrt(2 * pi)) * e ^ {-x^2 / 2}&quot;) 14.2.7.3 Adnotacje po różnych facets require(ggplot2) p &lt;- ggplot(mpg, aes(x=displ, y=hwy)) + geom_point() + facet_grid(. ~ drv) # A data frame with labels for each facet f_labels &lt;- data.frame(drv = c(&quot;4&quot;, &quot;f&quot;, &quot;r&quot;), label = c(&quot;4wd&quot;, &quot;Front&quot;, &quot;Rear&quot;)) p + geom_text(x=6, y=40, aes(label=label), data=f_labels) # If you use annotate(), the label will appear in all facets p + annotate(&quot;text&quot;, x=6, y=42, label=&quot;label text&quot;) 14.2.7.4 Adnotacje jako kreski i strzałki library(gcookbook) # For the data set p &lt;- ggplot(subset(climate, Source==&quot;Berkeley&quot;), aes(x=Year, y=Anomaly10y)) + geom_line() p + annotate(&quot;segment&quot;, x=1950, xend=1980, y=-.25, yend=-.25) library(gcookbook) # For the data set p &lt;- ggplot(subset(climate, Source==&quot;Berkeley&quot;), aes(x=Year, y=Anomaly10y)) + geom_line() library(grid) p + annotate(&quot;segment&quot;, x=1850, xend=1820, y=-.8, yend=-.95, colour=&quot;blue&quot;, size=2, arrow=arrow()) + annotate(&quot;segment&quot;, x=1950, xend=1980, y=-.25, yend=-.25, arrow=arrow(ends=&quot;both&quot;, angle=90, length=unit(.2,&quot;cm&quot;))) 14.2.8 ggplot- szablony 14.2.8.1 Zmiana domyslnych ustawien themes Zmiana domyslnych ustawien dla themes w ggplot2: #Zmiana dziala az to zrestartowania R-a. require(ggplot2) ble&lt;-theme_set(theme_bw()) ble&lt;-theme_update( panel.border=element_rect(colour=&quot;black&quot;, fill=NA, size=2), panel.grid.major=element_line(colour=rgb(.4,.4,.4), size=.3, linetype=1), axis.title.y=element_text(face=&quot;bold&quot;, size=14), axis.title.x=element_text(face=&quot;bold&quot;, size=13) , axis.text.x=element_text(colour=rgb(.0,.0,.0), size=12, face=&quot;bold&quot;), axis.text.y=element_text(colour=rgb(.0,.0,.0), size=12, face=&quot;bold&quot;) , panel.background=element_rect(fill=rgb(.99,.99,.99)), legend.text=element_text(size=5), legend.title=element_text(size=10), strip.text.x=element_text(size=5)) data(diamonds) ggplot() + geom_histogram(data=diamonds, aes(x=cut)) ggplot()+geom_density(data=diamonds, aes(x=cut)) ggplot()+geom_bar(data=diamonds, aes(x=cut)) #rozkminic roznice miedzym funkcjami: #theme_update() #theme_get() #theme_set(new) 14.2.8.2 Szablony z pakietu ggthemes require(ggplot2) require(ggthemes) data(diamonds) ggplot()+geom_density(data=diamonds, aes(x=x)) + theme_economist() ggplot()+geom_density(data=diamonds, aes(x=x)) + theme_economist_white() ggplot()+geom_density(data=diamonds, aes(x=x)) + theme_excel() ggplot()+geom_density(data=diamonds, aes(x=x)) + theme_few() ggplot()+geom_density(data=diamonds, aes(x=x)) + theme_foundation() ggplot()+geom_density(data=diamonds, aes(x=x)) + theme_igray() ggplot()+geom_density(data=diamonds, aes(x=x)) + theme_solarized() ggplot()+geom_density(data=diamonds, aes(x=x)) + theme_stata() ggplot()+geom_density(data=diamonds, aes(x=x)) + theme_tufte() ggplot()+geom_density(data=diamonds, aes(x=x)) + theme_wsj() 14.2.8.3 Slynny niebieski kolor dob&lt;-&#39;rgb( 37/256 , 164/256 , 40/256 )&#39; require(ggplot2) data(diamonds) f&lt;-rgb(8/256,96/256,186/256) ggplot()+geom_density(data=diamonds, aes(x=carat), fill=f, size=1) + theme( panel.border=element_rect(colour=&quot;black&quot;, fill=NA, size=2), panel.grid.major=element_line(colour=rgb(.4,.4,.4), size=.3, linetype=1), axis.title.y=element_text(face=&quot;bold&quot;, size=14), axis.title.x=element_text(face=&quot;bold&quot;, size=13) , axis.text.x=element_text(colour=rgb(.0,.0,.0), size=12, face=&quot;bold&quot;), axis.text.y=element_text(colour=rgb(.0,.0,.0), size=12, face=&quot;bold&quot;) , panel.background=element_rect(fill=rgb(.99,.99,.99)), legend.text=element_text(size=5), legend.title=element_text(size=10), strip.text.x=element_text(size=5)) + labs(fill=&quot;&quot;) 14.3 lattice # LATTICE podstawowe prakiety graiczne---- require(ggplot2) require(lattice) require(latticeExtra) d&lt;-diamonds #podstawowe wykresy histogram(~x, d, breaks=100) densityplot(~x, d, bw=0.1 ) xyplot(x~y, d, pch=10) parallelplot(~d[1:1000,c(&#39;cut&#39;,&#39;color&#39;,&#39;x&#39;)], d) #dla jakosciowych i ilosciowych bwplot(x~cut, d) barchart(c(1,2,3,4)~c(2,3,4,3)) dotplot(cut ~ price, d[1:50,] ) qqmath(x~y, d) qq() #?? levelplot(~cut, d) #?? contourplot cloud wireframe splom rfs # skladnia formuly histogram(~x|cut, d) histogram(~x|cut+color, d, subset=(color%in%c(&quot;D&quot;, &quot;E&quot;))) #ponizsze skladnie sa rownowazne histogram(~x|cut+color, d, subset=(color%in%c(&quot;D&quot;, &quot;E&quot;))) histogram(~x|cut*color, d, subset=(color%in%c(&quot;D&quot;, &quot;E&quot;))) xyplot(x~y, d,groups=cut) # ustawienia paretrow pch - wielkosc kropek bw - dokladnosc dopasowania wykresy gestosci breaks - szerokosc bloczka w histogramie layout - rozmieszczenie elementow (np: layout=c(2,3) ) subset - podzbior (np. subset=(price&gt;3000 &amp; cut %in% c(&#39;a&#39;,&#39;b&#39;)) ) groups - grupowanie kolorystyczne wykresu (nie dziala dla histogramu) 14.4 p:rgl 14.4.1 Wykresy 3D-ogolne zasady #primitive require(rgl) rgl.points(x=c(1,3,6),y=c(2,4,1),z=c(5,7,4), color=&#39;red&#39;, size=10) #tworze wykres z trzema punktami axes3d( labels=F) #dodaje osie. title3d(main=&#39;wykres&#39;, xlab=&#39;x&#39;, ylab=&#39;y&#39;, zlab=&#39;z&#39;, color=&#39;blue&#39;) #dodajem tytul wykresu oraz osi rgl.lines(x=c(1,2), y=c(3,2), z=c(4,3)) #dodaje odcinek rgl.triangles(x=c(1,2,2), y=c(3,2,1), z=c(4,3,4), color=&#39;yellow&#39;) #dodaje płytke rgl.quads(x=c(1,2,2,1), y=c(3,2,1,4), z=c(4,3,4,5), color=&#39;yellow&#39;) rgl.texts(x=c(1,2) ,y=c(2,3), z=c(4,5) , text=c(&#39;a&#39;, &#39;b&#39;)) rgl.spheres(x=c(1,2) ,y=c(2,3), z=c(4,5), r=c(1,2), color=c(&#39;red&#39;)) #surface x&lt;-c(1,2,3,4) z&lt;-c(1,2,3,4) y&lt;-matrix(c(1:16), ncol=4) rgl.surface(x=x, y=y, z=z) #wersja z kolorem x&lt;-c(1,2,3,4) z&lt;-c(1,2,3,4) y&lt;-matrix(c(1:16), ncol=4) ylim &lt;- range(y) #zakres wartosci y (wysokosci) ylen &lt;- ylim[2] - ylim[1] + 1 #dlugosc zakresu wartosci y colorlut &lt;- terrain.colors(ylen) # height color lookup table col &lt;- colorlut[ y-ylim[1]+1 ] # assign colors to heights for each point rgl.surface(x=x, y=y, z=z, color=col) rgl.pop() #usuwa ostatnio dodany element rgl.clear() #czysci okno #plot3d require(rgl) x &lt;- rnorm(100) y &lt;- rnorm(100) z &lt;- 0.2*x - 0.3*y + rnorm(100, sd=0.3) fit &lt;- lm(z ~ x + y) plot3d(x,y,z, type=&#39;s&#39;, col=&#39;red&#39;, size=1) coefs &lt;- coef(fit) a &lt;- coefs[&#39;x&#39;] b &lt;- coefs[&#39;y&#39;] c &lt;- -1 d &lt;- coefs[&#39;(Intercept)&#39;] planes3d(a, b, c, d, alpha=0.5) #4 wielkosci bo rownanie w postaci a x + b y + c z + d = 0 planes3d(2, 1, 1, 1, alpha=0.5) open3d() 14.4.2 Wykres gestosci Czarnobialy #wykres gestosci pod rgl require(graphics) x &lt;- rnorm(1000) y &lt;- 2 + x*rnorm(1000,1,.1) + rnorm(1000) library(MASS) den3d &lt;- kde2d(x, y) length(den3d[[3]]) require(rgl) x&lt;-den3d[[1]] z&lt;-den3d[[2]] y&lt;-matrix(den3d[[3]], ncol=length(x)) rgl.surface(x=x, y=y, z=z) Kolorowy #wykres gestosci pod rgl require(graphics) x &lt;- rnorm(1000) y &lt;- 2 + x*rnorm(1000,1,.1) + rnorm(1000) library(MASS) den3d &lt;- kde2d(x, y) length(den3d[[3]]) require(rgl) x&lt;-den3d[[1]] z&lt;-den3d[[2]] y&lt;-matrix(den3d[[3]]*10, ncol=length(x)) #pomnozone przez 10 zeby przeskalowac ylim &lt;- range(y) #zakres wartosci y (wysokosci) ylen &lt;- ylim[2] - ylim[1] + 1 #dlugosc zakresu wartosci y colorlut &lt;- terrain.colors(ylen) # height color lookup table col &lt;- colorlut[ y-ylim[1]+1 ] # assign colors to heights for each point rgl.surface(x=x, y=y, z=z, color=col) 14.4.3 histogram 3D w rgl library(rgl) demo(hist3d) ##### Required functions &#39;binplot&#39; and &#39;hist3d&#39;: binplot.3d&lt;-function(x,y,z,alpha=1,topcol=&quot;#ff0000&quot;,sidecol=&quot;#aaaaaa&quot;) { save &lt;- par3d(skipRedraw=TRUE) on.exit(par3d(save)) #wpolczedne bloczkow histogramu x1&lt;-c(rep(c(x[1],x[2],x[2],x[1]),3),rep(x[1],4),rep(x[2],4)) z1&lt;-c(rep(0,4),rep(c(0,0,z,z),4)) y1&lt;-c(y[1],y[1],y[2],y[2],rep(y[1],4),rep(y[2],4),rep(c(y[1],y[2],y[2],y[1]),2)) x2&lt;-c(rep(c(x[1],x[1],x[2],x[2]),2),rep(c(x[1],x[2],rep(x[1],3),rep(x[2],3)),2)) z2&lt;-c(rep(c(0,z),4),rep(0,8),rep(z,8) ) y2&lt;-c(rep(y[1],4),rep(y[2],4),rep(c(rep(y[1],3),rep(y[2],3),y[1],y[2]),2) ) rgl.quads(x1,z1,y1,col=rep(sidecol,each=4),alpha=alpha) rgl.quads(c(x[1],x[2],x[2],x[1]),rep(z,4),c(y[1],y[1],y[2],y[2]), + col=rep(topcol,each=4),alpha=1) rgl.lines(x2,z2,y2,col=&quot;#000000&quot;) } hist3d&lt;-function(x,y=NULL,nclass=&quot;auto&quot;,alpha=1,col=&quot;#ff0000&quot;,scale=10) { save &lt;- par3d(skipRedraw=TRUE) on.exit(par3d(save)) xy &lt;- xy.coords(x,y) x &lt;- xy$x y &lt;- xy$y n&lt;-length(x) if (nclass == &quot;auto&quot;) { nclass&lt;-ceiling(sqrt(nclass.Sturges(x))) } breaks.x &lt;- seq(min(x),max(x),length=(nclass+1)) breaks.y &lt;- seq(min(y),max(y),length=(nclass+1)) z&lt;-matrix(0,(nclass),(nclass)) for (i in 1:nclass) { for (j in 1:nclass) { z[i, j] &lt;- (1/n)*sum(x &lt; breaks.x[i+1] &amp; y &lt; breaks.y[j+1] &amp; x &gt;= breaks.x[i] &amp; y &gt;= breaks.y[j]) binplot.3d(c(breaks.x[i],breaks.x[i+1]),c(breaks.y[j],breaks.y[j+1]), scale*z[i,j],alpha=alpha,topcol=col) } } } 14.4.4 rgl-rozszerzenia 14.4.4.1 evd library(rgl) library(evd) data(lossalae) U=rank(lossalae[,1]+rnorm(nrow(lossalae), mean=0,sd=.001))/(nrow(lossalae)+1) V=rank(lossalae[,2])/(nrow(lossalae)+1) M=kde2d(qnorm(U),qnorm(V),n=35) library(rgl) persp3d(M$x,M$y,M$z,col=&#39;green&#39;, xlab=&quot;loss&quot;,ylab=&quot;alae&quot;,zlab=&quot;&quot;) 14.4.4.2 plot3Drgl Examples from manual ## ======================================================================= ## perspective plots ## ======================================================================= persp3Drgl(z = volcano, contour = list(side = &quot;zmax&quot;)) # ribbon, in x--direction V &lt;- volcano[seq(1, nrow(volcano), by = 5), seq(1, ncol(volcano), by = 5)] # lower resolution ribbon3Drgl(z = V, ticktype = &quot;detailed&quot;) hist3Drgl(z = V, col = &quot;grey&quot;, border = &quot;black&quot;, lighting = TRUE) ## Not run: cutrgl() # select a rectangle uncutrgl() ## End(Not run) ## ======================================================================= ## scatter points ## ======================================================================= with(quakes, scatter3Drgl(x = long, y = lat, z = -depth, colvar = mag, cex = 3)) plotdev() # plots same on oridinary device... ## ======================================================================= ## 3D surface ## ======================================================================= M &lt;- mesh(seq(0, 2*pi, length.out = 50), seq(0, 2*pi, length.out = 50)) u &lt;- M$x ; v &lt;- M$y x &lt;- sin(u) y &lt;- sin(v) z &lt;- sin(u + v) # alpha makes colors transparent surf3Drgl(x, y, z, colvar = z, border = &quot;black&quot;, smooth = TRUE, alpha = 0.2) ## ======================================================================= ## volumetric data ## ======================================================================= x &lt;- y &lt;- z &lt;- seq(-4, 4, by = 0.2) M &lt;- mesh(x, y, z) R &lt;- with (M, sqrt(x^2 + y^2 + z^2)) p &lt;- sin(2*R) /(R+1e-3) slice3Drgl(x, y, z, colvar = p, col = jet.col(alpha = 0.5), xs = 0, ys = c(-4, 0, 4), zs = NULL, d = 2) 14.5 ggvis #instalacja pakietu #devtools::install_github(&quot;hadley/testthat&quot;) #devtools::install_github(&quot;rstudio/ggvis&quot;) # require(ggvis) #lista dem w pakiecie # demo(package=&#39;ggvis&#39;) "],
["other-packages.html", "Chapter 15 OTHER PACKAGES 15.1 Wykres Gantta 15.2 ROCR 15.3 qualityTools 15.4 tabplot 15.5 vcd 15.6 sparkTable 15.7 ade4 15.8 arcdiagram 15.9 wykres balonowy 15.10 p:networkD3 15.11 WAZNE-wykres do wizualizacji dyskryminacji (np. w knn) 15.12 ciekawy wykres gestosci 15.13 fajna krzywa ROC 15.14 histogram z bloczkami o rownej LICZEBNOSCI 15.15 odds ratio plot 15.16 wykres gantta 15.17 wykres balonowy w tabelce 15.18 paralel plot. Nim chyba mozna wartosci nietypowe wykrywac 15.19 HiveR 15.20 muir 15.21 listviewer", " Chapter 15 OTHER PACKAGES 15.1 Wykres Gantta require(plotrix) Ymd.format &lt;- &quot;%Y/%m/%d&quot; Ymd &lt;- function(x){ as.POSIXct(strptime(x, format=Ymd.format))} gantt.info &lt;- list( labels =c(&quot;First task&quot;,&quot;Second task&quot;,&quot;Third task&quot;,&quot;Fourth task&quot;,&quot;Fifth task&quot;), starts =Ymd(c(&quot;2004/01/01&quot;,&quot;2004/02/02&quot;,&quot;2004/03/03&quot;,&quot;2004/05/05&quot;,&quot;2004/09/09&quot;)), ends =Ymd(c(&quot;2004/03/03&quot;,&quot;2004/05/05&quot;,&quot;2004/05/05&quot;,&quot;2004/08/08&quot;,&quot;2004/12/12&quot;)), priorities =c(1,2,3,4,5)) gantt.chart(gantt.info,main=&quot;Calendar date Gantt chart&quot;) 15.1.1 Piramida #wartosci zmiennej dla mezczyzn xy.pop&lt;-c(3.2,3.5,3.6,3.6,3.5,3.5,3.9,3.7,3.9,3.5,3.2,2.8,2.2,1.8,1.5,1.3,0.7,0.4) #wartosci zmiennej dla kobiet xx.pop&lt;-c(3.2,3.4,3.5,3.5,3.5,3.7,4,3.8,3.9,3.6,3.2,2.5,2,1.7,1.5,1.3,1,0.8) #przedzialy wiekowe agelabels&lt;-c(&quot;0-4&quot;,&quot;5-9&quot;,&quot;10-14&quot;,&quot;15-19&quot;,&quot;20-24&quot;,&quot;25-29&quot;,&quot;30-34&quot;, &quot;35-39&quot;,&quot;40-44&quot;,&quot;45-49&quot;,&quot;50-54&quot;,&quot;55-59&quot;,&quot;60-64&quot;,&quot;65-69&quot;,&quot;70-74&quot;, &quot;75-79&quot;,&quot;80-44&quot;,&quot;85+&quot;) mcol&lt;-color.gradient(c(0,0,0.5,1),c(0,0,0.5,1),c(1,1,0.5,1),18) fcol&lt;-color.gradient(c(1,1,0.5,1),c(0.5,0.5,0.5,1),c(0.5,0.5,0.5,1),18) par(mar=pyramid.plot(xy.pop,xx.pop,labels=agelabels, main=&quot;Australian population pyramid 2002&quot;,lxcol=mcol,rxcol=fcol,gap=0.5,show.values=TRUE)) # three column matrices avtemp&lt;-c(seq(11,2,by=-1),rep(2:6,each=2),seq(11,2,by=-1)) malecook&lt;-matrix(avtemp+sample(-2:2,30,TRUE),ncol=3) femalecook&lt;-matrix(avtemp+sample(-2:2,30,TRUE),ncol=3) # use a background color par(bg=&quot;#eedd55&quot;) # group by age agegrps&lt;-c(&quot;0-10&quot;,&quot;11-20&quot;,&quot;21-30&quot;,&quot;31-40&quot;,&quot;41-50&quot;,&quot;51-60&quot;,&quot;61-70&quot;,&quot;71-80&quot;,&quot;81-90&quot;,&quot;91+&quot;) oldmar&lt;-pyramid.plot(malecook,femalecook,labels=agegrps,unit=&quot;Bowls per month&quot;,lxcol=c(&quot;#ff0000&quot;,&quot;#eeee88&quot;,&quot;#0000ff&quot;), rxcol=c(&quot;#ff0000&quot;,&quot;#eeee88&quot;,&quot;#0000ff&quot;),laxlab=c(0,10,20,30), raxlab=c(0,10,20,30),top.labels=c(&quot;Males&quot;,&quot;Age&quot;,&quot;Females&quot;),gap=3) # put a box around it box() # give it a title mtext(&quot;Porridge temperature by age and sex of cook&quot;,3,2,cex=1.5) # stick in a legend legend(par(&quot;usr&quot;)[1],11,c(&quot;Too hot&quot;,&quot;Just right&quot;,&quot;Too cold&quot;), fill=c(&quot;#ff0000&quot;,&quot;#eeee88&quot;,&quot;#0000ff&quot;)) # don&#39;t forget to restore the margins and background par(mar=oldmar,bg=&quot;transparent&quot;) 15.2 ROCR 15.2.1 Krzywa roc z bajerami library(ROCR) # plot ROC curves for several cross-validation runs (dotted # in grey), overlaid by the vertical average curve and boxplots # showing the vertical spread around the average. data(ROCR.xval) pred &lt;- prediction(ROCR.xval$predictions, ROCR.xval$labels) perf &lt;- performance(pred,&quot;tpr&quot;,&quot;fpr&quot;) plot(perf,col=&quot;grey82&quot;,lty=3) plot(perf,lwd=1,avg=&quot;vertical&quot;,spread.estimate=&quot;boxplot&quot;,add=TRUE) 15.3 qualityTools #wykres diagnostyczny require(qualityTools) set.seed (1234) #generate some data norm = rnorm(20 , mean = 20) #generate some data weib = rweibull (20 , shape = 2, scale = 8) #process capability pcr(norm, &quot;normal&quot; , lsl = 17, usl = 23) #process cabapility # pcr(weib , &quot; weibull &quot; , usl = 20) &lt;small class=&#39;s1&#39;&gt;cos nie dziala&lt;/small&gt; 15.3.1 Wykres Pareto #wykres pareto require(qualityTools) #create artificial defect data set defects = c(rep(&quot;E&quot; , 62) , rep(&quot;B&quot; , 15) , rep(&quot;F&quot; , 3) , rep(&quot;A&quot; , 10) , rep(&quot;C&quot; ,20) , rep(&quot;D&quot; , 10)) paretoChart( defects ) 15.4 tabplot #wizualizacja duzych zbiorow danych (tabplot)---- )(zobaczy tez itableplot) require(tabplot) #nie mylic z pakietem &#39;tableplot&#39; require(ggplot2) data(diamonds) tableplot(diamonds) 15.5 vcd Wykres mozaikowy library(vcd) #przyklad z ladowaniem gotowej tablicy kontyngencji-nie trzeba tu tworzyc formuly mosaic( x=HairEyeColor, #dane jako gotowa tabela kontyngencji w formacie array. Opcjonalnie nazwy zmiennych jako dimnames przypisane array. W tym przypadku zmienna HairEyeColor to miacierz trojwymiarowa shade=T, #czy kolorowac prostokaty #formula=Sex~Eye, #wzgledem jakich zmiennych tablica kontyngencji.#nie wiem jak to dziala przy gotowych tablicach kontyngencji. Lepiej nie uzywac legend=TRUE, main=&#39;wykres mozaikowy&#39;, #tytul wykresu, sub=&#39;wykresik&#39;, #podtytul wykresu ) #czy dodac legende. Opcje funkcji legend patrz Biecek strona 256 (nie wiem czy bedzie z tym wykresem dzialac) #przyklad z ladowanymi surowymi danymi library(vcd) data(&#39;Arthritis&#39;) z&lt;-transform(Arthritis, Age=cut(Arthritis[,&#39;Age&#39;], breaks=c(0, 20, 40, 150))) z$a&lt;-c(rep(c(1,2), each=42)) mosaic( #formula=Improved ~ Treatment | Sex, #formula=Improved~Treatment, #formula=Improved ~ Treatment + Sex + Age + a, formula=Improved ~ Treatment + Age + Sex + a, #shade=TRUE, #koloroW i legendy na razie nie bedzie-skomplikowana kwestia #legend=TRUE, data=z, #surowe dane jako data.frame lub table #subset=... , wyszczegolnienie podzbioru danych na.action = na.omit, #co robic z brakami danych, na.omit, na.fail, na.pass, na.excule zero.shade=F, #czy kwadraty zerowe (zero obserwacji) powinny byc kolorowane zero.size=0) #rozmiar kwadratow zerowych 15.6 sparkTable Pakiet sluzy do rysowania tzw. spark charts, czyli wykresow w komorkach tabel. Analigoczne rozwiazania oferuje np. Excel od wersji 2010. Pakiet umozliwia wyswietlanie wykresów w PDF i HTML, co zaprezentowano ponizej. require(sparkTable) #zbior danych data(pop) #generuje puste obiekty w ktorych beda przechowywane wykresy (struktury danych opisujece wykresy) b &lt;- newSparkBox() l &lt;- newSparkLine() bb &lt;- newSparkBar() #generuje strukture tabeli. W kolumnach sa wygenerowane wczesniej obiekty na wykresy lub funkcje przeksztalcające badana zmienna content &lt;- list(function(x) { round(mean(x),2) }, b,l,bb, function(x) { round(tail(x,1),2) }) #nazwy kolumn w w tabeli ktora bedzie wyswietlana names(content) &lt;- paste(&quot;column&quot;,1:5,sep=&quot;&quot;) #(chyba) nazwy podobiektow (obiekt glowny bedzie utworzony dalej), w ktorych sa elementy potrzebne do tabeli varType &lt;- rep(&quot;value&quot;,5) #wyciaganie zmiennych ze zbioru ktore sa potrzebne pop &lt;- pop[,c(&quot;variable&quot;,&quot;value&quot;,&quot;time&quot;)] #przeksztalcenie zmienna czasowej na typ liczbowy pop$time &lt;- as.numeric(as.character(pop$time)) #przygotowanie ostatecznej struktury danych xx &lt;- reshapeExt(pop, #zbior danych idvar=&quot;variable&quot;, #zmienna grupujaca varying=list(2)) #zmienna badana a nie zmienna czasowa (jak to chyba jest w zwyklym reshape) #utworzenie tabeli x1 &lt;- newSparkTable(xx, content, varType) # showSparkTable(x1) 15.7 ade4 15.7.1 Reczne rysowanie bardziej wypasionych drzew (PAKIET ade4)—- require(ade4) provi.tre &lt;- &quot;( ((a,b,c,d,e)A,(f,g,h)B) C, ((i\\njkj,j)k,l) G )D;&quot; #uwaga. nie wolno powtarzac nazw liter bo sie pomiesza!!! provi.phy &lt;- newick2phylog(provi.tre) ade4::plot.phylog(provi.phy, clabel.l = 1.2, #wielkosc znakow w lisciach clabel.n = .9, #wielkosc znakow na wezlach f = .6, ) #dlugosc galezi drzewa 15.8 arcdiagram Wykres lukowy # wykres lukowy # install devtools install.packages(&quot;devtools&quot;) # load devtools library(devtools) # install arcdiagram install_github(&#39;arcdiagram&#39;, username=&#39;gastonstat&#39;) # load arcdiagram library(arcdiagram) # location of &#39;gml&#39; file mis_file = &quot;F:/Manuale/Manual do R-a/dane/lesmiserables.txt&quot; # read &#39;gml&#39; file mis_graph = read.graph(mis_file, format=&quot;gml&quot;) # get edgelist edgelist = get.edgelist(mis_graph) # get vertex labels vlabels = get.vertex.attribute(mis_graph, &quot;label&quot;) # get vertex groups vgroups = get.vertex.attribute(mis_graph, &quot;group&quot;) # get vertex fill color vfill = get.vertex.attribute(mis_graph, &quot;fill&quot;) # get vertex border color vborders = get.vertex.attribute(mis_graph, &quot;border&quot;) # get vertex degree degrees = degree(mis_graph) # get edges value values = get.edge.attribute(mis_graph, &quot;value&quot;) # load reshape library(reshape) # data frame with vgroups, degree, vlabels and ind x = data.frame(vgroups, degrees, vlabels, ind=1:vcount(mis_graph)) # arranging by vgroups and degrees y = arrange(x, desc(vgroups), desc(degrees)) # get ordering &#39;ind&#39; new_ord = y$ind # plot arc diagram arcplot(edgelist, ordering=new_ord, labels=vlabels, cex.labels=0.8, show.nodes=TRUE, col.nodes=vborders, bg.nodes=vfill, cex.nodes = log(degrees)+0.5, pch.nodes=21, lwd.nodes = 2, line=-0.5, col.arcs = hsv(0, 0, 0.2, 0.25), lwd.arcs = 1.5 * values) 15.9 wykres balonowy #ladny wykres balonowy crime &lt;- read.csv(&quot;http://datasets.flowingdata.com/crimeRatesByState2005.tsv&quot;, header=TRUE, sep=&quot;\\t&quot;) symbols(crime$murder, crime$burglary, circles=crime$population) radius &lt;- sqrt( crime$population/ pi ) symbols(crime$murder, crime$burglary, circles=radius) symbols(crime$murder, crime$burglary, circles=radius, inches=0.35, fg=&quot;white&quot;, bg=&quot;red&quot;, xlab=&quot;Murder Rate&quot;, ylab=&quot;Burglary Rate&quot;) text(crime$murder, crime$burglary, crime$state, cex=0.5) symbols(crime$murder, crime$burglary, squares=sqrt(crime$population), inches=0.5) text(crime$murder, crime$burglary, crime$state, cex=0.5) 15.10 p:networkD3 15.11 WAZNE-wykres do wizualizacji dyskryminacji (np. w knn) # library(klaR) data(iris) iris2 &lt;- iris levels(iris2$species) &lt;- c(&#39;s&#39;,&#39;e&#39;,&#39;v&#39;) # otherwise v*e*rsicolor are mixed ip with *v*irginica partimat(species ~ ., data = iris2, method = &quot;qda&quot;, mar=c(4,4,2,1)) data(iris) partimat(species ~ ., data = iris, method = &quot;lda&quot;) 15.12 ciekawy wykres gestosci require(hdrcde) data(faithful) faithful.cde &lt;- cde(faithful$waiting,faithful$eruptions) plot(faithful.cde,xlab=&quot;Waiting time&quot;,ylab=&quot;Duration time&quot;,plot.fn=&quot;hdr&quot;) points(faithful$waiting,faithful$eruptions, pch=&quot;+&quot;, col=&quot;yellow&quot;) 15.13 fajna krzywa ROC library(ROCR) # plot ROC curves for several cross-validation runs (dotted # in grey), overlaid by the vertical average curve and boxplots # showing the vertical spread around the average. data(ROCR.xval) pred &lt;- prediction(ROCR.xval$predictions, ROCR.xval$labels) perf &lt;- performance(pred,&quot;tpr&quot;,&quot;fpr&quot;) plot(perf,col=&quot;grey82&quot;,lty=3) plot(perf,lwd=1,avg=&quot;vertical&quot;,spread.estimate=&quot;boxplot&quot;,add=TRUE) 15.14 histogram z bloczkami o rownej LICZEBNOSCI set.seed(65) x &lt;- rnorm(500) breaks &lt;- quantile(x, 0:20/20) hist(x, breaks = breaks, col = &quot;#ffc38a&quot;, border = &quot;#5FAE27&quot;, main = &quot;Histogram with equal counts&quot;) # add a kernel density estimator of x lines(density(x), col = &#39;#3F489D&#39;, lty = &#39;1318&#39;, lwd=2) # add a box around the plot box() 15.15 odds ratio plot require(vcd) data(CoalMiners) l &lt;- oddsratio(CoalMiners) g &lt;- seq(25, 60, by = 5) plot(l, xlab = &quot;Age Group&quot;, main = &quot;Breathelessness and Wheeze in Coal Miners&quot;) m &lt;- lm(l ~ g + I(g^2)) lines(fitted(m), col = &quot;red&quot;) 15.16 wykres gantta ### failed to highlight code require(plotrix) Ymd.format &lt;- &quot;%Y/%m/%d&quot; Ymd &lt;- function(x){ as.POSIXct(strptime(x, format=Ymd.format))} gantt.info &lt;- list( labels =c(&quot;First task&quot;,&quot;Second task&quot;,&quot;Third task&quot;,&quot;Fourth task&quot;,&quot;Fifth task&quot;), starts =Ymd(c(&quot;2004/01/01&quot;,&quot;2004/02/02&quot;,&quot;2004/03/03&quot;,&quot;2004/05/05&quot;,&quot;2004/09/09&quot;)), ends =Ymd(c(&quot;2004/03/03&quot;,&quot;2004/05/05&quot;,&quot;2004/05/05&quot;,&quot;2004/08/08&quot;,&quot;2004/12/12&quot;)), priorities =c(1,2,3,4,5)) gantt.chart(gantt.info,main=&quot;Calendar date Gantt chart&quot;) 15.17 wykres balonowy w tabelce require(gplots) carnames &lt;- c(&quot;bmw&quot;,&quot;renault&quot;,&quot;mercedes&quot;,&quot;seat&quot;) carcolors &lt;- c(&quot;red&quot;,&quot;white&quot;,&quot;silver&quot;,&quot;green&quot;) datavals &lt;- round(rnorm(16, mean=100, sd=60),1) data &lt;- data.frame(Car=rep(carnames,4), Color=rep(carcolors, c(4,4,4,4) ), Value=datavals ) levels(data$Car) &lt;- c(&quot;BMW: \\nHigh End,\\n German&quot;,&quot;Renault: \\nMedium End,\\n French&quot;, &quot;Mercedes:\\n High End,\\n German&quot;, &quot;Seat:\\n Imaginary,\\n Unknown Producer&quot;) # generate balloon plot with default scaling balloonplot( data$Car, data$Color, data$Value, ylab =&quot;Color&quot;, xlab=&quot;Car&quot;) 15.18 paralel plot. Nim chyba mozna wartosci nietypowe wykrywac require(MASS) data(iris3) ir &lt;- rbind(iris3[,,1], iris3[,,2], iris3[,,3]) parcoord(log(ir)[, c(3, 4, 2, 1)], col = 1 + (0:149)%/%50) 15.19 HiveR # HiveR require(HiveR) set.seed(31) require(bipartite) data(Safariland) # You may wish to do ?Safariland or ?Safari for background hive1 &lt;- adj2HPD(Safariland, desc = &quot;Safariland data set from bipartite&quot;) sumHPD(hive1) # Note that all nodes are one axis with radius 1. Process further: hive2 &lt;- mineHPD(hive1, option = &quot;rad &lt;- tot.edge.count&quot;) sumHPD(hive2) # All nodes still on 1 axis but degree has been used to set radius # Process further: hive3 &lt;- mineHPD(hive2, option = &quot;axis &lt;- source.man.sink&quot;) sumHPD(hive3, chk.all = TRUE) # Note that mineHPD is generating some warnings, telling us # that the first 9 nodes were not assigned to an axis. Direct # inspection of the data shows that these nodes are insects # that did not visit any of the flowers in this particular study. # Pretty up a few things, then plot: hive3$edges$weight &lt;- sqrt(hive3$edges$weight)*0.5 hive3$nodes$size &lt;- 0.5 plotHive(hive3) 15.20 muir require(muir) # wszystkie kategorie muir(l.dt(diamonds), tree.dir = &#39;TB&#39;, #kierunki: LR, RL, TB, BT node.levels = c(&#39;cut:*&#39;,&#39;color:*&#39;), label.vals=c(&#39;mean(price, na.rm=TRUE): srednia cena&#39;), tree.height = 800, tree.width = 600) # wszysktie kategorie dla cut i color muir(l.dt(diamonds), node.limit = 2, node.levels = c(&#39;cut:*&#39;,&#39;color:*&#39;), label.vals=c(&#39;mean(price): srednia cena&#39;), tree.height = 800, tree.width = 600) # dwie najliczniejsze kategorie dla cut a dla color 2 najliczniejsze kategirie i reszta kategorii to jednego wora (kategoria &quot;other&quot;) muir(l.dt(diamonds), node.levels = c(&#39;cut:2&#39;,&#39;color:2+&#39;), label.vals=c(&#39;mean(price): srednia cena&#39;), tree.height = 800, tree.width = 600) # filtr na jedna ze zmiennych ( na razie nie dziala %in%). Jezeli chce rbic automat to najlepiej wczesniej przekodowac dane w zbiore. Tutaj narzedzia z kryteriami sa raczej jako narzedzie reczne. criteria &lt;- data.frame(col=c(&quot;cut&quot;), oper=c(&#39;%like%&#39;), val=c(&#39;Ide&#39;), title=c(&#39;Ide&#39;)) muir(l.dt(diamonds), node.levels = c(&#39;cut:+&#39;,&#39;color:*&#39;), label.vals=c(&#39;mean(price): srednia cena&#39;), level.criteria = criteria, tree.height = 800, tree.width = 600) 15.21 listviewer require(listviewer) l1 &lt;- list(a=10, b=list(c=20, d=list(e=100))) listviewer::jsonedit(l1) l2 &lt;- list(10, list(20, list(100))) listviewer::jsonedit(l) "],
["plots-graphs.html", "Chapter 16 PLOTS GRAPHS 16.1 p:Diagrammer’, type=‘new’ 16.2 p:networkD3 16.3 network 16.4 p:igraph 16.5 p:edgebundleR 16.6 wizualizacja korelacji p:ggraph", " Chapter 16 PLOTS GRAPHS 16.1 p:Diagrammer’, type=‘new’ 16.1.1 graph from data.table edges &lt;- DiagrammeR::create_edges(from = c(&#39;a&#39;, &#39;b&#39;), to = c(&#39;b&#39;, &#39;c&#39;), ) nodes &lt;- DiagrammeR::create_nodes(nodes=c(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;), shape=c(&#39;circle&#39;,&#39;rectangle&#39;,&#39;square&#39;), tooltip=c(&#39;ala ma kota&#39;, &#39;ble&#39;, &#39;dupa&#39;)) graph &lt;- create_graph(nodes_df = nodes, edges_df = edges) DiagrammeR::render_graph(graph) create_nodes(nodes = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;), label = FALSE, type = &quot;lower&quot;, style = &quot;filled&quot;, color = &quot;aqua&quot;, shape = c(&quot;circle&quot;, &quot;circle&quot;, &quot;rectangle&quot;, &quot;rectangle&quot;), data = c(3.5, 2.6, 9.4, 2.7)) 16.1.2 graph manually created require(DiagrammeR) boxes_and_circles &lt;- &quot; digraph boxes_and_circles { # several &#39;node&#39; statements node [shape = box, color = blue] A; B; C node [shape = box, color = black, fontsize = 18, fontcolor = yellow] D; E; F node [shape = circle, fixedsize = true, width = 0.9] // sets as circles 1; 2; 3; 4; 5; 6; 7; 8 # several &#39;edge&#39; statements A-&gt;1; B-&gt;2; B-&gt;3; B-&gt;4; C-&gt;A 1-&gt;D; E-&gt;A; 2-&gt;4; 1-&gt;5; 1-&gt;F E-&gt;6; 4-&gt;6; 5-&gt;7; 6-&gt;7; 3-&gt;8 [color = green] # a &#39;graph&#39; statement graph [overlap = true] } &quot; grViz(boxes_and_circles) 16.2 p:networkD3 16.2.1 sankeyPlot require(networkD3) # definiowanie polaczen. Numery zaczyaja sie od 0!. Numery koresponcuja z kolejnoscia wezlow zdefiniowanych w zmiennej z wezlami. links &lt;- data.frame(from=c(0,0,1,2), to=c(1,2,2,3), value=c(10,15,20,25)) nodes &lt;- data.frame(name=c(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;), group=c(1,1,2,2)) sankeyNetwork(Links = links, # data.frame z imformajami o polaczeniach Nodes = nodes, # ramka danych z informacjami o wezlach Source = &#39;from&#39;, # nazwa zmiennej z ramki z linkami dla poczatku polaczenia Target = &#39;to&#39;, # nazwa zmiennej z ramki z linkami dla konca polaczenia Value = &#39;value&#39;, # nazwa zmiennej z ramki z wartoscia zwiazana z polaczeniam NodeID = &#39;name&#39;, # nazwa zmiennej z ramki z wezlami w ktorej sa nazwy wezlow fontSize = 20) 16.2.2 network # definiowanie polaczen. Numery zaczyaja sie od 0!. Numery koresponcuja z kolejnoscia wezlow zdefiniowanych w zmiennej z wezlami. links &lt;- data.frame(from=c(0,0,1,2), to=c(1,2,2,3), value=c(10,15,20,25)) nodes &lt;- data.frame(name=c(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;), group=c(1,1,2,2)) forceNetwork(Links = links, # data.frame z imformajami o polaczeniach Nodes = nodes, # ramka danych z informacjami o wezlach Source = &#39;from&#39;, # nazwa zmiennej z ramki z linkami dla poczatku polaczenia Target = &#39;to&#39;, # nazwa zmiennej z ramki z linkami dla konca polaczenia Value = &#39;value&#39;, # nazwa zmiennej z ramki z wartoscia zwiazana z polaczeniam NodeID = &#39;name&#39;, # nazwa zmiennej z ramki z wezlami w ktorej sa nazwy wezlow Group = &#39;group&#39;, fontSize = 20) 16.2.3 radialNetwork and diagonalNetwork samochody &lt;- list(name=&#39;samochody&#39;, children=list(list(name=&#39;toyota&#39;, children=list(list(name=&#39;corolla&#39;), list(name=&#39;avensis&#39;)) ), list(name=&#39;nissan&#39;, children=list(list(name=&#39;micra&#39;), list(name=&#39;almera&#39;)) ), list(name=&#39;honda&#39;, children=list(list(name=&#39;civi&#39;), list(name=&#39;accord&#39;)) ) ) ) radialNetwork(List = samochody, fontSize=10) diagonalNetwork(List = samochody, fontSize=10) 16.2.4 dendrogram hc &lt;- hclust(dist(USArrests), &quot;ave&quot;) dendroNetwork(hc, height = 600) 16.3 network #Rysowanie ladnych grafow set.seed( 1 ) # for reproducibility of this exact graph require(network) # network require(sna) # plot.network require(Hmisc) # largest.empty # Create some data. con &lt;- textConnection(&quot;name,age,jobyrs,inc,saved,int,chld,addryrs Adam,21,1,46,110,3.9,2.62,16.46 Ben,32,6,82,110,3.9,2.875,17.02 Chris,22,2,38,93,3.85,2.32,18.61 David,46,16,158,110,3.08,3.215,19.44 Elvin,58,4,110,175,3.15,3.44,17.02 Fred,18,1,25,105,2.76,3.46,20.22 Greg,23,1,60,245,3.21,3.57,15.84 Henry,44,12,46,62,3.69,3.19,20 Ivan,32,2,40,95,3.92,3.15,22.9 James,29,5,67,123,3.92,3.44,18.3 Kevin,27,10,67,123,3.92,3.44,18.9 Luke,46,18,75,180,3.07,4.07,17.4&quot;) nodelist &lt;-read.csv(con) close( con ) con &lt;- textConnection(&quot;from,to Adam,Ben Adam,Chris Chris,David Chris,Elvin David,Fred Fred,Greg Greg,Henry Henry,James Henry,Ivan James,Kevin Ivan,Kevin Kevin,Luke&quot;) edgelist &lt;- read.csv(con) close( con ) nodes &lt;- levels(as.factor(nodelist[[1]])) # Create a matrix to represent the network. m &lt;- matrix(data = 0, nrow=length(nodes), ncol=length(nodes)) rownames(m) &lt;- colnames(m) &lt;- nodes apply(edgelist, 1, function(x) m[x[[1]], x[[2]]] &lt;&lt;- 1) graph &lt;- network(m, matrix.type=&quot;adjacency&quot;) # Now plot the network, without the nodes. par(xpd=TRUE) xy &lt;- plot(graph, vertex.cex=5, vertex.col=&quot;white&quot;, vertex.border=0) # Get the some other data from the nodes and generate a plot for # each node and place them onto the network. Include a Key at some # empty space. kl &lt;- largest.empty(xy[,1], xy[,2], 2, 2) stars(nodelist[-1], labels=nodelist[[1]], locations=xy, draw.segments=TRUE, key.loc=c(kl$x, kl$y), add=TRUE) 16.4 p:igraph Graf skierowany library(igraph) # Krawedzie dla grafow skierowanych gd &lt;- graph(c(1,2, 2,3, 2,4, 1,4, 5,5, 3,6)) plot(gd) Graf nieskierowany library(igraph) # Krawedzie dla grafow nieskierowanych gu &lt;- graph(c(1,2, 2,3, 2,4, 1,4, 5,5, 3,6), directed=FALSE) # No labels plot(gu, vertex.label=NA) More complex graph require(igraph) # macierz nodes actors &lt;- data.frame(name=c(&quot;Alice&quot;, &quot;Bob&quot;, &quot;Cecil&quot;, &quot;David&quot;, &quot;Esmeralda&quot;), age=c(48,33,45,34,21), gender=c(&quot;F&quot;,&quot;M&quot;,&quot;F&quot;,&quot;M&quot;,&quot;F&quot;)) # macierz edges relations &lt;- data.frame(from=c(&quot;Bob&quot;, &quot;Cecil&quot;, &quot;Cecil&quot;, &quot;David&quot;, &quot;David&quot;, &quot;Esmeralda&quot;), to=c(&quot;Alice&quot;, &quot;Bob&quot;, &quot;Alice&quot;, &quot;Alice&quot;, &quot;Bob&quot;, &quot;Alice&quot;), same.dept=c(FALSE, FALSE, TRUE, FALSE, FALSE, TRUE), cos_tam=c(&#39;a&#39;, &#39;b&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;, &#39;a&#39;), friendship=c(4,5,5,2,1,1), advice=c(4,5,5,4,2,3)) # utworzenie grafu graph &lt;- graph_from_data_frame(relations, directed=TRUE, vertices=actors) print(graph, e=TRUE, v=TRUE) # struktura obiektu grafu # wykres igraph plot.igraph(graph, edge.width=relations$advice, vertex.color=actors$gender , edge.color=relations$cos_tam, vertex.label.color=&#39;white&#39;) # wykres z p:igraph 16.5 p:edgebundleR require(igraph) require(edgebundleR) # generujemy graf tak jak dla p:igrap ale musi byc on symetryczny tzn jezeli jest polaczenia z &#39;a&#39; do &#39;b&#39; to tez musi byc z &#39;b&#39; do &#39;a&#39; actors &lt;- data.frame(name=c(&quot;Alice&quot;, &quot;Bob&quot;, &quot;Cecil&quot;, &quot;Martin&quot;), age=c(48,33,45,46), gender=c(&quot;F&quot;,&quot;M&quot;,&quot;F&quot;,&quot;F&quot;)) relations &lt;- data.frame(from=c(&quot;Alice&quot;, &quot;Bob&quot;, &quot;Alice&quot;, &quot;Cecil&quot;), to=c(&quot;Bob&quot;, &quot;Alice&quot;, &quot;Cecil&quot;, &quot;Alice&quot;), same.dept=c(FALSE, FALSE, TRUE, FALSE), friendship=c(1,1,5,5), cos_tam=c(&#39;a&#39;, &#39;a&#39;, &#39;b&#39;, &#39;b&#39;), advice=c(1,10,50,50)) graph &lt;- graph_from_data_frame(relations, directed=TRUE, vertices=actors) # wykres igraph plot.igraph(graph, edge.width=relations$advice, vertex.color=actors$gender , edge.color=relations$cos_tam, vertex.label.color=&#39;white&#39;) # wykres z p:igraph # wykres edgebundle edgebundle(graph, tension = c(.9) ) # wykres z p:edgebundle 16.6 wizualizacja korelacji p:ggraph example from: https://www.r-bloggers.com/how-to-create-correlation-network-plots-with-corrr-and-ggraph-and-which-countries-drink-like-australia/ wiecej o rysowaniu grafow http://www.data-imaginist.com/2017/Announcing-ggraph/ http://www.data-imaginist.com/2017/ggraph-introduction-layouts/ library(tidyverse) library(corrr) library(igraph) library(ggraph) # stworzenie tabeli korelacji pomiedzy zmiennymi tidy_cors &lt;- mtcars %&gt;% correlate() %&gt;% stretch() # filtrowanie graph_cors &lt;- tidy_cors %&gt;% filter(abs(r) &gt; .3) %&gt;% # interesuja nas korelacje powyzej 0.3 graph_from_data_frame(directed = FALSE) # utworzenie danych o strukturze grafu # narysowanie grafu bez kolorystyki ggraph(graph_cors) + geom_edge_link() + # krawedzie geom_node_point() + # wezly geom_node_text(aes(label = name)) # texty na wezlach # graf z kolorystyka ggraph(graph_cors) + geom_edge_link(aes( edge_alpha = abs(r) , edge_width = abs(r) , color = r)) + guides( edge_alpha = &quot;none&quot; , edge_width = &quot;none&quot;) + scale_edge_colour_gradientn( limits = c(-1, 1) , colors = c(&quot;firebrick2&quot;, &quot;dodgerblue2&quot;)) + geom_node_point( color = &quot;white&quot; , size = 5) + geom_node_text( aes(label = name) , repel = TRUE) + theme_graph() + labs(title = &quot;Correlations between car variables&quot;) "],
["plots-maps.html", "Chapter 17 PLOTS MAPS 17.1 Sources with maps 17.2 Administrative maps 17.3 p:leaflet 17.4 physical maps 17.5 google static maps 17.6 google dynamic maps 17.7 p:Leaflet", " Chapter 17 PLOTS MAPS 17.1 Sources with maps gadm - a database of global administrative boundaries countries - polygons for all countries SRTM - hole-filled CGIAR-SRTM (90 m resolution) Projections alt - altitude (elevation) aggregated from SRTM 90 m resolution data between -60 and 60 latitude. worldclim - a database of global interpolated climate data 17.2 Administrative maps 17.2.1 p:ggplot2 Ploting only outline of the map. require(sp) require(ggplot2) require(maptools) #loading to the workspace variable &#39;gadm&#39; from web site load(url(&quot;http://biogeo.ucdavis.edu/data/gadm2/R/POL_adm1.RData&quot;)) wojewodztwa &lt;- gadm load(url(&quot;http://biogeo.ucdavis.edu/data/gadm2/R/POL_adm2.RData&quot;)) powiaty &lt;- gadm #first way ggplot(wojewodztwa, aes(x = long, y = lat, group=group)) + geom_path() ggplot(powiaty, aes(x = long, y = lat, group=group)) + geom_path() #second way with ggmap function woj_fort &lt;- fortify(wojewodztwa) ggplot(data=woj_fort, aes(map_id=id, x=long, y=lat, group=group)) + geom_map(map = woj_fort, fill=&#39;yellow&#39;) + geom_path() Downloading shp files Trzeba sciagnac plik z mapa, np. ze strony . W sciagnietym pliku mapy beda w roznych formatach. Jest rowniez potrzebny ponizej format shp. Mapa Polski jest dostepna w trzech wersjach: 1. kontury samej polski 2. podzial na wojewodztwa 3. podzial na powiaty \\end{enumerate} Uwaga. Zeby dobrze dzialalo nie wystarczy sam plik shp. Lepiej aby w katalogy byly pozostale pliki. Widocznie sa tez wykorzystywane. #polska z wojewodztwami require(maptools) polska_shp &lt;- readShapePoly(&quot;C:/Users/ppp/Desktop/BIBLIA_R/MANUAL/2_WIZUALIZACJA/1_PODSTAWOWE_PAKIETY/demos/mapy/POL_adm1.shp&quot;) polska_map &lt;- fortify(polska_shp) ggplot(polska_map, aes(x = long, y = lat, group=group)) + geom_path() Manual map: example from help ids &lt;- factor(c(&quot;1.1&quot;, &quot;2.1&quot;, &quot;1.2&quot;, &quot;2.2&quot;, &quot;1.3&quot;, &quot;2.3&quot;)) values &lt;- data.frame( id = ids, value = c(3, 3.1, 3.1, 3.2, 3.15, 3.5) ) positions &lt;- data.frame( id = rep(ids, each = 4), x = c(2, 1, 1.1, 2.2, 1, 0, 0.3, 1.1, 2.2, 1.1, 1.2, 2.5, 1.1, 0.3, 0.5, 1.2, 2.5, 1.2, 1.3, 2.7, 1.2, 0.5, 0.6, 1.3), y = c(-0.5, 0, 1, 0.5, 0, 0.5, 1.5, 1, 0.5, 1, 2.1, 1.7, 1, 1.5, 2.2, 2.1, 1.7, 2.1, 3.2, 2.8, 2.1, 2.2, 3.3, 3.2) ) ggplot(values) + geom_map(aes(map_id = id), map = positions) + expand_limits(positions) ggplot(values, aes(fill = value)) + geom_map(aes(map_id = id), map = positions) + expand_limits(positions) ggplot(values, aes(fill = value)) + geom_map(aes(map_id = id), map = positions) + expand_limits(positions) + ylim(0, 3) Extracting detaild information powiaty@data$ID_0 powiaty@data$NAME_0 powiaty@data$ID_1 powiaty@data$NAME_1 powiaty@data$ID_2 powiaty@data$NAME_2 powiaty@data$VARNAME_2 wojewodztwa@data$ID_0 wojewodztwa@data$NAME_0 wojewodztwa@data$ID_1 wojewodztwa@data$NAME_1 wojewodztwa@data$VARNAME_1 Named elements library(raster) library(rgdal) library(rgeos) library(ggplot2) library(dplyr) require(sp) load(url(&quot;http://biogeo.ucdavis.edu/data/gadm2/R/POL_adm1.RData&quot;)) wojewodztwa &lt;- gadm polska_woj &lt;- fortify(wojewodztwa) polska_woj$id &lt;- as.integer(polska_woj$id) dat &lt;- data.frame(id=1:(length(wojewodztwa@data$NAME_1)), wojewodztwa=wojewodztwa@data$VARNAME_1) polska_woj_df &lt;- merge(polska_woj, dat, by=&#39;id&#39;) centers &lt;- data.frame(gCentroid(wojewodztwa, byid=TRUE)) centers$wojewodztwa &lt;- dat$wojewodztwa ggplot() + geom_map(data=polska_woj_df, map=polska_woj_df, aes(map_id=id, x=long, y=lat, group=group), color=&#39;#ffffff&#39;, fill=&#39;#bbbbbb&#39;, size=0.25) + geom_text(data=centers, aes(label=wojewodztwa, x=x, y=y), size=3) + coord_map() + labs(x=&#39;&#39;, y=&#39;&#39;, title=&#39;Poland&#39;) Extracting subelements example 1 require(sp) require(ggplot2) load(url(&quot;http://biogeo.ucdavis.edu/data/gadm2/R/POL_adm1.RData&quot;)) wojewodztwa &lt;- gadm polska_woj&lt;- fortify(wojewodztwa) polska_slaskie &lt;- polska_woj[polska_woj[,&#39;id&#39;]==13,] ggplot(polska_slaskie, aes(x=long, y=lat, group=group)) + geom_path() Extracting subelements example 2 require(sp) require(ggplot2) load(url(&quot;http://biogeo.ucdavis.edu/data/gadm2/R/POL_adm2.RData&quot;)) powiaty &lt;- gadm id_powiaty_slaskie &lt;- powiaty@data %&gt;% filter(ID_1==13) %&gt;% dplyr::select(ID_2) polska_pow &lt;- fortify(powiaty) powiaty_slaskie &lt;- polska_pow %&gt;% filter(id %in% as.character(unlist(id_powiaty_slaskie))) ggplot(powiaty_slaskie, aes(x=long, y=lat, group=group)) + geom_path() Maps with colors: example 1 require(sp) require(ggplot2) load(url(&quot;http://biogeo.ucdavis.edu/data/gadm2/R/POL_adm1.RData&quot;)) wojewodztwa &lt;- gadm polska_woj &lt;- fortify(wojewodztwa) unemployment_data &lt;- data.frame(id=rownames(wojewodztwa@data), unemployment=runif(16,min = 5,max = 12)) polska_woj &lt;- merge(polska_woj, unemployment_data, by=&#39;id&#39;) ggplot(polska_woj, aes(x=long, y=lat, group=group)) + geom_polygon(aes(fill=unemployment)) + geom_path(color=&#39;grey&#39;) + scale_fill_gradient(low=&#39;light green&#39;, high=&#39;dark green&#39;) + coord_map() Maps with colors: example 2 with faceting require(sp) require(ggplot2) load(url(&quot;http://biogeo.ucdavis.edu/data/gadm2/R/POL_adm1.RData&quot;)) wojewodztwa &lt;- gadm polska_woj &lt;- fortify(wojewodztwa) unemployment_data &lt;- data.frame(id=rep(rownames(wojewodztwa@data),2), unemployment=runif(32,min = 5,max = 12), year=rep(c(2020,2021), each=16) ) polska_woj &lt;- merge(polska_woj, unemployment_data, by=&#39;id&#39;) ggplot(polska_woj, aes(x=long, y=lat, group=group)) + geom_polygon(aes(fill=unemployment)) + geom_path(color=&#39;grey&#39;) + scale_fill_gradient(low=&#39;light green&#39;, high=&#39;dark green&#39;) + coord_map() + facet_grid(.~year) Maps with colors: example 3 descrete categories polska_woj &lt;- fortify(wojewodztwa) unemployment_continuous &lt;- runif(32,min = 4,max = 12) unemployment_discrete &lt;- cut(unemployment_continuous, breaks=c(4,6,8,10,12), include.lowest=TRUE, ordered_results=TRUE) require(plotrix) colors &lt;- gray.colors(nlevels(unemployment_discrete), start = 0.9, end = .1) require(plyr) unemployment_colors &lt;- as.character(mapvalues(unemployment_discrete, levels(unemployment_discrete), colors)) unemployment_data &lt;- data.frame(id=rep(rownames(wojewodztwa@data),2), unemployment=unemployment_discrete, year=rep(c(2020,2021), each=16) ) polska_woj_1 &lt;- merge(polska_woj, unemployment_data, by=&#39;id&#39;) ggplot(polska_woj_1, aes(x=long, y=lat, group=group)) + geom_polygon(aes(fill=unemployment)) + geom_path(color=&#39;black&#39;) + scale_fill_manual(values = colors) + coord_map() + facet_grid(.~year) 17.3 p:leaflet 17.3.1 Interactive map in shiny with wojewodztwa require(shiny) require(l.shiny) require(ggplot2) require(DT) require(rhandsontable) require(leaflet) u &lt;- shinyUI(fluidPage( leafletOutput(&#39;map1&#39;), textOutput(&#39;wojewodztwo&#39;) )) s &lt;- function(input, output, session){ output$map1 &lt;- renderLeaflet({ gadm &lt;- readRDS(&#39;C:/Users/ppp/Desktop/Temporary_files/POL_adm1.rds&#39;) pal &lt;- colorNumeric( palette = &quot;Blues&quot;, domain = 1:16 ) gadm &lt;- readRDS(&#39;C:/Users/ppp/Desktop/Temporary_files/POL_adm1.rds&#39;) leaflet() %&gt;% addTiles() %&gt;% addPolygons(data=gadm, weight=2, fillColor = ~pal(1:16) , layerId = paste0(&quot;marker&quot;, 1:16) ) # popup = ~pal(1:16), }) output$wojewodztwo &lt;- renderText({ z &lt;- input$map1_shape_click$id print(unlist(z)) }) } shinyApp(ui=u, server=s) 17.3.2 removing elements from map require(leaflet) library(shiny) ui &lt;- fluidPage(leafletOutput(&quot;map1&quot;)) server &lt;- function(input, output, session) { output$map1 &lt;- renderLeaflet({ leaflet() %&gt;% addCircleMarkers(lng = runif(10), lat = runif(10), layerId = paste0(&quot;marker&quot;, 1:10)) }) observeEvent(input$map1_marker_click, { leafletProxy(&quot;map1&quot;, session) %&gt;% removeMarker(input$map1_marker_click$id) }) } shinyApp(ui, server) 17.4 physical maps 17.5 google static maps require(ggplot2) library(ggmap) al1 &lt;- get_map(location = c(lon = -86.304474, lat = 32.362563), zoom = 11, maptype = &#39;terrain&#39;) #other options: &quot;terrain&quot;, &quot;satellite&quot;, &quot;roadmap&quot;, &quot;hybrid&quot;, &quot;toner&quot;, &quot;watercolor&quot; w &lt;- gglocator(n = 5, message = FALSE, xexpand = c(0.05, 0), yexpand = c(0.05, 0)) ggmap(al1)+ geom_point(data=w, aes(x=lon, y=lat), size=8) #faceting w &lt;- cbind(w, id=c(1,1,2,2,2)) ggmap(al1)+ geom_point(data=w, aes(x=lon, y=lat), size=8) + facet_grid(.~id) 17.6 google dynamic maps 17.7 p:Leaflet devtools::install_github(&quot;rstudio/leaflet&quot;) library(leaflet) m = leaflet() %&gt;% addTiles() m # a map with the default OSM tile layer #map with zoom m = m %&gt;% setView(-93.65, 42.0285, zoom = 17) m #adding popup m %&gt;% addPopups(-93.65, 42.0285, &#39;Here is the &lt;b&gt;Department of Statistics&lt;/b&gt;, ISU&#39;) #adding circle with popuu m %&gt;% addCircles(-93.65, 42.0285, popup = &#39;Here is the &lt;b&gt;Department of Statistics&lt;/b&gt;, ISU&#39;) #adding points set.seed(123) m = leaflet() %&gt;% addTiles() rand_lng = function(n = 10) rnorm(n, -93.65, .01) rand_lat = function(n = 10) rnorm(n, 42.0285, .01) # circles (units in metres) m %&gt;% addCircles(rand_lng(50), rand_lat(50), radius = runif(50, 10, 200)) "],
["plots-most-common.html", "Chapter 18 PLOTS MOST COMMON", " Chapter 18 PLOTS MOST COMMON "],
["visualisation-other-issues.html", "Chapter 19 VISUALISATION OTHER ISSUES 19.1 Formy elementow na wykresach 19.2 Kolory 19.3 Wspolrzedne 19.4 Jednostki wspolrzednych na wykresie 19.5 Wykresy dynamiczne 19.6 Rozne elementy graficzne", " Chapter 19 VISUALISATION OTHER ISSUES 19.1 Formy elementow na wykresach 19.2 Kolory 19.2.1 sposoby kodowania kolorow dostepne w R rgb-3 liczby dla trzech postawowywch kolorow (czerwony [R-red], zielony [G-green], niebieski [B-blue]). Because each of the three colors can have values from 0 to 255 (256 possible values), there are: 256 × 256 × 256 = 256^3 = 16.777.216 possible color combinations rgba-rgb z dodatkowym czwartym parametrm (alpha), odpowiedzialnym za szarosc. hex-ze znakiem hasha. Używaj systemu liczbowego heksagonalnego (16 znaków). A computer screen displays a color by combining red light, green light and blue light. 100% red, 100% green and 100% blue produces white. Zero red, zero green and zero blue produces black. In fact, equal levels of red, green and blue, whatever that level may be, will always produce a shade of gray. The six digits of a hex code are in fact three two-digit numbers, each representing the level of red, green and blue. So #000100 is zero red, the darkest possible shade of green without being totally black, and zero blue. #010101, because the three values are all equal, is the darkest possible shade of grey, and #020202 is the second darkest. And of course #000000 is black. But what about #FFFFFF for white – what do the letters mean? Hex Codes Use The Hexadecimal System to Minimize Length. There are 256 possible shades each of red, green and blue (0 through 255). If we wanted to produce white (the brightest levels of all three colors combined), we’d need to write #255255255. That’s nine digits long. Hex codes use the hexadecimal number system to make it possible for 256 numbers to be represented with only two digits. Instead of counting 0 through 10 like our regular decimal number system, it counts 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F and then 10, followed by 11, 12, 13, 14, 15, 16, 17, 18, 19, 1A, 1B, 1C, 1D, 1E, 1F and then 20. Make sense? This means that 256 numbers can be represented using only two digits, instead of the 100 that are possible with our decimal number system (0 through 99). So the highest possible two digit number is not 99 but FF (equal to 255). This is why white is #FFFFFF, pure red is #FF0000, pure green #00FF00 and pure blue #0000FF. HSLi HSV-HSL and HSV are the two most common cylindrical-coordinate representations of points in an RGB color model. LUV-kolejny rodzaj kodowania kolorow. Mozna go skojarzyc z paleta przedstawiona na przechylownym zaokraglonym trojkocie. LAB XYZ 19.2.2 `r CHAP(2,‘przekodowywanie kolorow’) Podstawowym typem jakim sie operuje w R jest hex. #z rgb do hex rgb(.04,.56,.65) #znormalizowany do 1 rgb(.04,.56,.65, maxColorValue = 255) #reczna normalizacja # z hex do rgb - sposob 1 require(colorspace) hex2RGB(c(&quot;#FF1223&quot;)) hex2RGB(c(&quot;#FF0000&quot;,&quot;#00FF00&quot;, &quot;#0000FF&quot;)) # z hex do rgb - sposob 2 col2rgb(c(&quot;#4682B433&quot;)) #z palet R do rgb col2rgb(&quot;peachpuff&quot;) col2rgb(c(g66 = &quot;gray66&quot;, darkg = &quot;dark gray&quot;, g67 = &quot;gray67&quot;, g74 = &quot;gray74&quot;, gray = &quot;gray&quot;, g75 = &quot;gray75&quot;, g82 = &quot;gray82&quot;, light = &quot;light gray&quot;, g83 = &quot;gray83&quot;)) col2rgb(palette()) # z kolorow R na hsv require(colortools) col2HSV 19.2.3 palety kolorow 19.2.3.1 sztywne #dostepne w pakiecie grDevices colors() colors()[2] palette() palette()[3] require(RColorBrewer) #podglad palet display.brewer.all(type=&quot;qual&quot;) brewer.pal(7,&quot;Greens&quot;) 19.2.4 palety elastyczne #rzeczy dostepne w grDevices rainbow(5) # 5 kolorow n&lt;-10 rainbow(n, s=1, v=1, start=0, end=max(1,n-1)/n , alpha=1) heat.colors(5) heat.colors(5, alpha=.5) gray.colors(5) gray.colors(5, start=1, end=0) cm.colors(5) terrain.colors(5) terrain.colors(5, alpha=.5) topo.colors(5) topo.colors(5, alpha=.5) #hsv hsv(.5,.5,.5) #hcl hcl(h = c(0, 120, 210, 300)) hcl(h = 0, c = 35, l = 85, alpha, #zarkes [0,1]-przezroczystosc fixup = TRUE) #paleta kolorowa gdzie dostajemy hex require(Kmisc) x&lt;-c(runif(20)) gradient(x, m = 10,cols = c(&quot;darkorange&quot;, &quot;grey60&quot;, &quot;darkblue&quot;)) #paleta z ustalonym sztywnym zakresem-dostajemy hex require(plotrix) x&lt;-c(runif(20)) color.scale(x, #zbior (wektor.macierz/ramka danych) c(0,1), #dla rgb pierwsza liczba dla pierwszego i drugiego koloru c(1,1), #dla rgb druga liczba dla pierwszego i drugiego koloru c(1,0), #dla rgb trzecia liczba dla pierwszego i drugiego koloru alpha=.9, #przezroczystosc koloru na.color=c(0,0,.5), #kolor dla brakow danych xrange = c(-3,3), #ustawiony na sztywno zakres kolorystyczny palety color.spec=&#39;rgb&#39; # w jaki sposob podawane sa kolory ) 19.2.5 Przyklady sposobu kodowanie kolorow na przykladzie wykresow wykonanych w f:ggplot2: z&lt;-data.frame(x=1:10, y=c(1,3,5,6,4,5,3,4,2,1)) #RGB ggplot() + geom_line(data=z, aes(x=x, y=y), colour=rgb(0.2, 0.4, 0.7)) #Nazwa koloru ggplot() + geom_line(data=z, aes(x=x, y=y), colour=&#39;orange&#39;) #lista kolorow w pliku &#39;kolory_R-a&#39; #Kodowanie literowe ggplot() + geom_line(data=z, aes(x=x, y=y), colour=&#39;#FFFFFF&#39;) #lista kolorow w pozrodziale &#39;kolory R-a&#39; #Paleta ggplot() + geom_line(data=z, aes(x=x, y=y), colour=rainbow(10)) #Paleta ggplot() + geom_line(data=z, aes(x=x, y=y), colour=heat.colors(10)) #inne skale to terrain.colors, cm.colors, topo.colors #skale dodatkowe sa w pakietach EColorBrewer i colorRamps #Jaki uklad liczb w sytemie PGB ma dany kolor RGB? col2rgb(&#39;orange&#39;) 19.2.6 Palety kolorow w R przeglad W przypadku kolorow gdzie odowlujemy sie po ich nazwach (np. orange) lista kolorow jest w pliku w pliku koloryR Kolory formatu #FFFFFFF znajduja sie ponizej: Skale kolorow w pakiecie RcolorBrewer 19.2.7 Gotowe palety kolorow RGB 19.2.8 Inne przyklady ladnych palet kolorow Przyklad 1 #ladne kolorki library(gcookbook) # For the data set # Base plot p &lt;- ggplot(uspopage, aes(x=Year, y=Thousands, fill=AgeGroup)) + geom_area() # The palette with grey: cb_palette &lt;- c(&quot;#999999&quot;, &quot;#E69F00&quot;, &quot;#56B4E9&quot;, &quot;#009E73&quot;, &quot;#F0E442&quot;, &quot;#0072B2&quot;, &quot;#D55E00&quot;, &quot;#CC79A7&quot;) # Add it to the plot p + scale_fill_manual(values=cb_palette) 19.3 Wspolrzedne 19.3.1 Odczytywanie wspolrzednych z wykresow require(graphics) locator(n=5) #uruchamiam funkcje, nastepnie klikam puntu (w tym wypadku 5). Funkcja konczy dzialanie po kliknieciu n punktow lub po uzyciu przycisku esc. 19.4 Jednostki wspolrzednych na wykresie 19.4.1 jednostki dlugosci ‘units’ require(grid) &quot;npc&quot; Normalised Parent Coordinates (the default). The origin of the viewport is (0, 0) and the viewport has a width and height of 1 unit. For example, (0.5, 0.5) is the centre of the viewport. &quot;cm&quot; Centimetres. &quot;inches&quot; Inches. 1 in = 2.54 cm. &quot;mm&quot; Millimetres. 10 mm = 1 cm. &quot;points&quot; Points. 72.27 pt = 1 in. &quot;picas&quot; Picas. 1 pc = 12 pt. &quot;bigpts&quot; Big Points. 72 bp = 1 in. &quot;dida&quot; Dida. 1157 dd = 1238 pt. &quot;cicero&quot; Cicero. 1 cc = 12 dd. &quot;scaledpts&quot; Scaled Points. 65536 sp = 1 pt. &quot;lines&quot; Lines of text. Locations and dimensions are in terms of multiples of the default text size of the viewport (as specified by the viewport s fontsize and lineheight). &quot;char&quot; Multiples of nominal font height of the viewport (as specified by the viewport s fontsize). &quot;native&quot; Locations and dimensions are relative to the viewport s xscale and yscale. &quot;snpc&quot; Square Normalised Parent Coordinates. Same as Normalised Parent Coordinates, except gives the same answer for horizontal and vertical locations/dimensions. It uses the lesser of npc-width and npc-height. This is useful for making things which are a proportion of the viewport, but have to be square (or have a fixed aspect ratio). &quot;strwidth&quot; Multiples of the width of the string specified in the data argument. The font size is determined by the pointsize of the viewport. &quot;strheight&quot; Multiples of the height of the string specified in the data argument. The font size is determined by the pointsize of the viewport. &quot;grobwidth&quot; Multiples of the width of the grob specified in the data argument. &quot;grobheight&quot; Multiples of the height of the grob specified in the data argument. 19.5 Wykresy dynamiczne require(animation) #ustawienie interwalow czasowych oopt = ani.options(interval = 2, #wielkosc przerwy dla koljnych klatek-wywolujemy potem funkcja &#39;ani.pause&#39; nmax = 10) # tworzenie petli for (i in 1:ani.options(&quot;nmax&quot;)) { plot(rnorm(30)) ani.pause() ## pause zdefiniowana wczesniej w &#39;ani.options&#39; } ## restore the options ani.options(oopt) 19.6 Rozne elementy graficzne 19.6.1 Tabelki 19.6.1.1 Hmisc #estetyczne wyswietlanie macierzy require(Hmisc) #pierwszy przyklad data(HairEyeColor) print.char.matrix(HairEyeColor[ , , &quot;Male&quot;], col.names = TRUE) #drugi przyklad require(ggplot2) data(diamonds) print.char.matrix(diamonds[1:5,]) 19.6.2 Drzewa 19.6.2.1 pakiet ade4-recznie rysowane drzewa niebinarne #Reczne rysowanie bardziej wypasionych drzew (PAKIET ade4)---- require(ade4) provi.tre &lt;- &quot;( ((a,b,c,d,e)A,(f,g,h)B) C, ((i\\njkj,j)k,l) G )D;&quot; #uwaga. nie wolno powtarzac nazw liter bo sie pomiesza!!! provi.phy &lt;- newick2phylog(provi.tre) plot.phylog(provi.phy, clabel.l = 1.2, #wielkosc znakow w lisciach clabel.n = .9, #wielkosc znakow na wezlach f = .6, ) #dlugosc galezi drzewa "],
["forking.html", "Chapter 20 FORKING 20.1 SQL Databases 20.2 NON SQL Databases 20.3 Python 20.4 C 20.5 C++ 20.6 Symphy", " Chapter 20 FORKING 20.1 SQL Databases https://db.rstudio.com/databases/microsoft-sql-server/ 20.1.1 Load file with sql code require(RODBC) con &lt;- odbcConnect(&#39;sql&#39;) sql &lt;- paste(readLines(con = &quot;C:/Users/lukasz.muszynski/Desktop/temp_files/sql_source/sql_source.sql&quot;), collapse = &quot;\\n&quot;) wynik &lt;- sqlQuery(con, sql) 20.1.2 Configuration of connection between R and database with sql server as an example (for ODBC drivers Go to control panel, and next go to configuration of OCBD conneciton (see figure RODBC_1 i RODBC_2) In the administrator window (see next figure) in fiel ‘Name’ and ‘Description’ type in any name you want to use in R-cran. In filed ‘Server’ type in server name from sql server properties (see second figure from here ). In the end we have to connect with database in R usin p:RODBC: require(RODBC) odbcConnect(&#39;sql&#39;) channel &lt;- odbcConnect(&#39;sql&#39;) z&lt;-sqlQuery(channel, &#39;select top 100 * from [dbo].[Sheet1$]&#39;) 20.1.3 ORACLE Connecting with RODBC # first you have to define odbc in Windows (like when you use other databases) require(RODBC) connection &lt;- odbcConnect(&#39;oracle&#39;, &#39;system&#39;, &#39;oracle&#39;) #&#39;oracle&#39; is a database name, &#39;system&#39; is username, &#39;oracle&#39; is a password result &lt;- sqlQuery(connection, &#39;select * from TABLE1&#39;) sqlTables(connection, schema=&#39;system&#39;) 20.1.4 SQL Server 20.1.4.1 Connection using p:DBI # SQL Server autentification con &lt;- DBI::dbConnect(odbc::odbc(), driver = &quot;SQL Server Native Client 11.0&quot;, server = &#39;DESKTOP-BGFASK3\\\\SQLEXPRES&#39;, database = &#39;master&#39;, Trusted_Connection = &#39;yes&#39;, Port = 1433) # Windows autentification con &lt;- DBI::dbConnect(odbc::odbc(), Driver = &quot;SQL Server&quot;, Server = &quot;DESKTOP-BGFASK3\\\\SQLEXPRESS&quot;, Database = &quot;master&quot;, Trusted_Connection = &quot;True&quot;) 20.1.4.2 Connection beteen R and SQL server and available operations (except SELECT) Using full string to provide connection parameters: # connection with Windows Authentification dbhandle &lt;- odbcDriverConnect(&#39;driver={SQL Server};server=PPP-KOMPUTER\\\\SQLEXPRESS;database=Nauka;trusted_connection=true&#39;) Most of syntax below can be applied to other databases. require(RODBC) require(ggplot2) #for diamonds dataset z &lt;- diamonds #connection configuration with full string (in sql server useful to specify trusted connection) channel &lt;- odbcDriverConnect( connection=&#39; Driver={SQL Server}; Server=PPP-KOMPUTER\\\\SQLEXPRESS; Database=master; Trusted_Connection=yes;&#39;) # here we use trusted connection #saving table in sql server sqlSave(channel, # connection z, #variable with table do save colnames=T, #if columns names should be included nastring=NULL, #how to define missing values rownames=F, #if rows names should be included tablename=&#39;lukasz&#39; ) #table name #updating data in table - we will replace old table the new one. sqlUpdate( channel, z, tablename=&#39;lukasz&#39;, nastring=NULL) #we will get error. Function needs kolumn with index (argumrnt &#39;index&#39; of the function is a string with name of column), to overwrite table. If we dont&#39;t have indexit is easier to remove table and save new. #list of available tables in server sqlTables(channel, tableType=&#39;TABLE&#39;) # available values for argument &#39;tableType&#39; are: TABLE, VIEW, SYSTEM TABLE, ALIAS, SYNONYM. By default all types of tables are printed #columns structure in table sqlColumns( channel , sqtable=&#39;lukasz&#39;) # table name must be provided #removing table sqlDrop(channel, sqtable=&#39;lukasz&#39;, errors=T) # In the case of error we will get value -1. #information about connection odbcGetInfo(channel) #info about mapping types between R and SQL when SAVING data in SQL getSqlTypeInfo(driver = &quot;Microsoft SQL Server&quot;) # info about data types in database sqlTypeInfo(channel = channel) 20.1.4.3 set nocount on The RODBC driver seems to think that when SQL Server returns any count of rows that the entire statement is complete. So you need to set nocount on at the beginning of your statement or stored procedure that is called. set nocount on: This allowed me to use a stored procedure that was using temporary table in R. require(RODBC) # connection with database z&lt;-odbcConnect(&#39;sql&#39;) #odbcClose(z) #query dane&lt;-sqlQuery(z, &#39; set nocount on SELECT rok,miesiac,model_sc model, sum(kwota) kwota,count(*) ilosc into #temp from (select distinct year(data_wpisu) rok ,month(data_wpisu) miesiac ,day(data_wpisu) dzien ,datepart(hh,data_wpisu) godzina ,datepart(mm,data_wpisu) minuta ,p_l_nr_czlonka id_klienta ,p_s_nr_konta id_konta ,p_l_id_wniosek id_wniosek ,model_sc ,p_l_kwota kwota ,pd ,pd*p_l_kwota/100 EL from sc.scoring ) as dane group by rok,miesiac,model_sc select * from ( select distinct rok,miesiac,model,kwota from #temp) as pv PIVOT (sum(kwota) FOR model in ([dk1],[s2],[dk3],[s4],[s5])) as tab order by rok,miesiac&#39;) #end of query odbcClose(z) 20.1.5 Postgres 20.1.5.1 p:RPostreSQL #___RPostgreSQL require(RPostgreSQL) m &lt;- dbDriver(&quot;PostgreSQL&quot;) con_1 &lt;- dbConnect(drv = m, dbname = &#39;lukasz&#39;, user = &#39;postgres&#39;, password = &#39;ppp&#39;, port=5432, host = &#39;localhost&#39;) rs = dbSendQuery(con_1, &quot;drop table diamonds&quot;) # uwaga: jezeli chcemy wykorzystac lacze z src_postres to robimy dbSendQuery(my_db$con,q) dbGetInfo(con_1) # podstawowe informacja po polaczeniu dbListTables(conn = con_1) # lista tabel dbRemoveTable(con_1, name = &#39;diamonds&#39;) #usuniecie tabeli dbDisconnect(con_1) # rozlaczenie sie z baza 20.1.5.2 Working with dlyr Laczenie z baza i przesylanie tabel # polaczenie z baza danych my_db &lt;- src_postgres( dbname = &#39;lukasz&#39; , user = &#39;postgres&#39; , password = &#39;ppp&#39; , port=5432 , host = &#39;localhost&#39;) # skopiowanie z R-a do postgresa copy_to( dest = my_db , mtcars , temporary = FALSE) # stworzenie zmiennej podlaczonej do tabeli w postgresie na ktore bedziemy mogli pracowa z R tabela &lt;- tbl( my_db , &#39;mtcars&#39;) # praca na tabeli &#39;diamonds&#39; ktora jest w bazie postres # usuniecie tabeli w postgresie dbRemoveTable(my_db, name = &#39;mtcars&#39;) #usuniecie tabeli # zamkniecie polaczenia z baza rm(my_db) zapytanie dplyr/sql my_db &lt;- src_postgres( dbname = &#39;lukasz&#39; , user = &#39;postgres&#39; , password = &#39;ppp&#39; , port=5432 , host = &#39;localhost&#39;) copy_to(my_db, df = mtcars, name = &#39;mtcars&#39;, temporary = TRUE) tabela &lt;- tbl( my_db , &#39;mtcars&#39;) # zapytanie przypisuje sie do zmiennych. Jest tu zasada leniwej ewaluacji wiec na razie nie nie jest wykonywane. Zapytanie moga stanowic ciag gdzie jedno moze sie odwolywac do wczesniejszych jak ponizej z1 &lt;- tabela %&gt;% mutate(nowa_zmienna=cyl*10) z2 &lt;- z1 %&gt;% mutate(mowa_zmienna_2=cyl*100) # wykonanie zapytanie i zwrocenie wynikow do R-a collect(z2) # UWAGA: na razie przy takim ciagu zaleznosci nie mozna sie chyba odwolywac do kolumn wczesniej zdefuniowanych: z1 &lt;- tabela %&gt;% mutate(nowa_zmienna=cyl*10) z2 &lt;- z1 %&gt;% mutate(mowa_zmienna_2=nowa_zmienna*100) collect(z2) #zwroci blad ( wynika moze to z tego ze w normlany SQL nie jest dopuszczalne takie odwolywanie sie do kolumny wczesniej utworzonej) # wykonanie zapytania i zapisanie wynikow w tabeli w bazie compute(z2, temporary=FALSE) # podglad kodu SQL show_query(z2) 20.1.6 Other things #tlumeczenie wyrazenia na sql translate_sql(first %is% NULL) 20.2 NON SQL Databases 20.3 Python library(reticulate) # use_python(&quot;C:/Users/memy/Anaconda3/python&quot;) # use_virtualenv(&quot;~/myenv&quot;) # use_condaenv(&quot;myenv&quot;) # python configuration used by p:reticulate py_config() py_discover_config() # running Python code from a file py_run_file(&quot;script.py&quot;) # running python code from script main &lt;- py_run_string(&quot; x = 10 y = 20&quot;) # extracting variables main$x %&gt;% class main$y # loading Python packages np &lt;- import(&quot;numpy&quot;, convert = FALSE) pd &lt;- import(&quot;pandas&quot;, convert = FALSE) # playing the Pandas data.frames main_data_frame &lt;- py_run_string(&#39; import pandas as pd df=pd.DataFrame({&quot;Animal&quot;:[&quot;dog&quot;,&quot;dolphin&quot;,&quot;chicken&quot;,&quot;ant&quot;,&quot;spider&quot;],&quot;Legs&quot;:[4,0,2,6,8]})&#39;) df &lt;- main_data_frame$df class(df) # this is not a R data.frame !!! . Currently (2018 Feb) you cannot convert it do R data.frame !!! py_to_r(…) ?? r_to_py(…) ?? 20.4 C 20.5 C++ 20.6 Symphy Algorytm korzystania z pakietu ‘symphy’: Przykladowy kod w R z uzyciem pakietu symphy ## Not run: # These examples are mostly from: http://wiki.sympy.org/wiki/Tutorial # create a SymPy variable called x sympy(&quot;var(&#39;x&#39;)&quot;) sympy(&quot;y = x*x&quot;) sympy(&quot;y&quot;) sympy(&quot;limit(1/x, x, oo)&quot;) # the next line fails under jython even without R # and seems to corrupt the rest of the session # sympy(&quot;(1/cos(x)).series(x, 0, 10)&quot;) sympy(&quot;diff(sin(2*x), x, 1)&quot;) sympy(&quot;diff(sin(2*x), x, 2)&quot;) sympy(&quot;integrate(exp(-x), (x, 0, oo))&quot;) sympy(&quot;xr = Symbol(&#39;xr&#39;, real=True)&quot;) sympy(&quot;exp(I*xr).expand(complex=True)&quot;) # Matrices are stored row by row (unlike R matrices) cat(sympy(&quot;A = Matrix([[1,x], [y,1]])&quot;), &quot;\\n&quot;) cat(sympy(&quot;A**2&quot;), &quot;\\n&quot;) ## End(Not run) "],
["interactive-apps-shiny.html", "Chapter 21 INTERACTIVE APPS SHINY 21.1 Code location 21.2 UI - basic elements and layout 21.3 UI - modifying 21.4 Server 21.5 modules 21.6 debugging 21.7 p:miniUI 21.8 Example 21.9 Shiny webPages 21.10 Shiny and markdown 21.11 Extensions 21.12 My apps", " Chapter 21 INTERACTIVE APPS SHINY main website about shiny: http://shiny.rstudio.com/ tutorial for shiny: https://shiny.rstudio.com/tutorial/ 21.1 Code location 21.1.1 Separated files W ramach ‘shiny’ tworzymy dwa zwykle pliki R i zapisujemy do stworzonego wczesniej katalogu. Katalog moze miec dowolna nazwe i lokalizacje. Pierwszy plik musi miec nazwe ‘ui’ a drugi ‘server’. Opcjonalanie mozemy dodac trzeci plik o nazwie ‘global’. Nazwy nie moga byc zmienione, bo program nie odnajdzie plikow. W pierwszy definiujemy ogolna strukture strony internetowej. W drugim tworzymy kod wykonujacy obliczenia. W trzecim globalne zmienne ktore mozna wykorzystac przy przetwarzaniu kodu w dwoch pozostalych plikach. Od wersji R-studio 98.800 do uruchomienia programu wykorzystuje sie przycisk ‘Run’ z zielona strzelka (w miejscu gdzie dla zwyklego dokumentu pdf jest przycisk ‘knit’). Wcześniej nie było takiej opcji i trzeba bylo sie posluzyc innym sposobem, .tzn, do uruchomienia strony wykorzystujemy polecenie zawierajace sciezke dostepu do katalogu z plikami: runApp('C:/Users/ppp/Desktop/shiny1'). Polecenie musi byc umieszczone w pliku ‘server’. Jednak w momencie odpalania strony samo polecenie nie może byc zapisane w pliku. Tzn. najpierw zapisujemy plik ‘server’ po zmianach, a nastepnie wklejamy polecenie i je odpalamy. przyklad: ui: shinyUI() server: require(shiny) shinyServer() # runApp(&#39;C:/Users/ppp/Desktop/wykresy_shiny/shinysky&#39;) # do recznego aplikacji bez przycisku w R-studio. 21.1.2 All in one file .&gt;&gt;&gt;&gt; server &lt;- function(input, output) { output$distPlot &lt;- renderPlot({ hist(rnorm(input$obs), col = &#39;darkgray&#39;, border = &#39;white&#39;) }) } ui &lt;- shinyUI(fluidPage( sidebarLayout( sidebarPanel( sliderInput(&quot;obs&quot;, &quot;Number of observations:&quot;, min = 10, max = 500, value = 100) ), mainPanel(plotOutput(&quot;distPlot&quot;)) ) )) require(shiny) shinyApp(ui = ui, server = server) 21.2 UI - basic elements and layout 21.2.1 General layout of page (1) Basic shinyUI(ui = basicPage()) (2) sidebarLayout shinyUI(ui = sidebarLayout( sidebarPanel() , mainPanel = ) ) (3) Grid shinyUI(ui = fluidPage( titlePanel(&#39;title&#39;) ,fluidRow( # numbers must sum up to 12 (here 4 + 8 = 12) column(4, ...) ,column(8, ...) ) ) ) Tip Przy zagniezdzaniu kolumn lepiej uzyc f:fixedRow. Wtedy przy zanieżdżonych szerokosc kolumn zaniezdzonych sumuje sie nie do 12 ale do szerokosci kolumny n fixedRow( column(9, &quot;Level 1 column&quot;, fixedRow( column(6, &quot;Level 2&quot; ), column(3, &quot;Level 2&quot; ) ) ) ) (6) flow require(shiny) ui &lt;- shinyUI(pageWithSidebar( headerPanel(&quot;Tab Switch Demo&quot;), sidebarPanel( flowLayout( # elements are alligned left to right and top to bottom numericInput(&quot;rows&quot;, &quot;How many rows?&quot;, 5), selectInput(&quot;letter&quot;, &quot;Which letter?&quot;, LETTERS), sliderInput(&quot;value&quot;, &quot;What value?&quot;, 0, 100, 50) ), splitLayout( #Lays out elements horizontally, dividing the available horizontal space into equal parts numericInput(&quot;rows1&quot;, &quot;How many rows?&quot;, 5), selectInput(&quot;letter1&quot;, &quot;Which letter?&quot;, LETTERS), sliderInput(&quot;value1&quot;, &quot;What value?&quot;, 0, 100, 50) ), inputPanel( #flowLayout with grey border and light grey backgroud numericInput(&quot;rows2&quot;, &quot;How many rows?&quot;, 5), selectInput(&quot;letter2&quot;, &quot;Which letter?&quot;, LETTERS), sliderInput(&quot;value2&quot;, &quot;What value?&quot;, 0, 100, 50) ), radioButtons(&quot;dist&quot;, &quot;Distribution type:&quot;, c(&quot;Normal&quot; = &quot;norm&quot;, &quot;Uniform&quot; = &quot;unif&quot;, &quot;Log-normal&quot; = &quot;lnorm&quot;, &quot;Exponential&quot; = &quot;exp&quot;), inline=TRUE), checkboxGroupInput(&quot;variable&quot;, &quot;Variable:&quot;, c(&quot;Cylinders&quot; = &quot;cyl&quot;, &quot;Transmission&quot; = &quot;am&quot;, &quot;Gears&quot; = &quot;gear&quot;), inline=TRUE), sliderInput(inputId = &#39;slid&#39;, label = &#39;slider1&#39;, min = 50, max=100, value = 70, width=&#39;70px&#39;) ), mainPanel() )) server &lt;- function(input, output) shinyApp(ui, server) (5) navbarPage page with downdrop menu shinyUI( navbarPage(inverse = FALSE, # for colors HTML(&#39;title&#39;), #button without downdrop tabPanel(HTML(&#39;MENU&#39;)), #buttons with downdrop in navigation bar (navbar) navbarMenu( &quot;More&quot; #name of downdrop button ,tabPanel(&quot;Summary1&quot;, ...) # in the place of dots put content of the page you want to dispay after clicking tab ,tabPanel(&quot;Summary1&quot;, ...) ,&quot;----&quot; # separator ,&quot;Section header&quot; # section ,tabPanel(&quot;Table&quot;, ...) ,tabPanel(&quot;Plot&quot;, ...) ) ) ) (6) boostrap ( For users who are proficient in HTML/CSS, and know how to lay out pages in Bootstrap. Create a Shiny UI page that loads the CSS and JavaScript for Bootstrap, and has no content in the page body (other than what you provide)) shinyUI(ui = bootstrapPage(..., title = NULL, responsive = NULL, theme = NULL)) ) (7) shinydashboar See in chapter about extensions for shiny. 21.2.2 Basic NON_INPUT elements (1) well shiny::wellPanel(...) (2) conditionalPanel .&gt;&gt;&gt;&gt; require(shiny) ui &lt;- shinyUI(basicPage( numericInput(&#39;n&#39;, &#39;n&#39;, value = 1, min = 0, max = 100) ,conditionalPanel( condition = &quot;input.n == 1 | input.n == 2 &quot; # input.n %in% c(1,2) does not work !!!! ,selectInput(&quot;br&quot;, &quot;br&quot;, c(&quot;Sturges&quot;, &quot;Scott&quot;, &quot;Freedman-D&quot;) )) )) server &lt;- function(input, output) shinyApp(ui, server) (3) tabset Creating tabsets .&gt;&gt;&gt;&gt; ui &lt;- shinyUI(basicPage( tabsetPanel( tabPanel(&quot;Plot&quot;, list(plotOutput(&quot;plot1&quot;), plotOutput(&quot;plot1&quot;) ) ) #jezeli jest wiele elementow to podaje je w liscie ,tabPanel(&quot;Summary&quot;, verbatimTextOutput(&quot;summary&quot;)) ,tabPanel(&quot;Table&quot;, tableOutput(&quot;table&quot;)) ,type = c(&quot;tabs&quot;, &quot;pills&quot;) ,id = &#39;tab_id&#39; # If provided, you can use input$id in your server logic to determine which of the current tabs is active. ,selected = &quot;Table&quot; # &#39;Table&#39; tab is selected ) )) server &lt;- function(input, output) shinyApp(ui, server) Dynamically adding/removing tabs .&gt;&gt;&gt;&gt; # example app for inserting/removing a tab ui &lt;- fluidPage( sidebarLayout( sidebarPanel( actionButton(&quot;add&quot;, &quot;Add &#39;Dynamic&#39; tab&quot;), actionButton(&quot;remove&quot;, &quot;Remove &#39;Foo&#39; tab&quot;) ), mainPanel( tabsetPanel(id = &quot;tabs&quot;, tabPanel(&quot;Hello&quot;, &quot;This is the hello tab&quot;), tabPanel(&quot;Foo&quot;, &quot;This is the foo tab&quot;), tabPanel(&quot;Bar&quot;, &quot;This is the bar tab&quot;) ) ) ) ) server &lt;- function(input, output, session) { observeEvent(input$add, { insertTab(inputId = &quot;tabs&quot;, tabPanel(&quot;Dynamic&quot;, &quot;This a dynamically-added tab&quot;), target = &quot;Bar&quot; ) }) observeEvent(input$remove, { removeTab(inputId = &quot;tabs&quot;, target = &quot;Foo&quot;) }) } shinyApp(ui, server) 21.2.3 Basic INPUT elements gellery of basic widgets for shiny: https://shiny.rstudio.com/gallery/widget-gallery.html selectInput i selectizeInput (pole do wybierania wartosci z listy rozwijanej): Warning! Dla nie zaznaczenia niczego tworzymy wartosc wyboru pusta ''. Jezeli mamy wielokrotny wybor to wtedy zwraca do servera NULL, a jezeli jednokrotny to pusty tekst '' .&gt;&gt;&gt;&gt; ui &lt;- shinyUI(basicPage( selectInput( inputId = &#39;s1&#39; #nazwa elementu do ktorej bedziemy sie odwolywac w pliku servera , label = &#39;s1&#39; #nazwa elementu widoczna dla uzytkownika , selectize = TRUE # nie jest potrzebne dla pustego wyboru (brak wyboru jakiejkolwiek wartosci z listy) , multiple = TRUE # Jezeli zaznaczanych jest wiele wartosci, to select zwroci zwykly wektor c(...) , selected = &#39;A&#39; # podaje wartosc do servera a nie wyswietlany label. Jezeli damy &#39;NULL&#39;to nic nie bedzie zaznaczone , choices = c( &#39;a&#39; = &#39;A&#39; # widoczne jest &#39;a&#39; a do servera zwraca &#39;A&#39; ,&#39;b&#39; = &#39;B&#39; ,&#39;nic&#39; = &#39;&#39; # jezeli nic nie wybiore ,&#39;nic_2&#39; = NA # zwroci tekst &quot;NA&quot; a nie brak danych NA )) ,verbatimTextOutput(&#39;s1_out&#39;) )) server &lt;- function(input, output, session) { output$s1_out &lt;- renderPrint(input$s1) } shinyApp(ui, server) selectInput( inputId = &#39;zm1&#39;, #nazwa do ktorej bedziemy sie odwolywac w pliku servera label = c(&quot;Lista rozwijana&quot;), #nazwa listy rozwinajej choices = c( &quot;z&quot; = &quot;d&quot; , &quot;d&quot; = &quot;b&quot; , &quot;g&quot; = &quot;g&quot;), #elementy do wyboru i ich etykiety selected = NULL, #co ma byc domyslnie zaznaczone. Jezeli damy &#39;NULL&#39;to nic. multiple = FALSE) #czy mozna zaznaczac wiele elementow. Domyslnie FALSE. Jezeli zaznaczanych jest wiele wartosci select prawdopodobnie zwroci zwykly wektor &#39;c(...)&#39; dateInput dateInput(&quot;date&quot;, label = h3(&quot;Date input&quot;), value = &quot;2014-01-01&quot;) dateRangeInput dateRangeInput(&quot;dates&quot;, label = &quot;Date range&quot;) # by default both date are set to current date dateRangeInput( &#39;dates&#39; , width = &#39;300px&#39; #szerokow w procentach (&#39;100%&#39;) lub pixelach (&#39;400px&#39;), lub centymetrach (&#39;2cm&#39;), lub milimetrach (&#39;20mm&#39;), lub &#39;auto&#39; , separator = &#39;to&#39; , format = &#39;yyy-mm-dd&#39; , language = &#39;en&#39; # dostepny jest tez polski &#39;pl&#39; , weekstart = 0 # 0-Sunday. Jaki dzien jest pierwszym dniem tygodnia. , startview = &#39;month&#39; # okno kalendarzyka na jakim interwale ma byc po otwarciu , start = as.Date(&#39;2017-12-31&#39;) , end = as.Date(&#39;2018-12-31&#39;) , min = as.Date(&#39;2012-12-31&#39;) , max = as.Date(&#39;2020-12-31&#39;)) radioButtons radioButtons( inputId = , label = , choices = c(&#39;choiceName&#39; = &#39;choiceValue&#39;) # alternativelly you can provide separated vector for both choiceNames and choiceValues # , choiceNames = # , choiceValues = , selected = &#39;choiceValue&#39; #no choiceName !!! , inline = , width = ) checkboxGroupInput checkboxGroupInput( &quot;checkGroup&quot; , inline = , label = h3(&quot;Checkbox group&quot;) , choices = list(&quot;Choice 1&quot; = 1, &quot;Choice 2&quot; = 2, &quot;Choice 3&quot; = 3) , selected = 1 ) textarea pole textowe o zmiennym rozmiarze tags$textarea(id=&quot;foo&quot;, rows=3, cols=40, &quot;Default value&quot;) 21.2.4 basic OUTPUT element Shiny package: renderDataTable() &lt;-&gt; dataTableOutput() renderImage() &lt;-&gt; imageOutput() renderPlot() &lt;-&gt; plotOutput() renderPrint() &lt;-&gt; verbatimTextOutput() renderTable() &lt;-&gt; tableOutput() renderText() &lt;-&gt; textOutput renderUI() &lt;-&gt; uiOutput() Extensions: rhandsontable::rhandsontable() &lt;-&gt; rhandsontable::rHandsontableOutput() DT::renderDataTable() &lt;-&gt; DT::dataTableOutput() 21.3 UI - modifying 21.3.1 CSS Loading external files tags$link( rel=&quot;stylesheet&quot; , type=&quot;text/css&quot; , href=&quot;C:/Users/ppp/Desktop/SHINY/Wstepne_analizy/css/plik_1.css&quot;) # or includeCSS(path=&#39;C:/Users/ppp/Desktop/SHINY/Wstepne_analizy/css/plik_1.css&#39;) Using CSS styles # frame div( id = &#39;div_1&#39; #id is optional , class=&quot;span11&quot; , sliderInput(&#39;ble&#39;,label=&#39;ble&#39;,min=0,max=10,step=1,value=4)) # parafraph p( id = &#39;a&#39; #id is optional , class = &#39;b&#39; , HTML(&#39;bleble&#39;)) Using CSS directly # (1) textInput(&#39;sep&#39;,&#39;sep&#39;), tags$style(type=&#39;text/css&#39;, &quot;#sep { width: 25px;}&quot;) # (2) textInput(&#39;dec&#39;,&#39;dec&#39;), tags$style(type=&#39;text/css&#39;, &quot;#dec { width: 100px;}&quot;) # (3) MODYFIKACJA GLOBALNA USTAWIEN DLA WSZYSTKICH INPUTOW DANEJ KATEGORII tags$head( tags$style(type=&quot;text/css&quot;, &quot;label.radio { display: inline-block; }&quot;, &quot;.radio input[type=\\&quot;radio\\&quot;] { float: none; }&quot;), tags$style(type=&quot;text/css&quot;, &quot;select { max-width: 200px; }&quot;), tags$style(type=&quot;text/css&quot;, &quot;textarea { max-width: 85px; }&quot;), tags$style(type=&quot;text/css&quot;, &quot;.jslider { max-width: 200px; }&quot;), tags$style(type=&#39;text/css&#39;, &quot;.well { max-width: 310px; }&quot;), tags$style(type=&#39;text/css&#39;, &quot;.span4 { max-width: 310px; }&quot;) ) # (4) MODYFIKACJA HEADERA tags$head( tags$style(type=&#39;text/css&#39;, &quot;.textInput {font-size: 20px} &quot;)), # (5) MODYFIKACJA LABEL W PRZYCISKU (with html, no CSS) sliderInput (&quot;lambda1&quot;, label=div(HTML(&quot;Choose &amp;-lambda;:&quot;)), min=0, max=10, value=1.1, step=0.1) 21.3.2 tags ui &lt;- shinyUI(basicPage( div(style=&#39;color:red;&#39;, HTML(&#39;frame&#39;)) ,span(&#39;a&#39;) # it is like div but with the difference that it is an INLINE element ,h1(&#39;big header&#39;) #headers ,h6(&#39;small header&#39;) ,a(href=&#39;http://www.wp.pl&#39;, &#39;Click Here!&#39;) # href fo rlinks ,img(src = &#39;C:/Users/memy/Desktop/dla_Ewelinki/Manual_R/figures/create_project.png&#39;, alt=&#39;no photo&#39;) ,code(&#39;code&#39;) ,br() # break line &lt;br&gt; ,em(&#39;emphesized text&#39;) # Renders as emphasized text ,strong(&#39;bolded text&#39;) ,hr(&#39;a&#39;) # horizontal rule [linia pozioma] ,pre(&#39;Text in a pre elementis displayed in a fixed-width font, and it preserves both spaces and line breaks&#39;) # preformatted text )) server &lt;- function(input, output, session) { } shinyApp(ui, server) tagList( tags$h1(&quot;Title&quot;) ,tags$h2(&quot;Header text&quot;) ,tags$p(&quot;Text here&quot;)) 21.3.3 UI - dynamically generating from server See part about server side processing 21.4 Server 21.4.1 General remarks Kod pisany w ‘reactive’ oddzialuje na konsole R-a. Warunkiem jest to ze sam reactive musi byc wywolany przez inny blok ktory generuje jakos ouput.Tej cechy nie posiada observe, ktory wykonuje kod nawet jesli nie jest wywolany. 21.4.2 scoping rules Zmienne na ktorych pracuje sie w blokach reaktywnych (render, observer itp.), NIE sa widziane poza nimi. Zmienne zdefiniowane poza blokami reaktywnymi sa widziane w blokach Zmienne zdefiniowane w pliku ‘global’ sa widziane w plikach ‘ui’ i ‘server’ Operator przypisania globalnego. Patrz dalsze przyklady. Przy pomocy operatora przypisania globalnego &lt;&lt;- mozna zapisac wartosc do zmiennej aby byla widziana w kolejnej sesji. Zmienne mozna tak zapisywac rowniez w blokach. Ale nalezy pamietac ze w bloku mozemy nadpisac globalnie zmienna zdefiniowana poza blokami. Tzn. nadpisanie w bloku globalnie zmiennej pochodzacej z innego bloku nie jest mozliwe (patrz punkt pierwszy). Wyniki z calych blokow mozna przypisywac do zmiennych. W takim wypadku zmienna taka jest widoczna w innych blokach. Z bloku jest przypisywana wartosc zogdna z regula nawiasow klamrowych (tzn ostatnie wyrazenie z klamry). Do zmiennych ktore powstaly przez przypisanie wartosci z bloku, w innym bloku odwolujemy sie poprzez wypisanie jej z nawiasami okraglymi np: zmienna()[[2]]. 21.4.3 problems list list of some problems patterns for actionButtons: http://shiny.rstudio.com/articles/action-buttons.html dwa przyciski - jeden element - jedna zmienna przyjmuje 2 wartosci: jedna dla nacisniecia jednego przycisku druga grugiego. Robimy to w observerze na poczatku. Potem sprawdzmy wartosc i wiemy co bylo nacisniete dwa outputy jedna lokalizacja - tutaj trzeba dynamicznego UI oraz zagniezdzenie obu outputow w observe generowanie output w petli: zagniezdzamy petle w observerze. Trzeba pamietac o funkcji local. nauka angielskiego - modul do wyswietlania i oceniania znajomosci. Musi byc globalny licznik z1 &lt;- numeric(0) z2 &lt;- numeric(0) z3 &lt;- numeric(0) z4 &lt;- numeric(0) z5 &lt;- numeric(0) ui &lt;- fluidPage(actionButton(&#39;a1&#39;), verbatimTextOutput(&#39;v1&#39;)) se &lt;- function(input, output, session){ observeEvent(input$a1,{z1 &lt;- runif(1)}) observeEvent(input$a1,{z2 &lt;- -1; z2 &lt;&lt;- runif(1)}) observeEvent(input$a1,{z3 &lt;- -1; observe(observe(z3 &lt;&lt;- runif(1)))}) observeEvent(input$a1,{z4 &lt;- -1; assign(&#39;z4&#39;, value=runif(1), envir = .GlobalEnv)}) observeEvent(input$a1,{z5 &lt;- -1; observe(observe( assign(&#39;z5&#39;, value=runif(1), envir = .GlobalEnv) ) )}) output$v1 &lt;- renderPrint({ input$a1 print(list( z1 # brak wplywu , z2 # zmienia sie , z3 # brak wplywu , z4 #zmiena sie , z5 #zmienia sie ) ) }) } shinyApp(ui, se) 21.4.4 reactive i observer 21.4.4.1 f:reactiveVal i reactiveVals Useful f:reactiveVal vs f:reactiveValues() - syntax differences: one_var &lt;- reactiveVal() one_var(10) # assigning values one_var() # extracting values many_vars &lt;- reactiveValues(a=1, b=2, c=3) many_vars$a &lt;- 10 #assigning values many_vars$a # estracting values W zmiennej reactiveVal mamy cos takiego, ze jezeli zmieniamy jej wartosc to wszyskie elementy ktore odwoluja sie do niej sa o tym informowane. Przyklad dla output .&gt;&gt;&gt;&gt; ui &lt;- shinyUI(basicPage(actionButton(&#39;a1&#39;,&#39;a1&#39;), verbatimTextOutput(&#39;v1&#39;))) sv &lt;- function(input, output, session){ r_val &lt;- reactiveVal() observeEvent(input$a1, {r_val(runif(1))}) # zdarzenie modyfikujace r_val output$v1 &lt;- renderPrint({print(r_val() )}) } shinyApp(ui, sv) Przyklad dla observer .&gt;&gt;&gt;&gt; ui &lt;- shinyUI(basicPage(actionButton(&#39;a1&#39;,&#39;a1&#39;))) sv &lt;- function(input, output, session){ r_val &lt;- reactiveVal() observeEvent(input$a1, {r_val(runif(1))}) # zdarzenie modyfikujace r_val observe({ saveRDS(r_val(), file = &#39;_17/usunac.RDS&#39;) # observer ktory bedzie poinformowany o zmianie wartosci r_val }) } shinyApp(ui, sv) Nastepny przyklad Tip Uzycie reactiveVal dla rozwiazania problemy gdzie dwoma przycikami steruje jednym outputem. Wersja bez f:isolate .&gt;&gt;&gt;&gt; require(shiny) ui &lt;- shinyUI(basicPage( actionButton(&#39;b1&#39;, &#39;b1&#39;) ,actionButton(&#39;b2&#39;, &#39;b2&#39;) ,verbatimTextOutput(&#39;v1&#39;) )) server &lt;- function(input, output, session){ a &lt;- reactiveValues(selection=NULL) observeEvent(input$b1, {a$selection &lt;- 1}) observeEvent(input$b2, {a$selection &lt;- 2}) output$v1 &lt;- renderPrint({ button_selection &lt;- a$selection if(button_selection == 1){ print(&#39;b1&#39;) }else if(button_selection == 2){ print(&#39;b2&#39;) } }) } shinyApp(ui = ui, server = server) Do f:reactiveVal mozna tez stosowac isolate. Powyzszy przyklad po drobnej modyfikacji: .&gt;&gt;&gt;&gt; require(shiny) ui &lt;- shinyUI(basicPage( actionButton(&#39;b1&#39;, &#39;b1&#39;) ,actionButton(&#39;b2&#39;, &#39;b2&#39;) ,actionButton(&#39;action&#39;, &#39;action&#39;) # dadajemy trzeci przycisk bo dwa poprzednie beda zaizolowane ,verbatimTextOutput(&#39;v1&#39;) )) server &lt;- function(input, output, session){ a &lt;- reactiveValues(selection=NULL) observeEvent(input$b1, {a$selection &lt;- 1}) observeEvent(input$b2, {a$selection &lt;- 2}) output$v1 &lt;- renderPrint({ button_selection &lt;- isolate(a$selection) # tutaj dodajemy izolacje input$action # trzeci przycisk dodany ze wzgledu na izolacje if(button_selection == 1){ print(&#39;b1&#39;) }else if(button_selection == 2){ print(&#39;b2&#39;) } }) } shinyApp(ui = ui, server = server) 21.4.4.2 reactive reactive syntax. Zgodnie z regula klamrowa zwracana jest ostatnia linijka. Jezeli nie umiescimy w niej zmiennej to reactive nam nic nie zwroci .&gt;&gt;&gt;&gt; ui &lt;- shinyUI(basicPage(actionButton(&#39;a1&#39;,&#39;a1&#39;), verbatimTextOutput(&#39;v1&#39;))) se &lt;- function(input, output, session){ # list r1 &lt;- reactive({ input$a1 l &lt;- list(a=runif(1), b=runif(1)) l }) #one variable r2 &lt;- reactive({ input$a1 x &lt;- runif(1) x }) # extracting output$v1 &lt;- renderPrint({ print(list( # r1()$l takie cos nam niczego nie zwroci !!! r1()$a #1 ,r1()[&#39;a&#39;] #2 ,r1()[1] #3 ,r2() #4 )) }) } shinyApp(ui, se) ‘reactive’ tak jak ‘rectiveVal’ i ‘reactiveVals’ potrafi pchac: .&gt;&gt;&gt;&gt; ui &lt;- shinyUI(basicPage( actionButton(&#39;a1&#39;, &#39;a1&#39;) , verbatimTextOutput(&#39;v1&#39;))) se &lt;- function(input, output, session) { a &lt;- reactive({a &lt;- runif(1) input$a1 # ten przycisk bedzie pchal dzialanie reactive a }) output$v1 &lt;- renderPrint({print(a())}) } shinyApp(ui, se) Natomiast output nie potrafi ciagnac (to co powyzej z drobna modyfikacja): .&gt;&gt;&gt;&gt; ui &lt;- shinyUI(basicPage( actionButton(&#39;a1&#39;, &#39;a1&#39;) , verbatimTextOutput(&#39;v1&#39;))) se &lt;- function(input, output, session) { a &lt;- reactive({a &lt;- runif(1) # input$a1 # blokuje przycisk pchajacy a }) output$v1 &lt;- renderPrint({ input$a1 # przycik ktory powinien NIBY ciagnac print(a()) }) } shinyApp(ui, se) complex chaining of reactve. First conclusion is that reactive can push reactive. Next is that we can fork reactive elements. .&gt;&gt;&gt;&gt; ui &lt;- shinyUI(basicPage(actionButton(&#39;a1&#39;, &#39;a1&#39;), verbatimTextOutput(&#39;v1&#39;))) se &lt;- function(input, output, session){ r1 &lt;- reactive({ input$a1 runif(1) }) r2 &lt;- reactive({ input$a1 c(runif(1), r1()) }) r3a &lt;- reactive({ c(runif(1), r2()) }) r3b &lt;- reactive({ # we have no input$a1 here !!! we are pushed by r2() c(runif(1), r2()) }) output$v1 &lt;- renderPrint({ list(r1(), r2(), r3a(), r3b()) }) } shinyApp(ui, se) 21.4.4.3 observe observe order of execution. .&gt;&gt;&gt;&gt; library(shiny) z1 &lt;- numeric(0) z2 &lt;- numeric(0) ui &lt;- fluidPage(actionButton(&#39;a1&#39;,&#39;a1&#39;), verbatimTextOutput(&#39;v1&#39;)) server &lt;- function(input, output, session) { #z1 observe(priority = 2, x = {input$a1; z1 &lt;&lt;- 200 + runif(1)}) observe(priority = 1, x = {input$a1; z1 &lt;&lt;- 100 + runif(1)}) # this observe will be executed bofore previous! #z2 observe(priority = 3, x = {input$a1; z2 &lt;&lt;- 400 + runif(1)}) observe(priority = 4, x = {input$a1; z2 &lt;&lt;- 500 + runif(1)}) output$v1 &lt;- renderPrint({input$a1; print(list(z1,z2))}) } shinyApp(ui, server) observe suspension server &lt;- function(input, output) { z &lt;- reactive({ input$action z &lt;- input$obs w &lt;- rnorm(n=z) w }) obs_1 &lt;- observe({ write.table(x = z(), file = &#39;C:/Users/ppp/Desktop/plik.txt&#39;) } , suspended=TRUE) obs_2 &lt;- observe({ if(input$action %% 2 == 0) obs_1$resume() }) #make &#39;obs_1&#39; not suspended obs_2 &lt;- observe({ if(input$action %% 2 != 0) obs_1$suspend() }) #make &#39;obs_1&#39; suspended } Using above syntax we can also change priority of observe obs_2 &lt;- observe({ if(input$action %% 2 != 0) obs_1$setPriority(priority = 0) }) Sprawdzenie czy observe jest zawieszony s &lt;- function(input, output, session){ obs &lt;- observe({}, suspended = TRUE) output$t &lt;- renderPrint({ obs$.suspended }) } u &lt;- shinyUI(fluidPage( verbatimTextOutput(&#39;t&#39;) )) shinyApp(u, s) 21.4.5 dynamic ui 21.4.5.1 simple examples Simple example (uiOutput not generated separately) ui &lt;- fluidPage( actionButton(&#39;a1&#39;, &#39;a1&#39;) ,numericInput(&#39;n1&#39;, &#39;n1&#39;, value = 1, min = 1, max = 100, step = 10) ,uiOutput(&#39;ui1&#39;) ) se &lt;- function(input, output, session){ output$ui1 &lt;- renderUI({ default &lt;- input$n1 tagList( sliderInput(&#39;s1&#39;, &#39;s1&#39;, value = default, min = 1, max = 100, step = 1) ) }) } shinyApp(ui, se) Many separated dynamically generated ui (also uiOutput!!!) .&gt;&gt;&gt;&gt; u &lt;- shinyUI(fluidPage(uiOutput(&#39;o3&#39;))) s &lt;- function(input, output, session){ observe({ output$o1 &lt;- renderUI({ checkboxInput(&#39;c1&#39;,&#39;c1&#39;,value = TRUE) }) output$o2 &lt;- renderUI({ checkboxInput(&#39;c2&#39;,&#39;c2&#39;,value = FALSE) }) }) output$o3 &lt;- renderUI({ list(uiOutput(&#39;o1&#39;), uiOutput(&#39;o2&#39;) ) }) } shinyApp(u,s) 21.4.5.2 Complicated nesting dynamically generated ui Niestety bezposrednia zaleznosc sel_1 od c1 w ramach jednego renderUI jest niemozliwa. .&gt;&gt;&gt;&gt; require(shiny) require(ggplot2) d &lt;- head(diamonds) m &lt;- head(mtcars) s &lt;- function(input,output, session){ output$o1 &lt;- renderUI({ list( checkboxInput(&#39;c1&#39;, &#39;c1&#39;, value = TRUE), selectInput(&#39;sel_1&#39;, &#39;sel_1&#39;, choices = if(input$c1) names(d) else names(m) )) }) } u &lt;- shinyUI(fluidPage( actionButton(&#39;a1&#39;,&#39;a1&#39;), uiOutput(&#39;o1&#39;) )) shinyApp(u, s) Koniecznie jest rozbicie elementow .&gt;&gt;&gt;&gt; require(shiny) require(ggplot2) d &lt;- head(diamonds) m &lt;- head(mtcars) s &lt;- function(input,output, session){ output$o1 &lt;- renderUI({ checkboxInput(&#39;c1&#39;, &#39;c1&#39;, value = TRUE) }) output$o2 &lt;- renderUI({ list( selectInput(&#39;sel_1&#39;, &#39;sel_1&#39;, choices = if(input$c1) names(d) else names(m) )) }) } u &lt;- shinyUI(fluidPage( actionButton(&#39;a1&#39;,&#39;a1&#39;) , uiOutput(&#39;o1&#39;), , uiOutput(&#39;o2&#39;) )) shinyApp(u, s) Next complecated nesting .&gt;&gt;&gt;&gt; ui &lt;- fluidPage( uiOutput(&#39;ui1&#39;) ) se &lt;- function(input, output, session){ output$ui1 &lt;- renderUI({ tagList( numericInput(&#39;n1&#39;, &#39;n1&#39;, min = 1, max = 100, step = 10, value = 1) ,renderUI({ tagList( sliderInput(&#39;s1&#39;, &#39;s1&#39;, min = 1, max = 100, value = input$n1) ) }) ) }) } shinyApp(ui, se) 21.4.5.3 dynamic ui in loop Dynamicznie inputy, render i outputy (3 rzeczy na raz), w tym inputy dynamicznie po stronie ui a nie servera !!! Przyklad ze strony: https://shiny.rstudio.com/gallery/creating-a-ui-from-a-loop.html .&gt;&gt;&gt;&gt; library(shiny) require(dplyr) ui &lt;- fluidPage( title = &#39;Creating a UI from a loop&#39;, sidebarLayout( sidebarPanel( # generowanie dynamicznej ilosci selectow lapply(1:5, function(i) { selectInput(paste0(&#39;a&#39;, i), paste0(&#39;SelectA&#39;, i), choices = sample(LETTERS, 5)) }) ), mainPanel( verbatimTextOutput(&#39;a_out&#39;), # UI output lapply(1:10, function(i) { uiOutput(paste0(&#39;b&#39;, i)) }) ) ) ) se &lt;- function(input, output, session) { # note we use the syntax input[[&#39;foo&#39;]] instead of input$foo, because we have # to construct the id as a character string, then use it to access the value; # same thing applies to the output object below # mamy jeden renderPrint ktory musi sobie poradzic z pobieraniem dynamicznej iloscio inputow output$a_out &lt;- renderPrint({ res &lt;- lapply(1:5, function(i) input[[paste0(&#39;a&#39;, i)]]) # tutaj mamy dynamiczna ilosc inputow str(setNames(res, paste0(&#39;a&#39;, 1:5))) }) # generowanie dynamicznej ilosci outputow lapply(1:10, function(i) { output[[paste0(&#39;b&#39;, i)]] &lt;- renderUI({ strong(paste0(&#39;Hi, this is output B#&#39;, i)) }) }) } shinyApp(ui, se) Simple example with many plots .&gt;&gt;&gt;&gt; ui &lt;- fluidPage( numericInput(&#39;n1&#39;, &#39;n1&#39;, value = 1, min = 1, max = 6) ,uiOutput(&#39;ui_1&#39;) ) se &lt;- function(input, output, session){ observe({ il_wyk &lt;- input$n1 # dynamiczne rendery lapply(1:il_wyk, function(i){ output[[paste0(&#39;nazwa&#39;, i)]] &lt;- renderPlot({ # ggplot() + geom_histogram(data=data.frame(sample(x = 1:1000, size = 50, replace = TRUE))) hist(sample(x = 1:1000, size = 50, replace = TRUE)) }) }) # dynamiczne outputy output$ui_1 &lt;- renderUI({ lapply(1:il_wyk, function(i){ plotOutput(paste0(&#39;nazwa&#39;, i)) }) }) }) } shinyApp(ui, se) Dynamic tabs require(shiny) require(ggplot2) r g &lt;- 1 u &lt;- shinyUI(fluidPage( sliderInput(&#39;slid&#39;,&#39;slid&#39;,min=1, max=4, value=1), uiOutput(&#39;wynik&#39;), actionButton(&#39;a1&#39;, &#39;a1&#39;) )) s &lt;- function(input, output, session) { output$wynik &lt;- renderUI({ # namest for tabs tabnames &lt;- paste0(&#39;z_&#39;,1:input$slid) # dynamic generating plots if(g &gt; input$slid){ # ten warunek powoduje ze jak zwiekszam ilosc wykresowo sliderem to nie znikaja wykresy z juz istniejacych tabs-ow for(i in (input$slid + 1):g ){ # tutaj licznik nie jest od 1 !!! output[[paste0(&#39;z_&#39;,i)]] &lt;- renderPlot({}) } } g &lt;&lt;- input$slid tabs &lt;- list(NULL) # dynamic generating tabs with dynamically generated plotoutput (two things at one) for (i in 1:input$slid) tabs[[i]] &lt;- tabPanel(tabnames[i], plotOutput(tabnames[i]), value = tabnames[i]) tabs$id &lt;- &quot;tab0&quot; do.call(tabsetPanel, tabs) }) observe({ if(input$a1 &gt; 0){ z &lt;- isolate(input$tab0) # selected tab output[[z]] &lt;- renderPlot({ hist(sample(1:100, size = 50, replace=TRUE)) }) } }) } shinyApp(u,s) 21.4.5.4 Dynamic navbar .&gt;&gt;&gt;&gt; l.s::l.s.packages_basic() elements &lt;- tribble(~nav, ~tab ,&#39;t1&#39;,&#39;a&#39; ,&#39;t1&#39;,&#39;b&#39; ,&#39;t2&#39;,&#39;c&#39; ,&#39;t2&#39;,&#39;d&#39; ,&#39;t2&#39;,&#39;e&#39; ) # example app for prepending/appending a navbarMenu ui &lt;- navbarPage(&quot;Navbar page&quot;, id = &quot;tabs&quot;, tabPanel(&quot;Home&quot;, actionButton(&quot;prepend&quot;, &quot;Prepend a navbarMenu&quot;), actionButton(&quot;append&quot;, &quot;Append a navbarMenu&quot;) ) ) server &lt;- function(input, output, session) { observe( { input$append elements_list &lt;- elements %&gt;% dplyr::group_by(nav) %&gt;% tidyr::nest(.key = &#39;elements&#39;) for(i in 1:nrow(elements_list) ){ id_nav &lt;- elements_list[i,&#39;nav&#39;] %&gt;% unnest %&gt;% pull appendTab(inputId = &quot;tabs&quot;, navbarMenu(title = id_nav)) #, tabPanel(paste0(id_nav,&#39;ts1&#39; ), value = paste0(id_nav,&#39;_ts1&#39;) ) ) for(j in 1:nrow(unnest(elements_list[i,&#39;elements&#39;]))){ id_tab &lt;- elements_list[i,&#39;elements&#39;] %&gt;% unnest %&gt;% .[j,&#39;tab&#39;] %&gt;% pull appendTab(inputId = &#39;tabs&#39;, menuName = id_nav, tabPanel(id_tab, id_tab) ) } } }) } shinyApp(ui, server) 21.5 modules 21.5.1 simple examples .&gt;&gt;&gt;&gt; require(shiny) # input element in UI f_Ui_Input &lt;- function(id){ ns &lt;- NS(id) tagList( sliderInput(ns(&#39;s1&#39;), &#39;s1&#39;, value = 2, min = 2, max = 100, step = 20) ) } # output elements in UI f_Ui_Output &lt;- function(id){ ns &lt;- NS(id) plotOutput(ns(&#39;plot&#39;)) } # server elements f_Server &lt;- function(input, output, session){ output$plot &lt;- renderPlot({ plot_1 &lt;- input$s1 plot(1:plot_1) }) } # PROGRAM GLOWNY Z MODULAMI server &lt;- function(input, output, session){ shiny::callModule(f_Server, &#39;ui_1&#39;) } # IM!! # takie cos NIE ZADZIALA (cos co zadziala jest dalej) ui_NIEZADZIALA &lt;- shinyUI({ basicPage( f_Ui_Input(&#39;ui_1&#39;), plotOutput(&#39;plot&#39;) # tutaj jest problem z odwolaniem do &#39;plot&#39; ktory jest w innym namespace IM!! ) }) # cos takiego zadziala ui_ZADZIALA &lt;- shinyUI({ basicPage( f_Ui_Input(&#39;ui_1&#39;), f_Ui_Output(&#39;ui_1&#39;) ) }) shinyApp(ui_NIEZADZIALA, server) shinyApp(ui_ZADZIALA, server) Teraz w module zrobie tylko jeden reactive w serwerze. # robie tylko modulowy server f_sever1 &lt;- function(input, output, session){ wynik &lt;- reactive({ s1 &lt;- input$s1 s1 }) wynik } # glowne UI ui &lt;- shinyUI({ basicPage( f_Ui_Input(&#39;ui_1&#39;), plotOutput(&#39;plot&#39;) ) }) # glowny server server_2 &lt;- function(input, output, session){ liczba_do_wykresu &lt;- callModule(f_sever1, &#39;ui_1&#39;) output$plot &lt;- renderPlot({ plot(1:liczba_do_wykresu()) }) } shinyApp( ui # ui jest zwykle , server_2) 21.5.2 General logic of modules # dla modulow typu UI dziala to tak: innerUI &lt;- function(id) { ns &lt;- NS(id) &quot;This is the inner UI&quot; } outerUI &lt;- function(id) { ns &lt;- NS(id) wellPanel( innerUI(ns(&quot;inner1&quot;)) ) } # dla modulow z logika serverowa dziala tak: inner &lt;- function(input, output, session) { # inner logic } outer &lt;- function(input, output, session) { innerResult &lt;- callModule(inner, &quot;inner1&quot;) # outer logic } 21.5.3 Important!!! passing input from outside of the module # module UI Outputs f1 &lt;- function(id){ ns &lt;- NS(id) tagList( verbatimTextOutput(ns(&#39;print_1&#39;)) , verbatimTextOutput(ns(&#39;print_2&#39;))) } # module Server f2 &lt;- function( input , output , session , a # a is an extra argument where I will pass values IM!! , b){ # b is an extra argument where I will pass values IM!! # v2: function(input, output, session, a) output$print_1 &lt;- renderPrint({ c1 &lt;- a() # v2: a()[[1]] if(c1){ z &lt;- 1 }else{ z &lt;- 2 } z }) output$print_2 &lt;- renderPrint({ c2 &lt;- b() # v2: a()[[1]] if(c2){ z &lt;- 1 }else{ z &lt;- 2 } z }) } # Main UI u4 &lt;- shinyUI(fluidPage( checkboxInput(&#39;c1&#39;, &#39;c1&#39;, value = FALSE) ,checkboxInput(&#39;c2&#39;, &#39;c2&#39;, value = FALSE) ,f1(&#39;test&#39;) )) # Main Server s4 &lt;- function(input, output, session){ callModule( f2 , &#39;test&#39; , reactive(input$c1) # passing arguments IMPORTANT! , reactive(input$c2)) # passing arguments IMPORTANT! #v2: callModule(f2, &#39;test&#39;, reactive(list(input$c1, input$c2))) } shinyApp(u4, s4) 21.6 debugging 21.6.1 validate Example: use f:validate to give a message that ggplot doesn’t work. .&gt;&gt;&gt;&gt; u &lt;- shinyUI(fluidPage( actionButton(&#39;a1&#39;,&#39;a1&#39;) ,plotOutput(&#39;p1&#39;) )) s &lt;- function(input, output, session){ output$p1 &lt;- renderPlot({ input$a1 validate( need( try( print( qplot(data=diamonds, x=aa ))) ,&#39;problem&#39; ) ) }) } shinyApp(u, s) 21.7 p:miniUI 21.8 Example Simple working example of gadget (not integrated as Addins in RStudio) library(shiny) library(miniUI) library(ggplot2) ggbrush &lt;- function(data, xvar, yvar) { ui &lt;- miniPage( gadgetTitleBar(&quot;Drag to select points&quot;), miniContentPanel( # The brush=&quot;brush&quot; argument means we can listen for # brush events on the plot using input$brush. plotOutput(&quot;plot&quot;, height = &quot;100%&quot;, brush = &quot;brush&quot;) ) ) server &lt;- function(input, output, session) { # Render the plot output$plot &lt;- renderPlot({ # Plot the data with x/y vars indicated by the caller. ggplot(data, aes_string(xvar, yvar)) + geom_point() }) # Handle the Done button being pressed. observeEvent(input$done, { # Return the brushed points. See ?shiny::brushedPoints. stopApp(brushedPoints(data, input$brush)) }) } runGadget(ui, server) } # just run gadget ggbrush(mtcars, &quot;hp&quot;, &quot;mpg&quot;) # run gadget in paneViewer runGadget(ui, server, viewer = paneViewer(minHeight = 500)) 21.8.1 How to install it as as Addins http://rstudio.github.io/rstudioaddins/ If you want to create your own RStudio addins, all you need to do is: Create an R package, Create some R functions, and Create a file at inst/rstudio/addins.dcf in your package directory, dcf extension: Digital Rights Management Each Addin shoud have file with content like this: Name: Insert %in% Description: Inserts `%in%` at the cursor position. Binding: insertInAddin Interactive: false 21.8.2 rstudioapi - interaction with code getActiveDocumentContext() - Returns information about the currently active RStudio document. See below for more details. insertText(location, text, id = NULL) - Insert text at a specific location within a document. setDocumentContext(text, id = NULL) - Set the contents of a document open in RStudio. The list returned from getActiveDocumentContext() provides the following information about the active RStudio document: id — The unique document id. path — The path to the document on disk. contents — The contents of the document. selection — A list of selections. 21.9 Shiny webPages 21.10 Shiny and markdown See: https://rmarkdown.rstudio.com/authoring_shiny.html 21.10.1 inputs and renders First simplified way with inputs and renders inputPanel( selectInput(&quot;n_breaks&quot;, label = &quot;Number of bins:&quot;, choices = c(10, 20, 35, 50), selected = 20), sliderInput(&quot;bw_adjust&quot;, label = &quot;Bandwidth adjustment:&quot;, min = 0.2, max = 2, value = 1, step = 0.2) ) renderPlot({ hist(faithful$eruptions, probability = TRUE, breaks = as.numeric(input$n_breaks), xlab = &quot;Duration (minutes)&quot;, main = &quot;Geyser eruption duration&quot;) dens &lt;- density(faithful$eruptions, adjust = input$bw_adjust) lines(dens, col = &quot;blue&quot;) }) 21.10.2 Full app from directory shinyAppDir( system.file(&quot;examples/06_tabsets&quot;, package = &quot;shiny&quot;), options = list( width = &quot;100%&quot;, height = 550 ) ) 21.10.3 Full app defined in markdow z &lt;- 100 # IM!! wariable will be seen inside our app shinyApp( ui = fluidPage( actionButton(&#39;a1&#39;,&#39;a1&#39;) ,verbatimTextOutput(&#39;v1&#39;) ) ,server = function(input, output, session){ output$v1 &lt;- renderPrint({ input$a1 list(runif(1), z) }) } ) 21.11 Extensions 21.11.1 p:DT 21.11.1.1 list basic options datatable(data , options = list() , class = &quot;display&quot; , callback = JS(&quot;return table;&quot;) , rownames , colnames , container , caption = NULL , filter = c(&quot;none&quot;, &quot;bottom&quot;, &quot;top&quot;) , escape = TRUE , style = &quot;default&quot; , width = NULL , height = NULL , elementId = NULL , fillContainer = getOption(&quot;DT.fillContainer&quot;, NULL) , autoHideNavigation = getOption(&quot;DT.autoHideNavigation&quot;, NULL) , selection = c(&quot;multiple&quot;, &quot;single&quot;, &quot;none&quot;) , extensions = list() , plugins = NULL , editable = FALSE) 21.11.1.2 editable Here no interaction with server side so changes are not saved!!! .&gt;&gt;&gt;&gt; library(shiny) require(DT) ui &lt;- fluidPage( DT::DTOutput(&#39;dt1&#39;) ,verbatimTextOutput(&#39;v1&#39;)) server &lt;- function(input, output, session) { output$dt1 &lt;- renderDT({DT::datatable( head(iris) , editable = TRUE )}, server = TRUE) # server=TRUE IM!! output$v1 &lt;- renderPrint({ info = input$dt1_cell_edit str(info) # extracting info about cell we have edited i = info$row j = info$col v = info$value list(i, j, v) }) } shinyApp(ui, server) How to save changes on the server side First of all we have to know about event: input$x2_cell_edit . Secondly there is a f:replaceData and f:dataTableProxy DT in opitons must have to set editable=TRUE See: https://yihui.shinyapps.io/DT-edit/ In this example there are three tables with different setting. .&gt;&gt;&gt;&gt; library(shiny) library(DT) shinyApp( ui = fluidPage( title = &#39;Double-click to edit table cells&#39;, # our three tables fluidRow(column(12, h1(&#39;Client-side processing&#39;), hr(), DTOutput(&#39;x1&#39;))), fluidRow(column(12, h1(&#39;Server-side processing&#39;), hr(), DTOutput(&#39;x2&#39;))), fluidRow(column(12, h1(&#39;Server-side processing (no row names)&#39;), hr(), DTOutput(&#39;x3&#39;))) ), server = function(input, output, session) { d1 = iris d1$Date = Sys.time() + seq_len(nrow(d1)) d2 = d3 = d1 # we have three data sets for each of our three tables options(DT.options = list(pageLength = 5)) # we can set global options for DT !!! output$x1 = renderDT(d1, selection = &#39;none&#39;, server = FALSE, editable = TRUE) output$x2 = renderDT(d2, selection = &#39;none&#39;, editable = TRUE) output$x3 = renderDT(d3, selection = &#39;none&#39;, rownames = FALSE, editable = TRUE) # creates a proxy object that can be used to manipulate an existing DataTables instance in a Shiny app, e.g. select rows/columns, or add rows. proxy2 = dataTableProxy(&#39;x2&#39;) observeEvent(input$x2_cell_edit, { info = input$x2_cell_edit str(info) # extracting info about cell we have edited i = info$row j = info$col v = info$value # in next two lines we will update data d2[i, j] &lt;&lt;- DT::coerceValue(v, d2[i, j]) replaceData(proxy2, d2, resetPaging = FALSE) # important }) proxy3 = dataTableProxy(&#39;x3&#39;) observeEvent(input$x3_cell_edit, { info = input$x3_cell_edit str(info) i = info$row j = info$col + 1 # column index offset by 1 v = info$value d3[i, j] &lt;&lt;- DT::coerceValue(v, d3[i, j]) replaceData(proxy3, d3, resetPaging = FALSE, rownames = FALSE) }) } ) 21.11.1.3 selcting columns and rows rows .&gt;&gt;&gt;&gt; ui &lt;- fluidPage( DT::DTOutput(&#39;dt1&#39;) ,verbatimTextOutput(&#39;v1&#39;) ) server &lt;- function(input, output, session) { output$dt1 &lt;- renderDT({ head(diamonds, 20) }) output$v1 &lt;- renderPrint({ input$dt1_rows_selected # if nothing is selected we get NULL }) } shinyApp(ui, server) columns .&gt;&gt;&gt;&gt; ui &lt;- fluidPage( DT::DTOutput(&#39;dt1&#39;) ,verbatimTextOutput(&#39;v1&#39;) ) server &lt;- function(input, output, session) { output$dt1 &lt;- renderDT({ datatable( head(diamonds, 20) , selection = list(target = &#39;column&#39;)) #IM!! }) output$v1 &lt;- renderPrint({ input$dt1_columns_selected # if nothing is selected we get NULL }) } shinyApp(ui, server) rows and columns calls .&gt;&gt;&gt;&gt; ui &lt;- fluidPage( DT::DTOutput(&#39;dt1&#39;) ,verbatimTextOutput(&#39;v1&#39;) ) server &lt;- function(input, output, session) { output$dt1 &lt;- renderDT({ datatable( head(diamonds, 20) , selection = list(target = &#39;cell&#39;)) #IM!! }) output$v1 &lt;- renderPrint({ input$dt1_cell_clicked # if nothing is selected we get NULL }) } shinyApp(ui, server) 21.11.1.4 getting information about table input$tableId_cell_clicked: information about the cell being clicked of the form list(row = row_index, col = column_index, value = cell_value) (example) input\\(tableId_rows_current**: the indices of rows on the current page 3, **input\\)tableId_rows_all: the indices of rows on all pages (after the table is filtered by the search strings) input$tableId_search: the global search string input$tableId_search_columns: the vector of column search strings when column filters are enabled input$tableId_state: the state information of the table (a list containing the search string, ordering and paging information; it is available only if the option stateSave = TRUE is applied to the table) .&gt;&gt;&gt;&gt; fluidPage( title = &#39;Select Table Rows&#39;, h1(&#39;A Client-side Table&#39;), fluidRow( column(6, DT::dataTableOutput(&#39;x1&#39;)), column(6, plotOutput(&#39;x2&#39;, height = 500)) ), hr(), h1(&#39;A Server-side Table&#39;), fluidRow( column(9, DT::dataTableOutput(&#39;x3&#39;)), column(3, verbatimTextOutput(&#39;x4&#39;)) ) ) library(shiny) library(DT) shinyServer(function(input, output, session) { output$x1 = DT::renderDataTable(cars, server = FALSE) # highlight selected rows in the scatterplot output$x2 = renderPlot({ s = input$x1_rows_selected par(mar = c(4, 4, 1, .1)) plot(cars) if (length(s)) points(cars[s, , drop = FALSE], pch = 19, cex = 2) }) # server-side processing mtcars2 = mtcars[, 1:8] output$x3 = DT::renderDataTable(mtcars2, server = TRUE) # print the selected indices output$x4 = renderPrint({ s = input$x3_rows_selected if (length(s)) { cat(&#39;These rows were selected:\\n\\n&#39;) cat(s, sep = &#39;, &#39;) } }) }) 21.11.2 p:rhandsontable rhandsontable in shiny: https://jrowen.github.io/rhandsontable/#shiny Basic Input ui &lt;- fluidPage( rHandsontableOutput(&#39;rh1&#39;) ) se &lt;- function(input, output, session){ output$rh1 &lt;- renderRHandsontable({ # defining data set DF = data.frame( integer = 1:10 ,numeric = rnorm(10) ,logical = rep(TRUE, 10) ,character = LETTERS[1:10] ,factor = factor( letters[1:10] , levels = letters[10:1] , ordered = TRUE) ,factor_allow = factor( letters[1:10] ,levels = letters[10:1] ,ordered = TRUE) ,date = seq( from = Sys.Date() , by = &quot;days&quot; , length.out = 10) ,stringsAsFactors = FALSE) rhandsontable( DF , width = 600 , height = 300) %&gt;% # modifying selected columns hot_col( &quot;factor_allow&quot; # column name , allowInvalid = TRUE) # attributes of column }) } shinyApp(ui, se) Interactive input .&gt;&gt;&gt;&gt; ui &lt;- fluidPage( rHandsontableOutput(&#39;rh1&#39;) ) se &lt;- function(input, output, session){ output$rh1 &lt;- rhandsontable::renderRHandsontable({ if( is.null( input$rh1)){ # jezeli pierwsze uruchomienie i tabela nie istnieje data &lt;- data.frame(a=FALSE, b=TRUE, c=letters[1:10], d=1:10, e = 1:10) rhandsontable(data) }else{ hot &lt;- hot_to_r( input$rh1) # sciagniecie wartosci z wyswietlonej tabeli hot %&lt;&gt;% mutate(e=10 * d) # values in column &#39;e&#39; are calculated using values from column &#39;d&#39; rhandsontable(hot) } }) } shinyApp(ui, se) Sparlines .&gt;&gt;&gt;&gt; ui &lt;- fluidPage( rHandsontableOutput(&#39;rh1&#39;) ) se &lt;- function(input, output, session){ output$rh1 &lt;- renderRHandsontable({ # creating part of data withour chars DF = data.frame( val = 1:10 , bool = TRUE , big = LETTERS[1:10] , small = letters[1:10] , dt = seq(from = Sys.Date(), by = &quot;days&quot;, length.out = 10) , stringsAsFactors = FALSE) # adding column &#39;chart&#39; with charts (called sparklines) DF$chart = c(sapply( 1:5 # five element on each chart ,function(x) jsonlite::toJSON(list( values=rnorm(10) ,options = list(type = &quot;bar&quot;)))), sapply( 1:5 # five element on each chart ,function(x) jsonlite::toJSON(list( values=rnorm(10) ,options = list(type = &quot;line&quot;))))) rhandsontable(DF, rowHeaders = NULL, width = 550, height = 300) %&gt;% hot_col(&quot;chart&quot;, renderer = htmlwidgets::JS(&quot;renderSparkline&quot;)) }) } shinyApp(ui, se) 21.11.2.1 brushing See: https://shiny.rstudio.com/articles/plot-interaction.html Getin information aboout action: input$plot_click input$plot_dblclick input$plot_hover input$plot_brush It works also with p:ggplot2 Click, hover and brush ui &lt;- basicPage( #ui plot - here I select option for type of interaction plotOutput( outputId = &quot;plot1&quot; ,click = &quot;plot_click&quot; # IM!! ,dblclick = &quot;plot_dblclick&quot; ,hover = &quot;plot_hover&quot; ,brush = &quot;plot_brush&quot; ) , br() , tabsetPanel( tabPanel(&quot;click&quot;, verbatimTextOutput(&quot;click&quot;)) ,tabPanel(&quot;dbclick&quot;, verbatimTextOutput(&quot;dbclick&quot;)) ,tabPanel(&quot;hover&quot;, verbatimTextOutput(&quot;hover&quot;)) ,tabPanel(&quot;brush&quot;, verbatimTextOutput(&quot;brush&quot;)) ,tabPanel(&quot;brushed_points&quot;, verbatimTextOutput(&quot;brushed_points&quot;)) ) ) server &lt;- function(input, output) { # rendering plot output$plot1 &lt;- renderPlot({ plot(mtcars$wt, mtcars$mpg) }) # info about interaction output$click &lt;- renderPrint({input$plot_click}) output$dbclick &lt;- renderPrint({input$plot_dblclick}) output$hover &lt;- renderPrint({input$plot_hover}) output$brush &lt;- renderPrint({input$plot_brush}) output$brushed_points &lt;- renderPrint({ # IM!! brushedPoints( mtcars , input$plot_brush , xvar = &quot;wt&quot; , yvar = &quot;mpg&quot; , allRows = FALSE) # If TRUE, the input data frame will have a new column, selected_, which indicates whether the row was inside the brush (TRUE) or outside the brush (FALSE) }) } shinyApp(ui, server) 21.11.3 p:shinyalerts simplified version od shiny modalDialog. .&gt;&gt;&gt;&gt; library(shiny) library(shinyalert) ui &lt;- fluidPage( useShinyalert(), # Set up shinyalert actionButton(&quot;preview&quot;, &quot;Preview&quot;) ) server &lt;- function(input, output, session) { observeEvent(input$preview, { # Show a modal when the button is pressed shinyalert(&quot;Oops!&quot;, &quot;Something went wrong.&quot;, type = &quot;error&quot;) }) } shinyApp(ui, server) 21.11.4 p:shinyAce .&gt;&gt;&gt;&gt; library(shiny) require(shinyAce) ui &lt;- fluidPage( div( # div to change width od Editor aceEditor( outputId = &quot;myEditor&quot; , value = &quot;Initial text for editor here&quot; , mode=&quot;r&quot; # use f:getAceModes to see all available modes , theme=&quot;ambiance&quot; # use f:getAceThemes to see all available themes , height = &#39;300px&#39; , fontSize = 12 , showLineNumbers = TRUE , selectionId = &#39;selected_elements&#39; , cursorId = &#39;cursor_change&#39; ) ,style = &#39;width:400px;&#39;) ,actionButton(&#39;a1&#39;,&#39;a1&#39;) ,verbatimTextOutput(&#39;v1&#39;) ) server &lt;- function(input, output, session) { output$v1 &lt;- renderPrint({ input$a1 code &lt;- isolate(input$myEditor) eval(parse(text=code)) }) } shinyApp(ui, server) 21.11.5 HIT!!! p:shinyWidgets .&gt;&gt;&gt;&gt; require(shiny) require(shinyWidgets) ui &lt;- fluidPage( switchInput(&#39;si&#39;) ,materialSwitch(&#39;ms&#39;) ,pickerInput( inputId = &quot;id&quot;, label = &quot;Select/deselect all options&quot;, choices = LETTERS, options = list(`actions-box` = TRUE), multiple = TRUE) ,checkboxGroupButtons( inputId = &quot;somevalue&quot;, label = &quot;Make a choice :&quot;, choices = c(&quot;Choice A&quot;, &quot;Choice B&quot;, &quot; Choice C&quot;, &quot;Choice D&quot;), justified = TRUE, status = &quot;primary&quot;, checkIcon = list(yes = icon(&quot;ok&quot;, lib = &quot;glyphicon&quot;), no = icon(&quot;remove&quot;, lib = &quot;glyphicon&quot;)) ) ,dropdownButton( tags$h3(&quot;List of Input&quot;), selectInput(inputId = &#39;xcol&#39;, label = &#39;X Variable&#39;, choices = names(iris)), selectInput(inputId = &#39;ycol&#39;, label = &#39;Y Variable&#39;, choices = names(iris), selected = names(iris)[[2]]), sliderInput(inputId = &#39;clusters&#39;, label = &#39;Cluster count&#39;, value = 3, min = 1, max = 9), circle = TRUE, status = &quot;danger&quot;, icon = icon(&quot;gear&quot;), width = &quot;300px&quot;, tooltip = tooltipOptions(title = &quot;Click to see inputs !&quot;) ) ,radioGroupButtons(inputId = &quot;somevalue&quot;, choices = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)) ,actionBttn( &#39;a1&#39; , &#39;a1&#39; , icon = , style = &#39;simple&#39; # simple, bordered, minimal, stretch, jelly, gradient, fill, material-circle, material-flat, pill, float, unite , color = &#39;warning&#39; # default, primary, warning, danger, success, royal , size = &#39;md&#39; # xs,sm, md, lg , block = FALSE) # full width button ) se &lt;- function(input, output, session){} shinyApp(ui, se) Gallery of buttons .&gt;&gt;&gt;&gt; library(shiny) ui &lt;- fluidPage( actionBttn(&#39;a1&#39;,&#39;a1&#39;, icon = icon(name = &#39;address=book&#39;)) ,actionBttn(&#39;a2&#39;,&#39;a2&#39;, style = &#39;simple&#39;, color = &#39;success&#39;) ,actionBttn(&#39;a3&#39;,&#39;a3&#39;, style = &#39;bordered&#39;, color = &#39;success&#39;) ,actionBttn(&#39;a4&#39;,&#39;a4&#39;, style = &#39;minimal&#39;, color = &#39;success&#39;) ,actionBttn(&#39;a5&#39;,&#39;a5&#39;, style = &#39;stretch&#39;, color = &#39;success&#39;) ,actionBttn(&#39;a6&#39;,&#39;a6&#39;, style = &#39;jelly&#39;, color = &#39;success&#39;) ,actionBttn(&#39;a7&#39;,&#39;a7&#39;, style = &#39;gradient&#39;) ,actionBttn(&#39;a8&#39;,&#39;a8&#39;, style = &#39;fill&#39;) ,actionBttn(&#39;a9&#39;,&#39;a9&#39;, style = &#39;material-circle&#39;) ,actionBttn(&#39;a10&#39;,&#39;a10&#39;, style = &#39;material-flat&#39;) ,actionBttn(&#39;a11&#39;,&#39;a11&#39;, style = &#39;pill&#39;) ,actionBttn(&#39;a12&#39;,&#39;a12&#39;, style = &#39;float&#39;, color = &#39;success&#39;) ,actionBttn(&#39;a13&#39;,&#39;a13&#39;, style = &#39;unite&#39;) ) server &lt;- function(input, output, session) {} shinyApp(ui, server) 21.11.6 p:htmlwidgets https://shiny.rstudio.com/articles/#extensions 21.11.7 p:shinydashboard Warning! to generate dynamically manuItem use renderMenu and sidebarMenuOutput!!! NOT renderUI !!!! .&gt;&gt;&gt;&gt; require(shinydashboard) u &lt;- dashboardPage( dashboardHeader(title = &quot;Basic dashboard&quot;, disable = FALSE), #to generate dynamically manuItem use renderMenu and sidebarMenuOutput!!! NOT renderUI !!!! dashboardSidebar(disable = FALSE, sidebarMenu( menuItem( text = &quot;Dashboard&quot; ,tabName = &quot;plot&quot; #tabName correspond witd the same value in tabItem!!! ,icon = icon(&quot;dashboard&quot;)) ,menuItem( text = &quot;Widgets&quot; ,icon = icon(&quot;th&quot;) ,tabName = &quot;text&quot; ,badgeLabel = &quot;new&quot; ,badgeColor = &quot;green&quot;) )), dashboardBody( tabItems( #tabItemx is optional if we want to display boex in dynamic configuration dependent on buttons in menuItem tabItem( tabName = &#39;plot&#39; #tabName correspond witd the same value in MenuItem!!! ,box( title = &#39;plot_box&#39; , plotOutput(&quot;plot1&quot;, height = 250) , width = &#39;100%&#39;, solidHeader = TRUE)), tabItem( tabName = &#39;text&#39; ,box( title = &#39;text_box&#39; , textInput(&#39;text&#39;, &#39;text&#39;, &#39;&#39;) , width = &#39;100%&#39;, solidHeader = TRUE)) ) ) ) s &lt;- function(input, output, session){ output$plot1 &lt;- renderPlot({ ggplot() + geom_density(data=diamonds, aes(x=price)) }) } shinyApp(u, s) Dynamic menu library(shiny) # ========== Dynamic sidebarMenu ========== example from help ui &lt;- dashboardPage( dashboardHeader(title = &quot;Dynamic sidebar&quot;), dashboardSidebar( sidebarMenuOutput(&quot;menu&quot;) ), dashboardBody() ) server &lt;- function(input, output) { output$menu &lt;- renderMenu({ sidebarMenu( menuItem(&quot;Menu item&quot;, icon = icon(&quot;calendar&quot;)) ) }) } shinyApp(ui, server) 21.12 My apps 21.12.1 RAS 21.12.1.1 Building modules manual Most simple example .&gt;&gt;&gt;&gt; # modules ----------------------------------------------------------------- plots_UI &lt;- function( id # f:callModule refers to this label. , label = &#39;my_plot&#39;){ # This is not an ID !!! # f:ns for creating unique ID ns &lt;- NS(id) # list of inputs (remember about putting id into f:ns) tagList( actionButton(ns(&#39;run&#39;), &#39;run&#39;) ,plotOutput(ns(&#39;plot&#39;)) ) } plots_server &lt;- function( input , output , session , api_save_input_values # saving information about inputs values , Notes){ # for notes output$plot &lt;- renderPlot({ input$run hist(rnorm(1000)) }) } # calling modules inside shiny app ---------------------------------------- library(shiny) ui &lt;- fluidPage( plots_UI(&#39;plot_gg_test&#39;) ) server &lt;- function(input, output, session) { callModule( plots_server , &#39;plot_gg_test&#39; , reactive(input$api_save_input_values) , reactive(input$Notes)) } shinyApp(ui, server) error info .&gt;&gt;&gt;&gt; # modules ----------------------------------------------------------------- plots_UI &lt;- function( id # f:callModule refers to this label. , label = &#39;my_plot&#39;){ # This is not an ID !!! # f:ns for creating unique ID ns &lt;- NS(id) # list of inputs (remember about putting id into f:ns) tagList( actionButton(ns(&#39;run&#39;), &#39;run&#39;) # ,numericInput(ns(&#39;value&#39;), value = 1, min = 10, max=1000, step = 50, label = &#39;sample size&#39;) ,textInput(ns(&#39;value&#39;), value = &#39;1&#39;) ,plotOutput(ns(&#39;plot&#39;)) ) } plots_server &lt;- function( input , output , session , api_save_input_values # saving information about inputs values , Notes){ # for notes output$plot &lt;- renderPlot({ input$run error_info(inherits(tryCatch(hist(rnorm(as.numeric(input$value))), error = function(e) e ), &#39;error&#39;), &#39;blad&#39;) }) } # calling modules inside shiny app ---------------------------------------- library(shiny) ui &lt;- fluidPage( plots_UI(&#39;plot_gg_test&#39;) ) server &lt;- function(input, output, session) { callModule( plots_server , &#39;plot_gg_test&#39; , reactive(input$api_save_input_values) , reactive(input$Notes)) } shinyApp(ui, server) Dynamic tabs .&gt;&gt;&gt;&gt; # modules ----------------------------------------------------------------- plots_UI &lt;- function( id # f:callModule refers to this label. , label = &#39;my_plot&#39;){ # This is not an ID !!! # f:ns for creating unique ID ns &lt;- NS(id) # list of inputs (remember about putting id into f:ns) tagList( actionButton(ns(&#39;run&#39;), label = &#39;run&#39;) ,numericInput(ns(&#39;value&#39;), value = 1, min = 10, max=1000, step = 50, label = &#39;sample size&#39;) ,sliderInput(ns(&#39;slid_den&#39;), min = 1, max = 5, value = 1, label = &#39;tabs number&#39;) ,uiOutput(ns(&#39;Plot&#39;)) ) } plots_server &lt;- function( input , output , session , api_save_input_values # saving information about inputs values , Notes){ # for notes # dynamic rendering tabs output$Plot &lt;- renderUI({ ns &lt;- session$ns l.shiny.tabs_without_subtabs( tab_name = &#39;Plot.den_gg.tab.&#39; # this must be unique for each use of function , dynamic = TRUE , number = 5 , slider_input = input$slid_den , ns = ns) }) # rendering plot in selected tab observe({ input$run selected_main_tab &lt;- isolate(input$Plot.den_gg.tab.0) output[[paste0(selected_main_tab,&#39;_t&#39;)]] &lt;- renderPlot({ hist(rnorm(input$value)) }) }) } # calling modules inside shiny app ---------------------------------------- library(shiny) ui &lt;- fluidPage( plots_UI(&#39;plot_gg_test&#39;) ) server &lt;- function(input, output, session) { callModule( plots_server , &#39;plot_gg_test&#39; , reactive(input$api_save_input_values) , reactive(input$Notes)) } shinyApp(ui, server) Static tabs .&gt;&gt;&gt;&gt; # modules ----------------------------------------------------------------- plots_UI &lt;- function( id # f:callModule refers to this label. , label = &#39;my_plot&#39;){ # This is not an ID !!! # f:ns for creating unique ID ns &lt;- NS(id) # list of inputs (remember about putting id into f:ns) tagList( actionButton(ns(&#39;run&#39;), label = &#39;run&#39;) ,numericInput(ns(&#39;value&#39;), value = 1, min = 10, max=1000, step = 50, label = &#39;sample size&#39;) # ,sliderInput(ns(&#39;slid_den&#39;), min = 1, max = 5, value = 1, label = &#39;tabs number&#39;) ,uiOutput(ns(&#39;Plot&#39;)) ) } plots_server &lt;- function( input , output , session , api_save_input_values # saving information about inputs values , Notes){ # for notes # dynamic rendering tabs output$Plot &lt;- renderUI({ ns &lt;- session$ns l.shiny.tabs_without_subtabs( tab_name = &#39;Plot.den_gg.tab.&#39; # this must be unique for each use of function , dynamic = FALSE , number = 5 , slider_input = NULL , ns = ns) }) # rendering plot in selected tab observe({ input$run selected_main_tab &lt;- isolate(input$Plot.den_gg.tab.0) output[[paste0(selected_main_tab,&#39;_t&#39;)]] &lt;- renderPlot({ hist(rnorm(input$value)) }) }) } # calling modules inside shiny app ---------------------------------------- library(shiny) ui &lt;- fluidPage( plots_UI(&#39;plot_gg_test&#39;) ) server &lt;- function(input, output, session) { callModule( plots_server , &#39;plot_gg_test&#39; , reactive(input$api_save_input_values) , reactive(input$Notes)) } shinyApp(ui, server) .&gt;&gt;&gt;&gt; # modules ----------------------------------------------------------------- plots_UI &lt;- function( id # f:callModule refers to this label. , label = &#39;my_plot&#39;){ # This is not an ID !!! # f:ns for creating unique ID ns &lt;- NS(id) # list of inputs (remember about putting id into f:ns) tagList( actionButton(ns(&#39;save_idle&#39;), label = &#39;run_and_save_idle&#39;) ,actionButton(ns(&#39;save_incrementally&#39;), label = &#39;run_and_save_incrementally&#39;) ) } plots_server &lt;- function( input , output , session , api_save_input_values # saving information about inputs values , Notes){ # for notes observe({ data &lt;- dplyr::sample_n(mtcars, 10) # rendering plot in selected tab observeEvent(input$save_idle, { # zapis w trybie idle l.shiny.api.save_data( data = data , data_name = &#39;data_2&#39; # name of data (if there is only one kind of data set to save it is recomended to give empty data_name) , name = &#39;super_Plot&#39; # name of module , if_add_input_val = if(is.null(api_save_input_values)) NULL else api_save_input_values() # this cannot be just input$api_save_input_values because it is from the outide of the module , notes_input = if(is.null(Notes)) NULL else Notes() # this cannot be just input$Notes because this from the outside of the module , api_env = api_env , selected_navbar = NULL # selected_navbar , save_mode = TRUE , isolate(input$Plot_den_gg.select_variable) , isolate(input$slid) ) }) # zapis w trybie nie idle observeEvent(input$save_incrementally,{ l.shiny.api.save_data( data = NULL # nie podaje danych bo tutaj tylko kopiuje dane z idle , data_name = &#39;data_2&#39; # name of data (if there is only one kind of data set to save it is recomended to give empty data_name) , name = &#39;super_Plot&#39; # name of module , if_add_input_val = if(is.null(api_save_input_values)) NULL else api_save_input_values() # this cannot be just input$api_save_input_values because it is from the outide of the module , notes_input = if(is.null(Notes)) NULL else Notes() # this cannot be just input$Notes because this from the outside of the module , api_env = api_env , selected_navbar = NULL # selected_navbar , save_mode = FALSE # save_mode()# this cannot be just input$save_mode because this is from the outside of the module , isolate(input$Plot_den_gg.select_variable) , isolate(input$slid) ) }, label = &#39;save_no_idle&#39;) }) } # calling modules inside shiny app ---------------------------------------- library(shiny) ui &lt;- fluidPage( plots_UI(&#39;plot_gg_test&#39;) ) server &lt;- function(input, output, session) { callModule( plots_server , &#39;plot_gg_test&#39; , reactive(input$api_save_input_values) , reactive(input$Notes)) } shinyApp(ui, server) .&gt;&gt;&gt;&gt; require(l.RAS) f1 &lt;- function(){ x &lt;- 10000 l.RAS::interp_assign_from_local_to_global(destination_variable = &#39;zw&#39;, value_to_assign = x) l.RAS::interp_assign_from_global_to_local(destination_variable = &#39;bb&#39;, value_to_assign = zw) print(bb) } f1() Executing code from input .&gt;&gt;&gt;&gt; validate(need(try(eval(parse(text=paste0(&#39;names_data &lt;- names(&#39;, input$api_df_processing_data, &#39;)&#39;) ))) , &#39;such data set does not exist&#39;)) "],
["interactive-apps-tcltk.html", "Chapter 22 INTERACTIVE APPS tcltk", " Chapter 22 INTERACTIVE APPS tcltk "],
["work-organisation.html", "Chapter 23 WORK ORGANISATION 23.1 Projects 23.2 Packrat 23.3 Creating own packages 23.4 Github 23.5 SVN", " Chapter 23 WORK ORGANISATION 23.1 Projects 23.2 Packrat https://rstudio.github.io/packrat/walkthrough.html 23.2.1 Creating packrat project Step 1 Creating New Project and checking if p:packrat is installed Step 2 Changing project into packrat mode. Figure 23.1: opis z numeracja When we accept ‘packrat’ mode then new directory named ‘packrat’ will be created On the console you will see that: Figure 23.2: Creation of ‘packrat’ files and directory We can create that manually too with f:init. ‘packrat’ directory contains: packrat/packrat.lock: Lists the precise package versions that were used to satisfy dependencies, including dependencies of dependencies. (This file should never be edited by hand!) packrat/packrat.opts: Project-specific packrat options. These can be queried and set with get_opts and set_opts; see ?“packrat-options” for more information. packrat/lib/: Private package library for this project. packrat/src/: Source packages of all the dependencies that packrat has been made aware of. .Rprofile: Directs R to use the private package library (when it is started from the project directory). 23.2.2 Managing packages in packrat ** Installing packages** You can install packages from CRAN or github in regular way. All packages will be downloaded to ‘packrat’ directory in your project. If your project needs to install packages from local directories firt you have to create extra directory (most recommended is to create it in project directory) and the set path to it wih f:set_opts(packrat): packrat::set_opts(local.repos = &quot;&lt;path_to_repo&gt;&quot;) shapshot Packrat should automatically create snapshot of packages. We can do it manually too: packrat::snapshot() Figure 23.3: opis z numeracja To restore snapshot Once your project has a snapshot, you can easily install the packages from that snapshot into your private library at any time. You’ll need to do this, for example, when copying the project to a new computer, especially to one with a different operating system. Let’s simulate this by exiting R and then deleting the library subdirectory in your project. Then launch R from your project directory again. Packrat automates the whole process for you – upon restarting R in this directory, you should see the following output: 23.3 Creating own packages 23.3.1 With RStudio Do tworzenia pakietu wykorzystany narzedzia zaimplementowane w RStudio. Writing an R package from scratch: https://hilaryparker.com/2014/04/29/writing-an-r-package-from-scratch/ Step 1: Warning Istalujemy program (nie jest to pakiet!!!) ‘Rtools’ jezeli nie jest zainstalowany. Jest do pobrania na stronie CRAN-R. Dodatkowo sprawdzamy czy mamy zainstalowany pakiet roxygen2. Figure 23.4: Rtools on CRAN website Step 2: Tworzymy plik z wlasnymi funkcjami (wszystkie w jednym pliku). Plik zapisujemy jako zwykly plik skryptu R-a. Mozna tez dodawac definicje obiektow (np. R6) i ich instancje. Jezeli chcemy aby do naszych funkcji byl dostepny ‘help’ oraz zrobila sie dokumentacja, w naszym pliku dodajemy opis dla kazdej funkcji uzywajac tzw. skladni Roxygen. (wczesniej musimy pamietac o tym czy mamy zainstalowany pakiet roxygen2 !!!) Kazda linika opisu Roxygen zaczyna sie od #' Znakiem @ rozpoczynam kolejne tagi (hasla) naszego ‘help-a’ Wyjatkiem jest piewsza linijka z opisem pod ktora zostawiam jedna linijke wolna. Ponizej przyklad: #&#39; Moja super funkcja do sumowania elementow #&#39; #&#39; @usage function(x1, x2=2) #&#39; @param x1 - pierwszy parametr typu numeric #&#39; @param x2 - drugi parametr typu numeric. Domyslanie ma wartosc 2. #&#39; @return - funkcja zwraca wartosc liczbowa #&#39; @note - moja notatka #&#39; @examples #&#39; # tutaj podaje jakis uzyteczny przyklad (jak widac moze zawierac kilka linije kodu) #&#39; x1 &lt;- 100 #&#39; moja_funkcja(x1) #&#39; @export # definicja mojej funkcji: moja_funkcja &lt;- function(x1, x2 = 2){ x1 + x2 # funkcja sumuje dwa elementy } Nie wszystkie tagi sa obowiazkowe. Ja zawsze daje @usage (zeby wiedziec na szybko jakie sa parametry i jakie maja wartosci domyslne), @examples (zazwyczaj z dzialajacym przykladem) i chyba zawsze daje sie @export. Obowiazkowy tez jest tytul (bez niego nie bedzie sie dalo zbudowac pakietu). Wazne jest zeby zrobic to starannie, bo przy skomplikowanych funkcjach dobry help jest bezcenny. Poza tym nie mozna robic pomylek w samej skladni Roxygen (nie zapominamy o spacji przed @ itp.), bo potem bedziemy sie meczyc z bladami przy budowie. Useful Szkielet takiego komentarza Roxygen mozna wprowadzic automatycznie. Kursor umieszczamy wewnatrz funkcji i nastepnie rozwijamy przycisk ‘różdżki’ i wybieramy ‘Insert Roxygen Skeleton’ Figure 23.5: Inserting skeletons Step 3: Tworzymy nowy Project. W koncowym oknie podajemy sciezke dostepu do pliku gdzie jest nasz kod oraz nazwe i miejsce gdzie powstanie nowy katalog (patrz na ponizsze zrzuty). W utorzonym katalogu beda nowe pliki utworzone po nacisnieciu przysicku ‘Create Project’ niezbedne do dalszej pracy zwiazanej z tworzeniem pakietu. Figure 23.6: Starting of creation Project Figure 23.7: Selecting new project Figure 23.8: Selecting type of new project Figure 23.9: Paths ans names in Project. In (1) we have to provide path for pur file with functions. In (2) we provide path where new project directory will be created Step 4 Zeby dalo sie tworzyc dokumentacje sprawdzamy w ustawieniach czy jest taka mozliwosc (patrz ponizszy zrzut): Figure 23.10: Ad step 4: Settings for Roxygen documentation Step 5: Jezeli wprowadzilismy jakies modyfikacje do naszego pliku z funkcjami (np. dodalismy nowa funkcje, usunelismy, albo zmodyfikowalismy stara) i chcemy odswiezyc projekt klikamy ‘clean and rebuild’. Step 6: Jezeli chcemy dodatkowo zbudowac/odswiezyc nasza dokumentacje Roxygen to klikamy ‘Document’ Figure 23.11: Ad step 5 and 6: Rebuilding package and updating documentation Step 7: Uruchamiamy budowanie ostatecznego katalogu pakietu ktory bedziemy instalowali w R (rysunek ‘build’). Mozna wybrac ‘Build Source Package’ jak i ‘Build Binary Package’ (patrz zrzut). Ja zazwyczj wybieram wersje ‘Binary’. Binary releases contain computer readable version of the application, meaning it is compiled. Source releases contain human readable version of the application, meaning it has to be compiled before it can be used. The source release is the raw, uncompiled code. Figure 23.12: Build new package W wyniku powstanie nowy plik ktory mozna zainstalowac w programie R jak kazdy inny pakiet, ale instalacje robimy nie z repozytorium CRAN ale z lokalnego zrodla. Figure 23.13: Instalation of package from local files Uwagi: Jezeli chcemy dodac wlasne zbiory danych tworzymy katalog ‘data’ w naszym katalogu z projektem. Wklejami tam pliki z danymi najlepiej w formacie txt. Bedzie je mozna po zaladowaniu pakietu wywolac funkcja data(). Jezeli chcemy aby podczas ladowania pakietu ladowaly sie inne pakiety musimy (jeszcze przed utworzeniem pliku zrodlowego ktory bedzie bezposrednio instalowany) w pliku DESCRIPTION (najlepiej otworzyc go notatnikiem) dodac linijke kodu za ‘Maintaner’ wyszczegolniajaca pakiety: Maintainer: Who to complain to yourfault@somewhere.net Depends: shiny, ggplot2 23.3.2 Without RStudio It is possible to create own package without RStudio, but difficult and time-consuming. RStudio tool for doing this i preferable and much better solution. 23.4 Github Swnietny podrecznik o wspolpracy Githuba i Windows pt “Happy Git and GitHub for the useR” (autor Jenny Bryan), jest na stronie http://happygitwithr.com/install-git.html#install-git 23.4.1 Installation and configuration with RStudio Warning! Before installation you must have your own account on Gibtub webpage. Step 1: Install Git for Windows from https://gitforwindows.org/ on your computer. Step 2: Instroduce yourself to Git by writting in shell this code: git config --global user.name &#39;lucas9999&#39; git config --global user.email &#39;memy@wp.pl&#39; git config --global --list Step 3 (optional): Installing Git Client. This is optional but highly recommended. This give us ability to use Version Control. Best choise is Sourcetree from https://www.sourcetreeapp.com/ . Step 4: Make repo in GitHub : Go to https://github.com and make sure you are logged in. Click green “New repository” button. Or, if you are on your own profile page, click on “Repositories”, then click the green “New” button. Repository name: myrepo (or whatever you wish, we will delete this) Public YES Initialize this repository with a README Click big green button “Create repository.” Copy the HTTPS clone URL to your clipboard via the green “Clone or Download” button. Step 5: Detect Git with RStudio. Firs let’s check if RStudio can find the Git executable. File &gt; New Project… Do you see an option to create from Version Control? If yes, good. Select New Directory &gt; Empty Project. Do you see a checkbox “Create a git repository”? If yes, good, CHECK IT. Give this disposable test project a name and click Create Project. Do you see a “Git” tab in the upper right pane, the same one that has “Environment” and “History”? If yes, good. If all looks good it means than RStudio and Git are talking to each other. Keep reading if things don’t go so well or you want to know more. If RStudio did’t detect Git automatically: In shell you command to detect Git location: where git Last time I got path: C:/Program Files/Git/cmd/git.exe. Then tell RStudio where to find it. From RStudio, go to Tools &gt; Global Options &gt; Git/SVN and make sure that the box Git executable points to … the Git executable. Restart RStudio if you make any changes. 23.4.2 Cloning repo from Git account Clone the new GitHub repository to your computer via RStudio In RStudio, start a new Project: File &gt; New Project &gt; Version Control &gt; Git. In the “repository URL” paste the URL of your new GitHub repository. It will be something like this https://github.com/jennybc/myrepo.git. Do you NOT see an option to get the Project from Version Control? Go to chapter 14 for tips on how to help RStudio find Git. Take charge of – or at least notice! – the local directory for the Project. A common rookie mistake is to have no idea where you are saving files or what your working directory is. Pay attention. Be intentional. Personally, I would do this in ~/tmp. I suggest you check “Open in new session”, as that’s what you’ll usually do in real life. Click “Create Project”. This should download the README.md file that we created on GitHub in the previous step. Look in RStudio’s file browser pane for the README.md file. Figure 23.14: Instalation of package from local files 23.4.3 Updates Updating repo after changes in local files To update repo after local changes: 1. Check ‘stages’. If there are some then commit them. 2. Use “push” button to load changes files to your repo. While pushing you will have to log in your git account. Figure 23.15: Git stages to commit Figure 23.16: Committing changes: (1) select changes to commit, (2) add comment for each change, (3) commitm changes Updating local files after changes in repo Just press pull button. 23.4.4 Package to repo If we have existing project how to connect it with our Git account? After that you will have to restart RStudio. Then create new repo on your account but withour README. Then create new branch in RStudio. Figure 23.17: New git branch in RStudio 23.4.5 Deleting repo on Git On GitHub, navigate to the main page of the repository. Repository settings buttonUnder your repository name, click Settings. Repository deletion buttonUnder Danger Zone, click Delete this repository. Read the warnings. Deletion labelingTo verify that you’re deleting the correct repository, type the name of the repository you want to delete. Click I understand the consequences, delete this repository. Figure 23.18: Removing repo from account Next remove your local repo if you want. 23.5 SVN "],
["reports-html.html", "Chapter 24 REPORTS HTML 24.1 Uniwersalia 24.2 Baza elementow 24.3 Own functions", " Chapter 24 REPORTS HTML 24.1 Uniwersalia Znajduja sie tutaj elementy uniwersalne dzialajace niezależnie od werski outputu knitra. Sa elementy z Pandos, Bootstrap jak i utworzone wlasnorecznie funkcje R-owskie typu html (znajdujace sie w plikach o nazwach rozpoczynajacych sie od FUNCTION…html.v). Pliki R-owskie tworzone specjalnie pod szablony sa w rozdziale ‘Szablony’ i znajduja sie w plikach o nazwach ‘FUNCTIONS…html.nazwa_szablonu’. 24.1.1 tekst-formaltowanie 24.1.1.1 wyglad_tekstu tekst przekreslony tekst pochylony tekst pogrubiony mniejsza czcionka subskrypt gorny subskrypt gorny tekst komputerowy czerwony KOD: 1. ~~tekst przekreslony~~ 2. *tekst pochylony* 3. **tekst pogrubiony** 4. &lt;small&gt;mniejsza czcionka&lt;/small&gt; 5. subskrypt &lt;sup&gt;gorny&lt;/sub&gt; 6. subskrypt &lt;sub&gt;gorny&lt;/sub&gt; 7. `tekst komputerowy czerwony` 24.1.1.2 drobiazgi i ozdobniki Nowa linia: dwie spacje i enter Dodatkowa spacja: &amp;nbsp; Linia pionowa: --- Naglowek rodzialu nienumerowany: # My header {.unnumbered} 24.1.2 praktyczne elementy rozne 24.1.2.1 indeksy i chaptery w oparciu o wlasne funkcje 24.1.2.2 notes footnote ^[notatka na koncu strony] sidenotes Zalezy od technologii output. Patrz szablony. tooltip &lt;a href=&quot;#&quot; data-toggle=&quot;tooltip&quot; title=&quot;Another tooltip&quot;&gt;have a&lt;/a&gt; 24.1.2.3 Linki linki do strony [sdca](http://wp.pl) link do rozdzialu [nazwa linku](#nazwa_rozdzialu) link do zdjecia link na email obrazek jako link link wewnetrzny &lt;a id=&#39;ble&#39;&gt;&lt;/a&gt; &lt;a href=&#39;#ble&#39;&gt;link&lt;/a&gt; 24.1.2.4 numeracja rozdzialow //naglowki rozdzialow-numeracja body {counter-reset: h1;} h1 {counter-increment: h1; counter-reset: h2; } h2 {counter-increment: h2; counter-reset: h3; } h3 {counter-increment: h3; counter-reset: h4; } h4 {counter-increment: h4; counter-reset: h5; } h5 {counter-increment: h5; counter-reset: h6; } h6 {counter-increment: h6; } /* usage: enclose content with div class=&quot;heading_numbered&quot; */ h1:before {content:counter(h1)&quot;. &quot;; } h2:before {content:counter(h1)&quot;.&quot;counter(h2)&quot;. &quot;; } h3:before {content:counter(h1)&quot;.&quot;counter(h2)&quot;.&quot;counter(h3)&quot;. &quot;; } h4:before {content:counter(h1)&quot;.&quot;counter(h2)&quot;.&quot;counter(h3)&quot;.&quot;counter(h4)&quot;. &quot;; } h5:before {content:counter(h1)&quot;.&quot;counter(h2)&quot;.&quot;counter(h3)&quot;.&quot;counter(h4)&quot;.&quot;counter(h5)&quot;. &quot;; } h6:before {content:counter(h1)&quot;.&quot;counter(h2)&quot;.&quot;counter(h3)&quot;.&quot;counter(h4)&quot;.&quot;counter(h5)&quot;.&quot;counter(h6)&quot;. &quot;; } h1 {font-size: 14px;} 24.1.3 praca z css i js 24.1.3.1 wprowadzenie kodu css wewnetrzny &lt;style type=&quot;text/css&quot;&gt;...&lt;/style&gt; css zewnetrzny &lt;link rel=&quot;stylesheet&quot; href=&quot;C:/Users/.../bootstrap-theme.min.css&quot; type=&quot;text/css&quot; media=&quot;screen&quot;/&gt; java wenetrzny &lt;script&gt;&lt;/script&gt; java zewnętrzny &lt;script type=&quot;text/javascript&quot; src=&quot;simpletabs_1.3.js&quot;&gt;&lt;/script&gt; 24.1.3.2 CSS-skladnia wiele kolumn w div: -webkit-column-count: 3; -moz-column-count: 3; column-count: 3; marginesy zewnetrzne dla tabel: margin-left: 10px; margin-right:20px; samo margin nie zadziala/ floating: float:left:10px; mozliwe wartosci dislplay: block, inline, inline-block mozliwe wartosci position: fixed, absolute, relative kolor tekstu: color:red; color:rbg(100,210,110); color: #FF0000; zaokraglone narozniki: border-radius: 25px; box-shadow: 3px 3px 3px 3px; text-shadow: 2px 2px 2px; Skladnia table.t1 tr, td, #ble {} Powyzszy kod to odwolanie sie do tr z tabel klasy t1 i do wszystkich elementow td, oraz elementu o id ble 24.1.3.3 ustawienia dla elementow /*cala strona*/ body { background:&quot;bgimage.jpg&quot;; background-color:rgb(255,0,0); font-family : Verdana, Geneva, Arial, Helvetica, sans-serif; margin: 0px; text-decoration: underline; } /*wlasnosci linkow*/ a:link {color:green;} a:visited {color:green;} a:hover {color:red;} a:active {color:yellow;} /*div*/ div { box-shadow: 10px 10px 5px #888888; border:2px solid; border-radius:25px; line-height: 20px; /*odstep miedzy wierszami*/ line-height: normal } 24.1.3.4 ustawienia css tabel table, th, td { border: 1px solid black; / border-color:#98bf21; border-width border-radius:25px; border-width:5px; border-width:medium; border-style:solid; border-top-style:dotted; border-right-style:solid; border-bottom-style:dotted; border-left-style:solid; backpground-color:green; background:url(img_flwr.gif); background-size:80px 60px; background-size:100% 100%; background-repeat:no-repeat; /*repeat|repeat-x|repeat-y|no-repeat|initial|inherit;*/ text-align:right; vertical-align:bottom; /*top*/ padding: 15px; width:100%; height:50px; } **ustawienia w tabeli dla n=tego wiersza** table tr:first-child td{ color:yellow } table tr:last-child td{ color:yellow } table tr:nth-child(2) td{ color:yellow } /* od trzeciego wiersza*/ table tr:nth-child(n+2) td{ color:yellow } /*od drugiego wiersza co trzeci*/ table tr:nth-child(3n+2) td{ color:yellow } table tr:firt-child td{ color:yellow } table tr:nth-child(odd) td{ background-color: red; } table tr:nth-child(even) td{ background-color: blue; } 24.1.3.5 js przyklady tabela z kolorem po najechaniu myszka (dodatkowo zakladam odowlanie do pliku sortable jako ze przykladowa tabela jest tej klasy) &lt;style&gt; table tr:nth-child(odd){ color:red; } tr:hover { background-color: #FFCF8B } tr:selected { background-color: #FFCF8B } td {padding: 5px;} &lt;/style&gt; &lt;script type=&#39;text/javascript&#39;&gt; var trs = document.querySelectorAll(&quot;tr&quot;); for(var i = 0; i &lt; trs.length; i++){ trs[i].addEventListener(&quot;click&quot;, function(){this.className += &quot; selected&quot;;}); } var trs = document.querySelectorAll(&quot;tr&quot;); for(var i = 0; i &lt; trs.length; i++){ trs[i].addEventListener(&quot;click&quot;, function(){ var cn = this.className, thc = &quot; selected&quot;, start_idx = cn.indexOf(thc); if(start_idx == -1) cn += thc; else cn = cn.replace(thc,&quot;&quot;); console.log(&quot;#&quot;+cn(0,start_idx)+&quot;#&quot;); this.className = cn; }); } &lt;/script&gt; &lt;table border=&quot;1&quot; style=&quot;width:300px&quot; class=&#39;sortable&#39; &gt; &lt;tr&gt; &lt;th&gt;Firstname&lt;/th&gt; &lt;th&gt;Lastname&lt;/th&gt; &lt;th&gt;Points&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Eve&lt;/td&gt; &lt;td&gt;Jackson&lt;/td&gt; &lt;td&gt;94&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Eve&lt;/td&gt; &lt;td&gt;uackson&lt;/td&gt; &lt;td&gt;94&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Eve&lt;/td&gt; &lt;td&gt;Jackson&lt;/td&gt; &lt;td&gt;94&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Eve&lt;/td&gt; &lt;td&gt;qackson&lt;/td&gt; &lt;td&gt;94&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 24.1.4 organizacja 24.1.4.1 podzial na czesci 2014-09-11 24.1.4.1.1 Podzial na kolumny z plywnnym przeplywem zawartosci div.dwa { -webkit-column-count: 2; /* Chrome, Safari, Opera */ -moz-column-count: 2; /* Firefox */ column-count: 2; } div.trzy { -webkit-column-count: 3; /* Chrome, Safari, Opera */ -moz-column-count: 3; /* Firefox */ column-count: 3; } aaaaaaa aaaaaaaaa aaaaaaaaaaa aaaaaaaaaa aaaaaaaaaaa aaaaaaaaaa aaaaaaaaaaaa aaaaaaaaaaa aaaaaaaaaaa aaaaaaaaaaa KOD: &lt;style&gt; div.dwa { -webkit-column-count: 2; /* Chrome, Safari, Opera */ -moz-column-count: 2; /* Firefox */ column-count: 2; } div.trzy { -webkit-column-count: 3; /* Chrome, Safari, Opera */ -moz-column-count: 3; /* Firefox */ column-count: 3; } &lt;/style&gt; &lt;div class=&#39;trzy&#39;&gt; aaaaaaa aaaaaaaaa aaaaaaaaaaa aaaaaaaaaa aaaaaaaaaaa aaaaaaaaaa aaaaaaaaaaaa aaaaaaaaaaa aaaaaaaaaaa aaaaaaaaaaa &lt;/div&gt; 24.1.4.1.2 Podzial sztywy na kolumny tresc pierwszej kolumny tresc drugiej kolumny KOD: &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-6&quot;&gt; tresc pierwszej kolumny&lt;/div&gt; &lt;div class=&quot;col-md-6&quot;&gt; tresc drugiej kolumny&lt;/div&gt; &lt;/div&gt; 24.1.5 zdjecia Rysunek &lt;img src=&quot;image.jpg&quot; alt=&quot;Smiley face&quot; height=&quot;90&quot; width=&quot;142&quot; align=&quot;left&quot; Hspace='50'&gt; Rysunek i jego float Służy do tego parametr ‘align’ który przyjmuje wartości: left right center justify Dodatkowo parametr hspace steruje odstępem po obu stronach rysunku, a vspace1 od góry i dołu. Dwa rysunki z opływającym tekstem &lt;figure&gt; &lt;img src=&quot;image.jpg&quot; alt=&quot;Smiley face&quot; height=&quot;90&quot; width=&quot;142&quot; align=&quot;left&quot; Hspace=&#39;50&#39;&gt; &lt;img src=&quot;image.jpg&quot; alt=&quot;Smiley face&quot; height=&quot;90&quot; width=&quot;142&quot; align=&quot;left&quot; Hspace=&#39;50&#39;&gt; &lt;/figure&gt; 24.2 Baza elementow 24.2.1 Kolory 1 #000080 2 #FFDEAD 3 #C71585 4 #3CB371 5 #9370DB 6 #32CD32 7 #B0C4DE 8 #778899 9 #20B2AA 10 #F08080 11 #4B0082 12 #483D8B 13 #FFFF00 24.2.2 Bootstrap-rozne elementy Kolorowe napisy Default Primary Success Info Warning Danger KOD: &lt;span class=&quot;label label-default&quot;&gt;Default&lt;/span&gt; &lt;span class=&quot;label label-primary&quot;&gt;Primary&lt;/span&gt; &lt;span class=&quot;label label-success&quot;&gt;Success&lt;/span&gt; &lt;span class=&quot;label label-info&quot;&gt;Info&lt;/span&gt; &lt;span class=&quot;label label-warning&quot;&gt;Warning&lt;/span&gt; &lt;span class=&quot;label label-danger&quot;&gt;Danger&lt;/span&gt; Oznaczanie skrótów klawiaturowych &lt;kbd&gt;ctr&lt;/kbd&gt; Glypkon search: pushpin: hand-right: circle-arrow-right: wrench: chevron-up: chevron-down: arrow-right: arrow-up: arrow-down: ok: remove: stats: th-list: list-alt: KOD: 1. search: &lt;span class=&quot;glyphicon glyphicon-search&quot;&gt;&lt;/span&gt; 2. pushpin: &lt;span class=&quot;glyphicon glyphicon-pushpin&quot;&gt;&lt;/span&gt; 3. hand-right: &lt;span class=&quot;glyphicon glyphicon-hand-right&quot;&gt;&lt;/span&gt; 4. circle-arrow-right: &lt;span class=&quot;glyphicon glyphicon-circle-arrow-right&quot;&gt;&lt;/span&gt; 5. wrench: &lt;span class=&quot;glyphicon glyphicon-wrench&quot;&gt;&lt;/span&gt; 6. chevron-up: &lt;span class=&quot;glyphicon glyphicon-chevron-up&quot;&gt;&lt;/span&gt; 7. chevron-down: &lt;span class=&quot;glyphicon glyphicon-chevron-down&quot;&gt;&lt;/span&gt; 8. arrow-right: &lt;span class=&quot;glyphicon glyphicon-arrow-right&quot;&gt;&lt;/span&gt; 9. arrow-up: &lt;span class=&quot;glyphicon glyphicon-arrow-up&quot;&gt;&lt;/span&gt; 10. arrow-down: &lt;span class=&quot;glyphicon glyphicon-arrow-down&quot;&gt;&lt;/span&gt; 11. ok: &lt;span class=&quot;glyphicon glyphicon-ok&quot;&gt;&lt;/span&gt; 12. remove: &lt;span class=&quot;glyphicon glyphicon-remove&quot;&gt;&lt;/span&gt; 13. stats: &lt;span class=&quot;glyphicon glyphicon-stats&quot;&gt;&lt;/span&gt; 14. th-list: &lt;span class=&quot;glyphicon glyphicon-th-list&quot;&gt;&lt;/span&gt; 15. list-alt: &lt;span class=&quot;glyphicon glyphicon-list-alt&quot;&gt;&lt;/span&gt; textarea KOD: &lt;textarea name=&quot;comments&quot; id=&quot;comments&quot; style=&quot;width:160px;height:90px;background-color:Cornsilk;&quot;&gt; &lt;/textarea&gt; 24.3 Own functions 24.3.1 Versatile tabela i zakladki l.html.stab(df, red=FALSE,rownames=TRUE, colnames=TRUE, hide=FALSE, title=&quot;table&quot;, title_before=NULL, title_after=NULL) l.html.tabs(k=0, names=NULL) l.html.collapse(code, title=&quot;collapse&quot;, title_before=NULL, title_after=NULL) haslo do indeksu dopuszczalne 3 poziomy zagniedzenia &#39;r l.html.i(c(&#39;f:mode&#39;,&#39;f:typeof&#39;, g:variables!acceptable names&#39;)); zn.) chapter ## &#39;r CHAP(nesting=1, title=&#39;pierwszy&#39;, subtitle=&#39;asdc&#39;, date=&#39;&#39;, type=c(&#39;normal&#39;))&#39; generowanie indeksu i spisu treści i eksport danych do globalnego indeksu l.html.indeks_tabela() if(exists(&#39;indeks_plik&#39;)) l.html.ind_eksp(indeks_plik) l.html.toc() if(exists(&#39;table.chapter&#39;)) CHAP.save() Panele l.html.panel.test(title = &#39;chi kwadrat&#39;, begin_text = &#39;fajny test&#39;, purpose = &#39;rozne&#39;, assumptions = &#39;musi byc odpowiedni rozklad&#39;) l.html.panel.method(title = &#39;ble&#39;, begin_text = &#39;ble&#39;, notions = c(ala=&#39;bleble&#39;,kot=&#39;sdcdsac&#39;)) l.html.panel.syntax(title=&#39;funkcja(pakiet)&#39;, parameters=c(aaa=&#39;[TRUE]-jakis paramert&#39;, bbb=&#39;[FALSE]csdcsc&#39;)) l.html.panel.intro(title=&#39;dsac&#39;, text=&#39;dsc asdc&#39;) l.html.glyp(&#39;search&#39;,&#39;yellow&#39;) "],
["reports-latex.html", "Chapter 25 REPORTS Latex", " Chapter 25 REPORTS Latex "],
["reports-markdown.html", "Chapter 26 REPORTS Markdown 26.1 Chunk options 26.2 Chunks names and references 26.3 Splitting file (child files) 26.4 depenencies between chunks 26.5 Creating chunks dinamically 26.6 Cache 26.7 Extractind R code from chunks of markdown document 26.8 How to change position of TOC 26.9 Other programming languages 26.10 tables", " Chapter 26 REPORTS Markdown 26.1 Chunk options 26.1.1 list of basic options echo eval - if evaluate code background results fig.width fig.height fig.align fig.keep warning message error ref.label R.options autodep cache cache.path cache.lazy engine engine.path 26.1.2 Conditional values of options #If variable &#39;cook&#39; &gt; 1 then run child file &quot;outlier.Rnw&quot; &#39;&#39;&#39;{r, child=if(any(cook&gt;1)) &quot;outlier.Rnw&quot; } &#39;&#39;&#39; 26.1.3 Shortcuts for options names set_alias(w=&#39;fig.width&#39;, h=&#39;fig.height&#39;) 26.1.4 Changing chunk default settings &#39;&#39;&#39;r{setup, include=FALSE} opts_chunk$set(fig.path=&#39;figure/beamer-&#39;,fig.align=&#39;center&#39;,fig.show=&#39;hold&#39;,size=&#39;footnotesize&#39;) options(replace.assign=TRUE,width=90) &#39;&#39;&#39; 26.1.5 Creating list of setting require(knitr) #list &#39;&#39;&#39;{r} opts_template$set( k=list(eval=FALSE, echo=TRUE), #sam kod kot=list(eval=TRUE, echo=TRUE) #zwykły output i kod z thumbnail ) &#39;&#39;&#39; #how to refer to the list &#39;&#39;&#39;{r, opts.label=&quot;kot&quot;} &#39;&#39;&#39; 26.1.6 Function execution after/before chunk # this function if set TRUE displays writing before chunk require(knitr) &#39;&#39;&#39;{r setup, eval=TRUE} require(knitr) knit_hooks$set(play = function(before, options, envir) { if(before) &#39;.&gt;&gt;&gt;&gt;&#39; }) &#39;&#39;&#39; &#39;&#39;&#39;{r, play=TRUE} #dafasf &#39;&#39;&#39; 26.2 Chunks names and references 26.2.1 Rules for names R gives the numers to chunks automatically. We can also specify names for chuns ourselves. Names must be unique. 26.2.2 Cross-references &#39;&#39;&#39;{r A} x&lt;-100 &#39;&#39;&#39; &#39;&#39;&#39;{r B} y&lt;-200 &#39;&#39;&#39; #first type of cross-reference &#39;&#39;&#39;{r} &#39;&#39;&#39; #second type of cross-referense &#39;&#39;&#39;{r, ref.label=c(&quot;A&quot;,&quot;B&quot;)} &#39;&#39;&#39; Cross reference to all chunks #reference to all chunks except the first one. &#39;&#39;&#39;{r, ref.label=all_labels()[-1]} &#39;&#39;&#39; 26.3 Splitting file (child files) &#39;&#39;&#39;{r, child=&#39;sciezka.Rmd&#39;} &#39;&#39;&#39; Note: If we use relative path the point of reference is a file directory you work with(not working directory). 26.4 depenencies between chunks Default auto dependency is used. For more details see ‘Dynamic Documents with R and knitr’, p.71 (chapter 8). 26.5 Creating chunks dinamically See: example in directory 26.6 Cache If document rendering becomes time consuming due to long computations or plots that are expensive to generate you can use knitr caching to improve performance. The documentation knitr chunk and package options describe how caching works and the cache examples (https://yihui.name/knitr/demo/cache/) provide additional details. If you want to enable caching globally for a document you can include a code chunk like this at the top of the document: For individual chunks use cache, cache.path, chache.vars, cache.lazy options. When cache=TRUE, the chunk will only be evaluated in the following scenarios: There are no cached results (either this is the first time running or the results were moved/deleted) The code chunk has been modifed rustuling in a new MD5 digest. For clearnig cache you can use button Figure 26.1: Clearning cache Warning! When you use cache depemdencies between chaunks are very imporatnt. dependson option (NULL; character or numeric): a character vector of chunk labels to specify which other chunks this chunk depends on; this option applies to cached chunks only – sometimes the objects in a cached chunk may depend on other cached chunks, so when other chunks are changed, this chunk must be updated accordingly. autodepth option (FALSE; logical): whether to figure out the dependencies among chunks automatically by analyzing the global variables in the code (may not be reliable) so that dependson does not need to be set explicitly 26.7 Extractind R code from chunks of markdown document require(knitr) purl( file_path = ... , documentation = 1) # 0 for pure code, 1 code with chunk headers, 2 add to code text chunks as roxygen The results will be R file in working directory with extracted R code. 26.8 How to change position of TOC The position of the TOC is fixed in the R Markdown default HTML template. If you want to change its position in the document, you’ll need to modify the template: Make a copy of the R Markdown HTML template to use as a starting point. You can find it by running this R command: system.file(“rmd/h/default.html”, package=“rmarkdown”) Move the $toc section to where you want the table of contents to appear. Save the modified template in the same folder as the document you’re rendering as e.g. lowertitle.html Add template: lowertitle.html to the html_document settings. From the standpoint of the template, all of the document’s content is an atomic unit, so it might be necessary to put any content you want to appear before the TOC in the template itself. 26.9 Other programming languages If you have installed p:reticulate you can use this code: # python, engine.path=&#39;C:/Users/memy/Anaconda3/python.exe&#39; 100 26.10 tables 26.10.1 p:formattable First step: formatting numbers require(formattable) p &lt;- data.frame( id = c(1, 2, 3, 4, 5), name = c(&quot;A1&quot;, &quot;A2&quot;, &quot;B1&quot;, &quot;B2&quot;, &quot;C1&quot;), balance = accounting(c(52500, 36150, 25000, 18300, 7600), format = &quot;f&quot;, digits = 5 ), growth = percent(c(0.3, 0.3, 0.1, 0.15, 0.1555555) , format = &quot;G&quot; # d - liczba calkowita; e format naukowy; f - ulamet - domyslnie dwa miejsca po przecinku (regulowane przez digit) ; # , digits = 5 , flag=&#39;+&#39;), ready = formattable(c(TRUE, TRUE, FALSE, FALSE, TRUE), &quot;yes&quot;, &quot;no&quot;)) p Second step: formatting colors and adding icons df &lt;- data.frame( id = 1:10 ,name = c(&quot;Bob&quot;, &quot;Ashley&quot;, &quot;James&quot;, &quot;David&quot;, &quot;Jenny&quot;, &quot;Hans&quot;, &quot;Leo&quot;, &quot;John&quot;, &quot;Emily&quot;, &quot;Lee&quot;) ,age = c(28, 27, 30, 28, 29, 29, 27, 27, 31, 30) ,grade = c(&quot;C&quot;, &quot;A&quot;, &quot;A&quot;, &quot;C&quot;, &quot;B&quot;, &quot;B&quot;, &quot;B&quot;, &quot;A&quot;, &quot;C&quot;, &quot;C&quot;) ,test1_score = c(8.9, 9.5, 9.6, 8.9, 9.1, 9.3, 9.3, 9.9, 8.5, 8.6) ,test2_score = c(9.1, 9.1, 9.2, 9.1, 8.9, 8.5, 9.2, 9.3, 9.1, 8.8) ,final_score = c(9, 9.3, 9.4, 9, 9, 8.9, 9.25, 9.6, 8.8, 8.7) ,registered = c(TRUE, FALSE, TRUE, FALSE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE) ,stringsAsFactors = FALSE ) formattable( df , list( age = color_tile(&quot;white&quot;, &quot;orange&quot;) , grade = formatter( &quot;span&quot; , style = x ~ ifelse( x == &quot;A&quot; , style(color = &quot;green&quot;, font.weight = &quot;bold&quot;) , NA)) , area(col = c(test1_score, test2_score)) ~ normalize_bar(&quot;pink&quot;, 0.2) , final_score = formatter( &quot;span&quot; # span is a html tag # x represents column of data.frame we want to stylize , style = x ~ style(color = ifelse(rank(-x) &lt;= 3, &quot;green&quot;, &quot;gray&quot;)) , x ~ sprintf(&quot;%.2f (rank: %02d)&quot;, x, rank(-x))) , registered = formatter( &quot;span&quot; , style = x ~ style(color = ifelse(x, &quot;green&quot;, &quot;red&quot;)) # adding icons , x ~ icontext( ifelse(x, &quot;ok&quot;, &quot;remove&quot;) # icon name , ifelse(x, &quot;Yes&quot;, &quot;No&quot;))) # values in column (converted from TRUE/FALSE) ) ) 26.10.2 p:pivottabler require(ggplot2) # zaby byl zbior &#39;diamonds&#39; dostepny require(pivottabler) # tutaj bedzie output w koncoli R-a qpvt( dataFrame = diamonds #zbior diamonds z pakietu ggplot2 ,rows = c(&#39;cut&#39;, &#39;color&#39;) # zmienne grupujace po wierszach ,columns = c(&#39;clarity&#39;) #zmianna grupujaca kolumnowa (oczywiscie moze byc wiecej niz jedna) # ponizej dwa pola obliczeniowe ,calculations = c( &#39;suma&#39;=&#39;sum(price, na.rm=TRUE)&#39; , &#39;min&#39;=&#39;min(price, na.rm=TRUE)&#39;) # c(&quot;Number of Trains&quot;=&quot;n()&quot;, &quot;Maximum Speed&quot;=&quot;max(SchedSpeedMPH, na.rm=TRUE)&quot;) ,totals = &#39;NONE&#39; #list(&quot;x&quot;=&quot;All x&quot;, &quot;y&quot;=&quot;All y&quot;) # informacja o tym czy maja byc podsumowania po kategoriach ) # tutaj to samo jako HTML qhpvt( dataFrame = diamonds #zbior diamonds z pakietu ggplot2 ,rows = c(&#39;cut&#39;, &#39;color&#39;) # zmienne grupujace po wierszach ,columns = c(&#39;clarity&#39;) #zmianna grupujaca kolumnowa (oczywiscie moze byc wiecej niz jedna) # ponizej dwa pola obliczeniowe ,calculations = c( &#39;suma&#39;=&#39;sum(price, na.rm=TRUE)&#39; , &#39;min&#39;=&#39;min(price, na.rm=TRUE)&#39;) # c(&quot;Number of Trains&quot;=&quot;n()&quot;, &quot;Maximum Speed&quot;=&quot;max(SchedSpeedMPH, na.rm=TRUE)&quot;) ,totals = &#39;NONE&#39; #list(&quot;x&quot;=&quot;All x&quot;, &quot;y&quot;=&quot;All y&quot;) # informacja o tym czy maja byc podsumowania po kategoriach ) # Totals can be controlled using the totals argument. This works as follows: # If not specified, then totals are generated for all variables. # To hide all totals, specify totals=NONE. # To specify which variables have totals, specify the names of the variables in a character vector, e.g. in a pivot table containing the variables x, y and z, to display totals only for variables x and z, specify totals=c(&quot;x&quot;, &quot;z&quot;). # To specify which variables have totals and also rename the captions of the total cells, specify a list, e.g. to rename the totals for x to “All x” and y to “All y”, specify totals=list(&quot;x&quot;=&quot;All x&quot;, &quot;y&quot;=&quot;All y&quot;) # # c(&quot;Number of Trains&quot;=&quot;n()&quot;, &quot;Maximum Speed&quot;=&quot;max(SchedSpeedMPH, na.rm=TRUE)&quot;) "],
["reports-officer.html", "Chapter 27 REPORTS Officer 27.1 Word 27.2 Power Point scraping 27.3 Table p:flextable", " Chapter 27 REPORTS Officer p:officer documentation: https://davidgohel.github.io/officer/index.html 27.1 Word 27.1.1 basic operations require(officer) require(ggplot2) library(magrittr) # creating new word document my_doc = read_docx() # default styles in document styles_info(doc) # adding elements gg_plot &lt;- ggplot(iris) + geom_density(aes(x=Petal.Width)) myft &lt;- regulartable( head(mtcars) , col_keys = c(&quot;am&quot;, &quot;carb&quot;, &quot;gear&quot;, &quot;mpg&quot;, &quot;drat&quot; ) # by default is names(data) ) my_doc &lt;- my_doc %&gt;% body_add_par(&#39;Witam. To jest moj wierwszy paragraf w dokumencie wykonanym pakietem officer&#39;) %&gt;% body_add_break() %&gt;% # przejscie do nowej STRONY # add picutre body_add_img(src = &#39;figures\\\\create_project.png&#39;, width = 5, height = 6, style = &quot;centered&quot;) %&gt;% # add paragraph body_add_par(&quot;Hello world!&quot;, style = &quot;Normal&quot;) %&gt;% body_add_par(&quot;&quot;, style = &quot;Normal&quot;) %&gt;% # blank paragraph #add table body_add_table(iris[1:5,], style = &quot;table_template&quot;) %&gt;% body_add_gg(gg_plot) %&gt;% body_add_flextable(myft) # adding elements to our document print(my_doc, target = &quot;first_example.docx&quot;) 27.1.2 using bookmarks and cursors require(officer) require(magrittr) my_doc_1 &lt;- officer::read_docx() my_doc_1 &lt;- my_doc_1 %&gt;% body_add_par(&#39;tekst 1&#39;) %&gt;% body_add_par(&#39;tekst 2&#39;) %&gt;% body_add_par(&#39;tekst 3&#39;) %&gt;% body_bookmark(&#39;moj_znacznik_1&#39;) %&gt;% body_add_par(&#39;tekst 4&#39;) %&gt;% body_add_par(&#39;tekst 5&#39;) %&gt;% body_add_par(&#39;tekst 6&#39;) %&gt;% body_bookmark(&#39;moj_znacznik_2&#39;) %&gt;% body_add_par(&#39;tekst 7&#39;) %&gt;% body_add_par(&#39;tekst 8&#39;) print(my_doc_1, target = &quot;cursors.docx&quot;) # removing part of text with cursor my_doc_2 &lt;- my_doc_1 %&gt;% cursor_bookmark(&#39;moj_znacznik_1&#39;) %&gt;% body_remove() # removing element before cursor print(my_doc_2, target = &quot;cursors_removed.docx&quot;) 27.1.3 merging cells in columns and rows More at: https://davidgohel.github.io/flextable/articles/layout.html columns select_columns &lt;- c(&quot;Species&quot;, &quot;Petal.Length&quot;, &quot;Petal.Width&quot;) myft &lt;- regulartable(iris[46:55,], col_keys = select_columns) # merge cells in columns &#39;spaces&#39; and &#39;Petal.Width&#39; myft &lt;- merge_v(myft, ~ Species + Petal.Width ) myft rows select_columns &lt;- c(&quot;Species&quot;, &quot;Petal.Length&quot;, &quot;Petal.Width&quot;) myft &lt;- regulartable(head(mtcars, n = 10 ) ) myft &lt;- merge_h(myft) # and add borders myft &lt;- border(myft, border = fp_border(), part = &quot;all&quot;) myft colls and rows select_columns &lt;- c(&quot;Species&quot;, &quot;Petal.Length&quot;, &quot;Petal.Width&quot;) myft &lt;- regulartable(head(mtcars, n = 6 ) ) myft &lt;- merge_at( myft, i = 1:3, j = 1:3) myft &lt;- border(myft, border = fp_border(), part = &quot;all&quot;) myft 27.1.4 Headers 27.2 Power Point scraping 27.3 Table p:flextable 27.3.1 Simple table require(officer) require(flextable) # creating of new object myft &lt;- regulartable( head(mtcars) , col_keys = c(&quot;am&quot;, &quot;carb&quot;, &quot;gear&quot;, &quot;mpg&quot;, &quot;drat&quot; ) # by default is names(data) ) myft # changing table layout with theme myft &lt;- theme_vanilla(myft) myft "],
["uwagi-dla-eweliny.html", "A Uwagi dla Eweliny", " A Uwagi dla Eweliny Starałem sie pisać ten manual, żeby był w miarę uprządkowany i łatwy w czytaniu. Ale wszyskiego jest bardzo dużo i wiele elementów jest po prostu na tą chwilę mieszanką roznych materiałów z roznych zrodel pisanych w bardzo roznych okresach czasu. To powoduje zaburzenie ciaglosci i zmniejsza przystepnosc. Format calej “ksiazki” (bo tak to trzeba nazwac) jest na tyle przyjemny, że mysle iż będzie Ci się wygodnie na własna ręką go uzupełniało i rozszerzało. Ten szablon możesz oczywiście smialo używać też przy nauce innych języków programowania. Ja będę go używał do Python i do materiałów związanych z analizą statytyczną (w tej ksiazce o statystyce w R nic nie bedzie - tylko podstawy programowania). Chcialem też w takiej ksiazce gromadzic wiedze z SQL-a, ale z uwagi na to ze zakres materialu ktory mnie interesuje jest maly, nie wiem czy warto. Plik ze snippetami ktory Ci przeslalem na razie mi wystarcza. Tak czy inaczej jezeli bys ten materiał rozwijała po proponuje, żeby się na przyszłość takimi rzeczmi wymieniać. Napewno przyśpieszy nam to zdobywanie wiedzy. Kilka zdan a porpos tego co jest w załącznikach, a zwłaszcza w rodziale o stosowanych OZNACZENIACH To co jest napisane w zalacznikach moze byc dla niektorych troche smieszne i byc przejawem skrajnej pedanterii ale uwierz mi ze to ma sens. Kiedy ilosc informacji którą gromadzisz jest bardzo duża trzeba stosować różne reguły w jej zapisywaniu. Wie to każda osoba która prowadzi np. porządny zeszyt z notatkami. Takie reguły ułatwiają logiczne porządkowanie wszystkiego, zapewniają przejżystość, umożliwiają wprowadzenie hierarchizacji w ważności informacji. Dlatego też takie reguły warto sobie dobrze przemyśleć już na samym początku. Sama “ksiażka” którą teraz oglądasz też powstała jak wynik różnych doświadczeń związanych z gromadzeniem informacji. Kiedyś moja wiedza programistyczna była rozproszona po różnych plikach i zeszycikach. W pewnym momencie było tego tak dużo że zacząłem się w tym wszystkim gubić. Ta książka podobnie jak inne które prowadzę pozwala mi bardzo uporządkowane magazynowanie wiedzy na zdobycie której trzeba przecież poświećić tak wiele pracy i czasu. Potem w takiej książce wszysko mam na wyciągnięcie ręki. Jeszcze jedno. Wiele osob lubi notować papierowo w zeszytach Ale tutaj jak widziesz mamy do czynienia z kodem programistycznym i notowanie tego z zeszycie to słaby pomysł. Kod to rozwiązania które musisz móc szybko sobie przekopiować do wlasnego skryptu. Poza tym tutaj ten cały materiał żyje i cały czas jest mofikowany i udoskonalany. W zeszycie musiałabys albo cały czas kreślić, albo robić na końcu załączniki i byś się w końcu w tym wszyskim pogubiła. Narzędzie elektroniczne są już na tyle rozwinięte, że naprawdę notowanie tutaj jest bardzo wygodne i nie doskwierają nam wieksze ograniczenia. Jak dla mnie na tą chwilę jezeli chodzi o wiedze naukowa/zawodowa, to tylko notowanie rzeczy gdzie trzeba dużo rysować albo pisać wzorów matematycznych powinno sie robic na papierze. Ale to też się powoli zmienia to pokazuje mi mój tablet z rysikiem. "],
["oznaczenia.html", "B Oznaczenia B.1 Oznaczenia odpisowe B.2 Oznaczenia w kodzie", " B Oznaczenia B.1 Oznaczenia odpisowe Opisujac cos slowami posluguje sie nastepujacymi zasadami (to tylko zasady do opisu slownego NIESTOSOWANE w samym programowaniu !!!): “p:” dla pakietow (np. zamiast “pakiet dplyr”&quot; pisze “p:dplyr” ) “f:” dla funkcji (np. zamiast “funkcja max” pisze &quot;f:max)) Jezeli chce pozdac ze cos jest funkcja i jednoczesnie okreslic pakiet robie tak: funkcja summarise z pakietu dplyr zamieniam na. f:summarise(dplyr) Tlumaczenia na na jezyk polski (lub czasem z polskiego na angielski) sa w nawiasach kwadratowyh np.: data.frame [ramka danych]. Warto uczyc sie nazw angielskich, zeby potem szybkiej wyszukiwac informacje w internecie. W ostatnim dodatku bede prowadzil sobie slowniczej. Przy pisaniu tak jak przy programowaniu raczej nie uzywam polskich znakow. Pare razy przez zle ustawienie kodowania w RStudio wszyskie polskie znaki pozamienialy sie na krzaczki i od tego czasu odechcialo mi sie ich uzywania. Poza tym wszystkie nowe materialy staram sie juz pisac po angielsku. Tobie w ramach nauki angielskiego tez cos takiego doradzam. Bedzie Ci sie latwiej wypowiadalo na tematy informatyczne i znacznie latwiej pisalo dokumentacje. Rzeczy istotne sa boldowane Nazwy wlasne itp. sa kursywa pochylona W codzyslowie podaje tytuly publikacji itp. Bloki w ktorych jest kod R-a bede nazywal chunk (wymawiam: czank), zgodnie z ich prawdziwa nazwa w jezyku angielskim. Niektorzy tez uzywaja pojecia Listing. Poza chunk-ami formatowanie czcionki jakie jest w kodach moze pojawic sie w samym teksie. Czesc chunkow jest pisana tak ze po przejlejeniu powinny dzialac. Jezeli mam doczynienia z jakims ciekawszym i wpelni dzialajacym kodem to przed chunkiem jest znak ‘.&gt;&gt;&gt;&gt;’. Czasami jakis wiekszy przyklad moze byc rozbity na wiecej chunkow. Wtedy przed pierwszym chunkiem jest napis ‘BEGIN’ a po ostatnim ‘END’. Niektore kody w chunkach musza byc dlugie zeby zrobic pelny dzialajacy przyklad. Ale istota problemy moze byc zlokalizowana w zaledwie kilku linijkach. Zeby je oznaczyc w komentarza wstawiam znanik ‘IM!!’ Przyklad chunk-a: #tutaj jest przykladowy chunk w ktorym bede pisal kod R-a. Ponadto stosuje kolorowe ramki dla oznaczenia rzeczy istotnych: Warning! jakies wazne ostrzezenie Tip Jakis przydatny trik Useful Jakas ciekawa i uzyteczna informacja, np. fajne zrodlo z informacjami B.2 Oznaczenia w kodzie B.2.1 Packages names before functions names Co do samego programowania to jezeli funkcja pochodzi z jakiegos pakietu ktory trzeba zaladowac wywoluje ja z podaniem nazwy pakietu: dplyr::summarise(data) # f:summarise podchodzi z p:dplyr i mozna ja tak wywolac wlasnie podajac nazwe pakietu przed podwojnym dwukropkiem summarise(data) Po co cos takiego? PO PIERWSZE dla Twojej wygody zebys od razu wiedziala z jakiego pakietu jest dana funkcja. PO DRUGIE czasem wystepuje konflikt polegajacy na tym, ze funkcja o tej samej nazwie jest w dwoch roznych pakietach i zeby byc pewnym co tak naprawde wywolujemy musimy wlasnie podac nazwe pakietu przed podwojnym dwukropkiem. Ale to sie zdarza dosyc rzadko. Przykladem sa p:dplyr i p:plyr gdzie wiele funkcji nazywa sie tak samo. Pytanie jak sprawdzic ile funkcji o tej samej nazwie jest zaladowanych: # laduje 2 pakiety w ktorych wystepuje ta sama f:mutate require(plyr) require(dplyr) # sprawdzam czy jest zaladowana wiecej niz jedna f:mutate getAnywhere(&#39;mutate&#39;) Powyzej domyslnie bedzie uzywana funkcja z p:dplyr, bo zostal zaladowany po p:plyr. Po prostu f:mutate z p:plyr zostala przykrywa przez funkcje z p:dplyr. Takie wiec: mutate(data) # tutaj wywolamy funkcja z p:dplyr plyr::mutate(data) # tak piszemy jezeli chcemy jednak uzyc funkcji z p:plyr B.2.2 Sytem of making variables names zmienne:przedrostki d. - date path. - file/directory path c. - control names: using dots after one dot - type after two dots - source use &#39;_&#39; if the name compare few words variables named with one letter - only for loop counter. B.2.3 System of making comments # from number to number # from capital letter to capital letter (chapters) # one line blow or next to #&gt; opcjonalnie tekst #&lt; bez tekstu #&gt; opcjonalnie tekst #&lt; opcjonalnie tekst ( potrzebne przy zagniezdzaniach zeby sie polapac co gdzie sie konczy) #&gt;b to remove #&lt;e # note (general remarks not direcly concerning a code) "],
["more-about-r.html", "C More about R", " C More about R Dla zaawansowanego uzytownika bezcenny jest internetowy podrecznik: http://adv-r.had.co.nz/ Na stronie RStudio sa tzw. sciagi [cheat sheets] https://www.rstudio.com/resources/cheatsheets/ gdzie w skroconej i przejzystej formie sa pokazane najwazniejsze rzeczy w R. Niektore z nich sa dostepne w samym RStudio: Help -&gt; Cheatsheets. Podobnie jak w przypadku chyba kazdego innego jezyka programowania forum https://stackoverflow.com/ to ogromna skarbnica wiedzy Warto też odwiedzac strony do danych pakietow z funkcjami. Sa najczesciej na stronie tzw. githuba gdzie ludzie rozwijaja te pakiety. Tu jest przykladowo strona dla p:dplyr: https://github.com/tidyverse/dplyr Firma ktora robi program RStudio robi tez wlasne swietne pakiety ktore maja rewelacyjna dokumentacja na ich stronie: https://www.rstudio.com/products/rpackages/ . Do tych pakietow wlicza sie m.in caly czas przede mnie polecany dplyr (czyli sql pod R-em), ggplot2 (wykresy) czy tez makrodown (tworzenie dokumentow/raportow/prezentacji) http://r4ds.had.co.nz/ . Na tej stronie jest fajny podrecznik “R for Data Science” Pisanie wlasnych ksiazek przy uzyciu p:markdown i bookdown: https://bookdown.org/yihui/bookdown/ Warto ogladac filmiki na youtubie Sa tez darmowe albo za niewielka oplata kursy internetowe np. na DataCamp Strona: https://awesome-r.com/#awesome-r-syntax "],
["skroty-klawiaturowe.html", "D Skroty klawiaturowe", " D Skroty klawiaturowe Ponizej sa skroty z ktorych sam najczesciej korzystam alt + strzalka - umozliwia przesuwanie w gore i w dol zaznaczonych linijek kodu ctrl + alt + strzelka - umozliwia rozwiniecie multikursora czyli pisanie w kilku linijkach jednoczesnie alt + znak minus - wstawia znak przypisania ze spacjami po obu stronach ctrl + shift + R - wstawia w skrypcie nowy rozdzial (dziala w pliku bedacym skryptem R-a a nie np. pliku markdown do generowania raportow) ctrl + s - zapisanie zmian w pliku ctrl + Enter - uruchomienie zaznaczonego kodu ctrl + l - w konsoli (tam gdzie kod jest wykonywany, a nie w pliku skryptu) czysci ekran ctr1 + 1 - przejscie kursorem do skryptu z kodem ctrl + 2 - przejcie kursorem do konsoli F1 - kiedy jestesmy kursorem na funkcji to wyswieli nam pomoc w obienku help F2 - kiedy jestesmy kursorem na funkcji to wyswieli nam kod funkcji ctrl + z - cofniecie ostatniej operacji ctrl + F - wyszukiwanie/zamienianie w tekscie - dosyc rozbudowane narzedzie - mozna uzywac wyrazen regularnych [regular expressions] ctrl + shift + F3 - wyszukiwanie w plikach - bardzo użyteczna rzecz. shift + alt + G - przejdz do linii numer. Ja sobie zawsze zmieniam ten skrot na ctrl + G zeby miec tak samo jak w MS SQL. ctrl + shift + C - zamiana linijek kodu na komentrz, lub odkomentowanie jezeli juz mamy komentarz Shift + Ctrl + m - new pipe Ctrl + Alt + i - new chunk in markdown file Alt + o - collapse all collapsible code (e.g. chunks) Shift + Alt + o - expand all collapsible code Pelna lista skrotow jest w: Tools -&gt; Keyboards Shorcuts Help Useful W RStudio mozna sobie modyfikowac skroty i tworzyc swoje wlasne: Tools -&gt; Modify Keyboard Shorcuts "],
["dobre-nawyki.html", "E Dobre nawyki E.1 skladnia w kodzie E.2 Home i End E.3 Rozdzialy E.4 snippets E.5 Projects", " E Dobre nawyki O dobrych nakach w programowaniu w R: https://google.github.io/styleguide/Rguide.xml E.1 skladnia w kodzie Make new line each time it makes code more clear Use spaces after commas and around signs (like &lt;-, + and so on) Dont’t use capital letters in variables names Variables and functions names should be related to their purpose. Make long variables names if it is necessary. E.2 Home i End W programowaniu warto uzywac przyciskow Home i End rzeby szybo przechodzic na poczatek i koniec linijek kodu. E.3 Rozdzialy Warto skrypt z kodem dzielic sobie na rozdzialy (dodawanie skrotem ctrl + shift + R) - dzieki temu stworzymy fajny spis tresci. Poza tym rozdzialy mozemy zwijac i rozwijac przez to przegladanie nawet duzego skryptu jest znacznie wygodniejsze. E.4 snippets Warto je robic dla ulatwianie sobie zycia. Sa w Tools -&gt; Global Options -&gt; Code -&gt; Editing(sam dół tej zakładki) Figure E.1: gdzie znalesc snippety w RStudio E.5 Projects W przyszlosci zrob sobie nawyk zeby kazda wieksza analize robic jako oddzielny Project. Project jest zwartym katalogiem (taka paczka) ktory zapewnie przenoscnowsc. Czyli taki Project mozesz po prostu komus skopiowac na inny komputer i bedzie mu to dzialalo (pod warunkiem ze ma oczywiscie zainstalowne odpowiednie pakiety). Kazdy Project ma swoj wlasny Environment ze zmiennymi wiec nie ma komfliktu miedzy nimi i np. czyszczac pamiec zmiennych w jednym projekcie nie naruszasz innych projektow. "],
["other-things-2.html", "F Other things F.1 Packages instalation F.2 My packages F.3 Categories for index (for the future when adding index is possible)", " F Other things F.1 Packages instalation Uwaga: jezeli instalujemy jakis pakiet i nie wystepuje w podpowiedziach, to wcale nie musi oznaczec ze go nie ma na repozytorium pakietow na CRAN-R. Przyczyna problemy moze byc to ze mamy zbyt stara wersje R-a. Zeby to sprawdzic wchodzi na pakiet na stronie repozytorium i sprawdzamy parametr ‘Depends’ F.2 My packages l.html - generating html code l.s - supporing non graphic functions l.a - analytics function(includig analytical-vizualization functions ) l.g - supporting graphic functions F.3 Categories for index (for the future when adding index is possible) 1. f - function 2. p - package 3. w - warning 4. t - statistical test 5. w - warning 6. tr - trick/tip "],
["things-to-do.html", "G Things to do", " G Things to do Przeczytac koniecznie o najciekawszych nowych pakietach: https://www.r-bloggers.com/jan-2018-top-40-new-package-picks/ https://www.r-bloggers.com/august-2017-new-package-picks/ "],
["dictionary.html", "H Dictionary H.1 EN-PL H.2 PL-EN", " H Dictionary H.1 EN-PL H.2 PL-EN "],
["references.html", "References H.3 R Markdown H.4 Including Plots", " References H.3 R Markdown This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see http://rmarkdown.rstudio.com. When you click the Knit button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this: require(formattable) p &lt;- data.frame( id = c(1, 2, 3, 4, 5), name = c(&quot;A1&quot;, &quot;A2&quot;, &quot;B1&quot;, &quot;B2&quot;, &quot;C1&quot;), balance = accounting(c(52500, 36150, 25000, 18300, 7600), format = &quot;f&quot;, digits = 5 ), growth = percent(c(0.3, 0.3, 0.1, 0.15, 0.1555555) , format = &quot;G&quot; # d - liczba calkowita; e format naukowy; f - ulamet - domyslnie dwa miejsca po przecinku (regulowane przez digit) ; # , digits = 5 , flag=&#39;+&#39;), ready = formattable(c(TRUE, TRUE, FALSE, FALSE, TRUE), &quot;yes&quot;, &quot;no&quot;)) p formattable( df , list( age = color_tile(&quot;white&quot;, &quot;orange&quot;) , grade = formatter( &quot;span&quot; , style = x ~ ifelse( x == &quot;A&quot; , style(color = &quot;green&quot;, font.weight = &quot;bold&quot;) , NA)) , area(col = c(test1_score, test2_score)) ~ normalize_bar(&quot;pink&quot;, 0.2) , final_score = formatter( &quot;span&quot; # span is a html tag # x represents column of data.frame we want to stylize , style = x ~ style(color = ifelse(rank(-x) &lt;= 3, &quot;green&quot;, &quot;gray&quot;)) , x ~ sprintf(&quot;%.2f (rank: %02d)&quot;, x, rank(-x))) , registered = formatter( &quot;span&quot; , style = x ~ style(color = ifelse(x, &quot;green&quot;, &quot;red&quot;)) # adding icons , x ~ icontext( ifelse(x, &quot;ok&quot;, &quot;remove&quot;) # icon name , ifelse(x, &quot;Yes&quot;, &quot;No&quot;))) # values in column (converted from TRUE/FALSE) ) ) H.4 Including Plots You can also embed plots, for example: Note that the echo = FALSE parameter was added to the code chunk to prevent printing of the R code that generated the plot. "]
]
